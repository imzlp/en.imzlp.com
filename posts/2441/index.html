<!DOCTYPE html>
<html lang="en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-tilt-brush.png">
  <link rel="mask-icon" href="/images/favicon-32x32-tilt-brush.png" color="#222">
  <meta name="google-site-verification" content="ttIkhAIFZQM9Huj8roB0l95ePN2Tv2zv2wRFksi09WA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Pacifico:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"en.imzlp.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"width":280},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"code_unfold":{"enable":true,"CODE_MAX_HEIGHT":600},"path":"search.xml"};
  </script>

  <meta name="description" content="From C language to C++03, the OO features feel absolutely great. Recently, I focused on the new features of C++11 and found many fantastic syntactic sugars! It’s also very enjoyable to use.">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11 syntactic sugar">
<meta property="og:url" content="https://en.imzlp.com/posts/2441/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="From C language to C++03, the OO features feel absolutely great. Recently, I focused on the new features of C++11 and found many fantastic syntactic sugars! It’s also very enjoyable to use.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/01.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/02.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/03.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/05.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/07.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/08.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/09.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/10.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/11.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/12.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/13.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/14.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/15.webp">
<meta property="article:published_time" content="2016-05-12T22:30:19.000Z">
<meta property="article:modified_time" content="2016-05-12T22:30:19.000Z">
<meta property="article:author" content="LIPENGZHA">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C++11">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/2441/01.webp">

<link rel="canonical" href="https://en.imzlp.com/posts/2441/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>C++11 syntactic sugar | Z's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDCJ41EFP5"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FDCJ41EFP5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Z's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-edit fa-fw"></i>Notes</a>

  </li>


      
        
            
  <li class="menu-item menu-item-essay">

    <a href="/essay/" rel="section"><i class="fas fa-feather-alt fa-fw"></i>Essay</a>

  </li>


      
        
            
  <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-inbox fa-fw"></i>Resources</a>

  </li>


      
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fas fa-link fa-fw"></i>Friends</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me</a>

  </li>


      
        <li class="menu-item menu-item-showcase">

    <a href="/showcase/" rel="section"><i class="fa fa-solid fa-trophy fa-fw"></i>ShowCase</a>

  </li>
        <li class="menu-item menu-item-changelog">

    <a href="/changelog/" rel="section"><i class="fa fa-history fa-fw"></i>Site Log</a>

  </li>
        <li class="menu-item menu-item-opensource">

    <a href="/opensource/" rel="section"><i class="fas fa-code-branch fa-fw"></i>Open Source</a>

  </li>
        <li class="menu-item menu-item-uewiki">

    <a href="https://ue5wiki.com/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>Unreal Wiki</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>



<script type="text/javascript">
  let domain='en.imzlp.com';
  let domain_str = atob(domain);
  let pathname = location.pathname;
  if (domain_str!= location.host.toLowerCase()){
        console.log(`this host is not safe,jump to https://${domain_str}${pathname}`);
        location.href=`https://${domain_str}${pathname}`;
  }
</script>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <div class="l10n-header-widget">
    <script>
      // 获取当前页面的 URL
      const currentUrl = window.location.href;
      // 替换 URL 中的部分内容
      const jumpToL10nLink = currentUrl.replace('en.imzlp.com', 'imzlp.com');
      // 将 jumpToL10nLink 绑定到一个全局变量
      window.jumpToL10nLink = jumpToL10nLink;
    </script>

    <a href="#" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: none;" rel="noopener" target="_blank" onclick="window.open(window.jumpToL10nLink, '_blank'); return false;">
      <i class="fa fa-solid fa-language"></i>
    </a>
  </div>



    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en"
  >
    <link itemprop="mainEntityOfPage" href="https://en.imzlp.com/posts/2441/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
      <meta itemprop="name" content="LIPENGZHA">
      <meta itemprop="description" content=""I think, therefore I am"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++11 syntactic sugar<a href="https://github.com/imzlp/blog-md/blob/en/_posts/2016-05-12-2441.md" class="post-edit-link" title="Edit this post" style="float: right;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a><a href="https://imzlp.com/posts/2441/" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-solid fa-language"></i></a>
        </h1>

        
          <div class="post-subtitle" style="text-align: center;line-height: 1;">
            <sub text-align="center" style="font-size: 15px;align-content: center;font-style: italic;bottom: 0em;">C++11的语法糖</sub>
          </div>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 22:30 22:30:19:30" itemprop="dateCreated datePublished" datetime="2016-05-12T22:30:19+00:00">2016-05-12 22:30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span id="/posts/2441/" class="post-meta-item leancloud_visitors" data-flag-title="C++11 syntactic sugar" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>44k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1:50</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>From C language to C++03, the OO features feel absolutely great. Recently, I focused on the new features of C++11 and found many fantastic syntactic sugars! It’s also very enjoyable to use.</p>
<span id="more"></span>

<h3 id="List-Initialization"><a href="#List-Initialization" class="headerlink" title="List Initialization"></a>List Initialization</h3><h4 id="List-Initialization-1"><a href="#List-Initialization-1" class="headerlink" title="List Initialization"></a>List Initialization</h4><p>As part of the C++11 standard, <strong>list initialization (using braces to initialize variables)</strong> has been comprehensively applied. This method is indeed very comfortable to use, for example, when initializing a vector template, you can either use a container to initialize it or initialize it to the value of N elements.</p>
<p>List initialization can prevent <code>narrowing conversions</code>, which means:</p>
<ul>
<li>If an integer type cannot store the value of another integer type, the latter will not be converted to the former. For example, char can be converted to int, but int cannot be converted to char.</li>
<li>If a floating-point type cannot store the value of another floating-point type, the latter will not be converted to the former. For example, float can be converted to double, but double cannot be converted to float.</li>
<li>Floating-point values cannot be converted to integer values.</li>
<li>Integer values cannot be converted to floating-point values.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++03 standard, constructor of containers</span></span><br><span class="line">C&lt;T&gt; C; 	<span class="comment">// Create an empty container, calling the default constructor</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(c2)</span></span>;	<span class="comment">// Create a copy of a container, c and c2 must have the same container type</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(b,e)</span></span>;	<span class="comment">// Create a container that takes two iterator parameters to initialize c with a part of another container (the range indicated by b, e iterators)</span></span><br><span class="line"><span class="comment">// The following construction methods only apply to sequential containers</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(n,t)</span></span>;	<span class="comment">// Create a container with n elements, all initialized to t; value t must be of the element type of container c, or convertible to that type</span></span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(n)</span></span>;		<span class="comment">// Create a container with n values initialized elements.</span></span><br></pre></td></tr></table></figure>

<p>The list initialization supported by C++11 standard:</p>
<p>The form of list initialization is <code>C c&#123;element-List&#125;;</code> or <code>C c=&#123;element-List&#125;;</code></p>
<p><strong>Note: Be sure to use braces; using parentheses for initialization has a completely different meaning.</strong></p>
<p>When we use the <code>auto</code> keyword to deduce the type of a variable from an initializer, there’s no need to adopt the list initialization method. Moreover, if the initializer is a <code>&#123;&#125;</code> list, the deduced data type is definitely not what we want.</p>
<blockquote>
<p>When using auto, do not use list initialization; using <code>=</code> in auto is a better choice unless you are sure that it gives you the desired result.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> z1&#123;<span class="number">99</span>&#125;;	<span class="comment">// z1&#x27;s type is initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> z2=<span class="number">99</span>;	<span class="comment">// z2&#x27;s type is int</span></span><br></pre></td></tr></table></figure>
<p>Additionally, when constructing objects of certain classes, there may be two forms:</p>
<ol>
<li>Providing a set of initial values.</li>
<li>Providing several parameters.</li>
</ol>
<p>Pay attention to the distinction between the following two expressions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Be sure to distinguish these two meanings completely</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intVec_1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// intVec_1 has 10 elements, each value is 0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; intVec_2&#123;<span class="number">10</span>&#125;; <span class="comment">// intVec_2 has one element, its value is 10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival&#123;<span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">// List initialization of containers</span></span><br><span class="line">vector&lt;string&gt; strvec&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vecInt=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">list&lt;string&gt; strlist=&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;World&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>If the above code is compiled without adding <code>std=c++11</code>, four errors will occur:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/01.webp"></p>
<p>When using the C++11 standard, you have to add <code>std=c++11</code>, and compilation will not generate errors.</p>
<p>Run and output the initialized objects and containers above:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/02.webp"></p>
<h4 id="Initializer-List"><a href="#Initializer-List" class="headerlink" title="Initializer List"></a>Initializer List</h4><p>The new standard for C++ specifies using an initializer list enclosed in braces as the right operand of assignment statements.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; intVec;</span><br><span class="line">intVec=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>List assignment statements cannot be used for narrowing conversions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="comment">// error: type &#x27;double&#x27; cannot be narrowed to &#x27;int&#x27; in initializer list</span></span><br><span class="line">k=&#123;<span class="number">3.14</span>&#125;;</span><br><span class="line"><span class="comment">// Value initialization of ivalInit</span></span><br><span class="line"><span class="type">int</span> ivalInit=&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>If the left operand is a built-in type, the initializer list can contain at most one value, and that value must not occupy more space than the target type space even if converted. The type conversion still refers to <a target="_blank" rel="noopener" href="https://imzlp.com/2016/05/04/type-convert-in-cpp/">detailed analysis of type conversion in C++</a>.</p>
<p>Regardless of the type of the left operand, the initializer list can be empty. In this case, the compiler creates a value-initialized temporary variable and assigns it to the left operand.</p>
<p>A list defined by <code>&#123;&#125;</code> can serve as an actual argument for the following parameter types:</p>
<ol>
<li>Type <code>std::initializer_list&lt;T&gt;</code>, where the list values can implicitly convert to T.</li>
<li>Types that can be initialized by the values in the list.</li>
<li>References to arrays of type T, where the list values can implicitly convert to T.</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(initializer_list&lt;T&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  string s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(S)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T (&amp;r)[N])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);  <span class="comment">// T is int, initializer_list size is 4</span></span><br><span class="line">  <span class="built_in">f2</span>(&#123;<span class="number">1</span>, <span class="string">&quot;MKS&quot;</span>&#125;);    <span class="comment">// f2(S&#123;1, &quot;MKS&quot;&#125;);</span></span><br><span class="line">  <span class="built_in">f3</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);  <span class="comment">// T is int, N is 4</span></span><br><span class="line">  <span class="built_in">f4</span>(&#123;<span class="number">1</span>&#125;);           <span class="comment">// f(int(1))</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If ambiguity exists, functions with initializer_list parameters are preferred.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(initializer_list&lt;T&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f1</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);  <span class="comment">// T is int, initializer_list size is 4</span></span><br><span class="line">  <span class="built_in">f4</span>(&#123;<span class="number">1</span>&#125;);           <span class="comment">// T is int, initializer_list size is 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The reason for preferring functions with initializer_list parameters is that if selecting functions based on the number of elements in the list, the selection process can become quite confusing. During overload resolution, it is difficult to eliminate all potential ambiguities, but giving highest priority to <code>initializer_list</code> parameters when encountering {} list can minimize such conflicts.</p>
<h4 id="Return-Value-of-List-Initialization"><a href="#Return-Value-of-List-Initialization" class="headerlink" title="Return Value of List Initialization"></a>Return Value of List Initialization</h4><p>C++11 stipulates that functions can return a value list enclosed in braces.</p>
<p>From the concept of <code>initializer list</code>, it follows that if the list is empty, value initialization is performed on built-in types; otherwise, the returned value is determined by the function’s return type.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">&quot;X &gt; 0&quot;</span>, <span class="string">&quot;Yes&quot;</span>&#125;;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">return</span> &#123;<span class="string">&quot;X &lt; 0&quot;</span>, <span class="string">&quot;NO&quot;</span>&#125;;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> &#123;<span class="string">&quot;X = 0&quot;</span>, <span class="string">&quot;ZERO&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We call process, we get</span></span><br><span class="line">vector&lt;string&gt; test = <span class="built_in">process</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : test)</span><br><span class="line">	cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>The result is: <code>X &gt; 0,Yes</code></p>
<h4 id="List-Initialization-of-Associative-Containers"><a href="#List-Initialization-of-Associative-Containers" class="headerlink" title="List Initialization of Associative Containers"></a>List Initialization of Associative Containers</h4><p>When defining a map, both the key type and value type must be specified; for a set, only the key type needs to be indicated, as there are no values in a set.</p>
<p>Each associative container has a default constructor that creates an empty container of the specified type. Associative containers can also be initialized as a copy of another container of the same type or from a range of values, as long as those values can be converted to the required container type.</p>
<p>Under the new standard, we can value-initialize associative containers:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Empty container</span></span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;</span><br><span class="line"><span class="comment">// List initialization</span></span><br><span class="line">set&lt;string&gt; exclude = &#123;<span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;or&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;The&quot;</span>, <span class="string">&quot;But&quot;</span>, <span class="string">&quot;And&quot;</span>, <span class="string">&quot;Or&quot;</span>, <span class="string">&quot;An&quot;</span>, <span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// Three elements; authors map surnames to first names</span></span><br><span class="line">map&lt;string, string&gt; authors = &#123;&#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;, &#123;<span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;, &#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Return-Type-of-List-Initialization-Pair"><a href="#Return-Type-of-List-Initialization-Pair" class="headerlink" title="Return Type of List Initialization Pair"></a>Return Type of List Initialization Pair</h4><p>Imagine a function needs to return a pair. Under the new standard (C++11), we can perform list initialization for the return value.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Process v</span></span><br><span class="line">	<span class="keyword">if</span> (!v.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="comment">// back returns a reference to the last element of the container, front returns the first</span></span><br><span class="line">		<span class="keyword">return</span> &#123;v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>()&#125;;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Implicitly construct and return an empty pair</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If v is not empty, we return a pair composed of the last string in v and its size. Otherwise, we implicitly construct an empty pair and return it.</p>
<p>In earlier versions of C++, it was not allowed to use braces to return an object of type pair; the return value had to be explicitly constructed:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!v.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// You could also use make_pair to generate the pair object; the types of the pair are taken from the parameters of make_pair.</span></span><br><span class="line"><span class="keyword">if</span> (!v.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="built_in">make_pair</span>(v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="nullptr-Constant"><a href="#nullptr-Constant" class="headerlink" title="nullptr Constant"></a>nullptr Constant</h3><p>Before C++11, literal 0 or NULL was used to initialize/assign a pointer to a <strong>null pointer</strong>.</p>
<p><strong>NULL</strong> is a preprocessor variable defined in cstdlib, with a value of 0. When a preprocessor variable is used, it is automatically replaced by the preprocessor with the actual value, so initializing a pointer with NULL is the same as initializing it with 0.</p>
<p><strong>Assigning an int variable to a pointer is an incorrect operation, even if the value of that variable happens to be 0.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="number">0</span>;	<span class="comment">// Initialize p1 with the literal value 0</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="literal">NULL</span>;	<span class="comment">// Equivalent to int *p2 = 0;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>The C++11 standard introduced the nullptr literal constant that can be used to initialize pointers to null.</p>
<p>nullptr is a special type of literal that can be converted to any other pointer type.</p>
</blockquote>
<p>Using nullptr to initialize a pointer:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">nullptr</span>;	<span class="comment">// Equivalent to int *p = 0;</span></span><br></pre></td></tr></table></figure>

<p><strong>Note: Using uninitialized pointers is a significant cause of runtime errors. All pointers should be initialized, and a pointer should be immediately set to null after deletion; otherwise, accessing it again can lead to errors (dangling pointer).</strong></p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><h4 id="constexpr-Variables"><a href="#constexpr-Variables" class="headerlink" title="constexpr Variables"></a>constexpr Variables</h4><p>A <strong>constant expression (const expression)</strong> refers to an expression whose value does not change and can be computed during the <strong>compilation process</strong>.</p>
<p>Evidently, <strong>literals</strong> belong to constant expressions, while const objects initialized with constant expressions are also constant expressions.</p>
<p>Whether an object or expression is a constant expression is determined by <strong>its data type and initial value</strong>.</p>
<p>When constexpr appears in a function definition, it means “if a constant expression is given as a parameter, then the function should be usable in a constant expression.” When constexpr appears in an object definition, it indicates “evaluating the initializer at compile time.”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_NUM = <span class="number">20</span>; <span class="comment">// MAX_NUM is a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = MAX_NUM + <span class="number">1</span>; <span class="comment">// MAX is also a constant expression</span></span><br><span class="line"><span class="type">int</span> ival = <span class="number">20</span>; <span class="comment">// ival is not a constant expression; it is a variable</span></span><br></pre></td></tr></table></figure>

<p>The C++11 standard stipulates that variables can be declared as <code>constexpr</code> types to allow the compiler to verify whether the value is a constant expression.</p>
<p>A variable declared as <code>constexpr</code> must be a constant and must be initialized with a constant expression.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ival = <span class="number">20</span>; <span class="comment">// 20 is a constant expression</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> limit = ival + <span class="number">1</span>; <span class="comment">// ival + 1 is a constant expression</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ival_2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> = ival_2;	<span class="comment">// Will produce an error; only correct if the right-hand side value is constexpr</span></span><br></pre></td></tr></table></figure>

<h4 id="constexpr-Pointers"><a href="#constexpr-Pointers" class="headerlink" title="constexpr Pointers"></a>constexpr Pointers</h4><p>In a constexpr declaration, if a pointer is defined, the constexpr qualifier only applies to the pointer itself, not to the object it points to.</p>
<p>constexpr makes the pointer object <strong>top-level const</strong> (the pointer cannot be modified, while the object it points to can be modified).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p is a pointer to a constant integer; the pointer can be modified, but the object it points to cannot be modified</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// q is a constant pointer to an integer; the pointer cannot be modified, but the object it points to can be modified.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<h4 id="constexpr-Functions"><a href="#constexpr-Functions" class="headerlink" title="constexpr Functions"></a>constexpr Functions</h4><p>A <code>constexpr function</code> is a function that can be used in constant expressions; the function must be simple enough to be evaluated at compile time.</p>
<p>The definition of a constexpr function is similar to others but must follow several regulations:</p>
<ul>
<li>The function’s <strong>return type</strong> and <strong>all parameter types</strong> must be <strong>literal types</strong>.</li>
<li>The function body <strong>must contain only one return statement</strong>.</li>
<li>No loops or local variables are allowed.</li>
<li>constexpr should have no side effects (cannot write to non-local objects).</li>
<li>Recursion and conditional expressions are allowed.</li>
</ul>
<p>In other words, constexpr functions should be pure functions.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> glob;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">bad1</span><span class="params">(<span class="type">int</span> a)</span> <span class="comment">// error: constexpr function cannot be void</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  glob = a; <span class="comment">// error: side effect in constexpr function</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">bad2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt;= <span class="number">0</span>) <span class="keyword">return</span> a; <span class="keyword">else</span> <span class="keyword">return</span> −a; <span class="comment">// error: if-statement in constexpr function</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">bad3</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sum = <span class="number">0</span>; <span class="comment">// error: local variable in constexpr function</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a; ++i) sum += <span class="built_in">fac</span>(i); <span class="comment">// error: loop in constexpr function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> sz = <span class="built_in">new_sz</span>(); <span class="comment">// Correct; sz is a constant expression</span></span><br></pre></td></tr></table></figure>

<p>The compiler replaces calls to constexpr functions with their resulting values. To enable expansion during compilation, <code>constexpr functions</code> are implicitly specified as <code>inline functions</code>.</p>
<p>The body of a constexpr function can also include other statements, as long as those statements do not perform any operations at runtime.</p>
<p>Empty statements, type aliases, and using declarations are allowed in constexpr functions.</p>
<p>We allow the return value of constexpr functions to not be a constant:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If scale receives constant expressions as parameters, scale(const-parameter) is also a constant expression.</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt; &#125;</span><br></pre></td></tr></table></figure>

<p>When the argument of scale is a constant expression, its return value is a constant expression; otherwise, it is not.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct; the return value of scale(2) is a constant expression, and the compiler replaces the call to the scale function with the corresponding result value.</span></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)]; <span class="comment">// Incorrect; the return value of scale(i) is not a constant expression</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>A constexpr function does not necessarily return a constant expression.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> x = <span class="built_in">scale</span>(i); <span class="comment">// Error; the call to scale with argument i does not return a constexpr</span></span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/03.webp"></p>
<p>constexpr can return a reference or pointer:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span>* <span class="title">addr</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; r)</span> </span>&#123; <span class="keyword">return</span> &amp;r; &#125; <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>But this violates the intent of constexpr functions being evaluated as constant expressions.</p>
<p>Conditions outside of constexpr functions will not be evaluated at compile time, meaning they may request runtime evaluation.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (low &lt;= i &amp;&amp; i &lt; high) ? i : <span class="keyword">throw</span> <span class="built_in">out_of_range</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> high = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ival = <span class="built_in">check</span>(<span class="built_in">f</span>(x, y, z));</span><br></pre></td></tr></table></figure>

<h4 id="Constexpr-Constructors"><a href="#Constexpr-Constructors" class="headerlink" title="Constexpr Constructors"></a>Constexpr Constructors</h4><p>Compared with ordinary constexpr functions, constexpr constructors have distinctions: they are only allowed to perform simple member initialization operations.</p>
<p>Although constructors cannot be const (if the member function is const, it means the class’s internal data members cannot be modified), a constructor of a literal type can be a constexpr function.</p>
<p>A literal type must provide at least one constexpr constructor, which must be simple enough to qualify as constexpr, meaning <strong>its body must be empty, and all members must be potentially initialized with constant expressions</strong>.</p>
<p>Constexpr constructors can be declared as <code>=default</code> (compiler-synthesized default constructor) or <code>=delete</code> (deleted function). <strong>Otherwise, a constexpr constructor must meet both constructor and constexpr function requirements (which means the only executable statement it can have is a return statement).</strong></p>
<p>Thus, the body of a constexpr constructor must be empty.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b = <span class="literal">true</span>)</span> : hw(b), io(b), other(b) &#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> h, <span class="type">bool</span> i, <span class="type">bool</span> o)</span> : hw(h), io(i), other(o) &#123;</span>&#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">any</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hw || io || other; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">const</span> Debug&amp;)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_io</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; io = b; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_hw</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; hw = b; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set_other</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123; other = b; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">bool</span> hw; <span class="comment">// Hardware error</span></span><br><span class="line">	<span class="type">bool</span> io; <span class="comment">// IO error</span></span><br><span class="line">	<span class="type">bool</span> other; <span class="comment">// Other errors</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Constexpr must initialize all data members, with initial values using a constexpr constructor or through a constant expression.</strong></p>
<p>Constexpr constructors are used to generate constexpr objects and the parameters or return types of constexpr functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">io_sub</span><span class="params">(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">true</span>)</span></span>; <span class="comment">// Debugging IO</span></span><br><span class="line"><span class="keyword">if</span> (io_sub.<span class="built_in">any</span>()) &#123; <span class="comment">// Equivalent to if (true)</span></span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;print appropriate error messages&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">prod</span><span class="params">(<span class="literal">false</span>)</span></span>; <span class="comment">// No debugging</span></span><br><span class="line"><span class="keyword">if</span> (prod.<span class="built_in">any</span>()) &#123; <span class="comment">// Equivalent to if (false)</span></span><br><span class="line">	cerr &lt;&lt; <span class="string">&quot;print an error message&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>For member functions, constexpr implicitly implies const.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No need to explicitly write const</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">Debug::max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Address-Constant-Expressions"><a href="#Address-Constant-Expressions" class="headerlink" title="Address Constant Expressions"></a>Address Constant Expressions</h4><p>The addresses of global variables and statically allocated objects are constants. These addresses are assigned by the <code>linker</code>, not the compiler. Therefore, the compiler does not know the value of such address constants, limiting the use of pointer or reference types in constant expressions. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* p2 = p1;  <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* p3 = p1 + <span class="number">2</span>;  <span class="comment">// Error; the compiler does not know the value of p1.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">char</span> c = p1[<span class="number">2</span>]; <span class="comment">// ok, c == &#x27;l&#x27;, the compiler knows the value of p1.</span></span><br></pre></td></tr></table></figure>

<h3 id="Type-Deduction"><a href="#Type-Deduction" class="headerlink" title="Type Deduction"></a>Type Deduction</h3><p>C++11 introduced two methods of type deduction—<strong>auto and decltype</strong>, but they serve different purposes.</p>
<p><strong>The role of auto:</strong> It deduces the type of the expression on the right side of the equals sign (the result).</p>
<p><strong>The role of decltype:</strong> It obtains the type through existing expressions.</p>
<p><strong>Important differences between decltype and auto:</strong></p>
<ul>
<li>When decltype uses a variable expression, it returns the type of that variable (including const and references), while auto returns the type of the final result of the expression (ignoring top-level const attributes and applying type conversion).</li>
<li>The result type of decltype tightly correlates with the expression form.</li>
</ul>
<h4 id="Auto-Type-Specifier"><a href="#Auto-Type-Specifier" class="headerlink" title="Auto Type Specifier"></a>Auto Type Specifier</h4><p>As a statically typed language, C++ requires us to know the variable’s type at the time of its definition.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> dval = <span class="number">11.11</span>;</span><br></pre></td></tr></table></figure>

<p>C++11 introduced a new type specifier <strong>auto</strong>, which allows the compiler to analyze the type of the expression for us.</p>
<p>Unlike type specifiers that correspond to a specific type, <code>auto</code> allows the compiler to deduce a variable’s type from its initializer.</p>
<p><strong>Note: A variable defined as auto must have an initializer.</strong></p>
<p>When using the auto specifier to deduce type, sometimes it doesn’t match the initial type completely; the compiler makes appropriate adjustments to align with initialization rules. Refer to my blog article <a target="_blank" rel="noopener" href="https://imzlp.com/2016/05/04/type-convert-in-cpp/">detailed analysis of type conversion in C++</a>.</p>
<p><strong>Note: Using reference types actually works with the object referenced, especially when set as an initializer; what participates in the initialization is actually the value of the referenced object.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival_1 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// ival2 is of type int</span></span><br><span class="line"><span class="keyword">auto</span> ival_2 = ival_1;</span><br></pre></td></tr></table></figure>

<p>Auto generally ignores top-level const attributes, while keeping the bottom-level const intact.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;	<span class="comment">// b is an integer, ci&#x27;s const attribute is ignored.</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;	<span class="comment">// c is an integer, cr is an alias of ci, and ci itself is a top-level const.</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;	<span class="comment">// d is an int pointer</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;	<span class="comment">// e is a pointer to a constant integer</span></span><br></pre></td></tr></table></figure>

<p>If you wish the deduced auto type to be a top-level const, you need to specify it explicitly:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;</span><br></pre></td></tr></table></figure>

<p>Setting a type as an auto reference retains the top-level const from the initializer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;	<span class="comment">// g is a ref to a constant integer, bound to ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;	<span class="comment">// Error; cannot bind a non-const reference to a literal</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>; <span class="comment">// Correct; can bind a const reference to a literal</span></span><br></pre></td></tr></table></figure>

<h4 id="decltype-Type-Specifier"><a href="#decltype-Type-Specifier" class="headerlink" title="decltype Type Specifier"></a>decltype Type Specifier</h4><p>C++11 introduced the second type specifier, <strong>decltype</strong>, which serves to <strong>select and return the data type of the operand</strong>. During this process, the compiler analyzes the expression and determines its type without actually calculating the value of the expression.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x; <span class="comment">// sum&#x27;s type is the return type of function f</span></span><br><span class="line"><span class="comment">// The compiler does not actually call function f but uses the return value&#x27;s type when the call occurs.</span></span><br></pre></td></tr></table></figure>

<p><strong>Decltype</strong> processes top-level const and references differently from auto.</p>
<p>If the expression used by decltype is a variable, then decltype returns that variable’s type (including const and references).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x&#x27;s type is const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// y&#x27;s type is const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;	  <span class="comment">// Error; z is a reference and must be initialized.</span></span><br></pre></td></tr></table></figure>

<h5 id="decltype-and-References"><a href="#decltype-and-References" class="headerlink" title="decltype and References"></a>decltype and References</h5><p>If the expression used by decltype is not a variable, then decltype’s return type corresponds to the result type of the expression.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The result of decltype can be a reference type</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b; <span class="comment">// Correct; the result of addition is int, so b is an (uninitialized) int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;    <span class="comment">// Error; *p is int&amp;, which must be initialized</span></span><br><span class="line"><span class="comment">//error: declaration of reference variable &#x27;c&#x27; requires an initializer</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>If it’s a dereference operation, then decltype will get a reference type.</p>
<p>Dereferencing can access the object pointed to by the pointer and assign values to it. Thus, the result type of decltype(*p) is int&amp; rather than int.</p>
</blockquote>
<p>For decltype’s expressions, if the variable name includes parentheses, the result type will differ.</p>
<p>If the expression used by decltype is an unparenthesized variable, the result will be the type of that variable; if one or more layers of parentheses are added, the compiler treats it as an expression. A variable is a special kind of expression that can appear on the left side of an assignment statement, so such a decltype will yield a reference type.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the expression for decltype is a variable with parentheses, the result will be a reference</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d; <span class="comment">// Error: d is int&amp;, must be initialized</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e; <span class="comment">// Correct: e is an (uninitialized) int</span></span><br></pre></td></tr></table></figure>

<h4 id="Simplifying-Declarations-with-auto-and-decltype"><a href="#Simplifying-Declarations-with-auto-and-decltype" class="headerlink" title="Simplifying Declarations with auto and decltype"></a>Simplifying Declarations with auto and decltype</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">// The following declarations must include parentheses</span></span><br><span class="line"><span class="type">int</span> *ip[<span class="number">4</span>] = ia;  <span class="comment">// An array of integer pointers</span></span><br><span class="line"><span class="built_in">int</span> (*ip)[<span class="number">4</span>] = *ia; <span class="comment">// A pointer to an array containing four integers</span></span><br></pre></td></tr></table></figure>

<p>With the introduction of auto and decltype, we can avoid adding a pointer type to the front of an array.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output the value of each element in ia, with each inner array occupying a line</span></span><br><span class="line"><span class="comment">// p points to an array of 4 integers</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p) &#123;</span><br><span class="line">  <span class="comment">// q points to the first element of the array of 4 integers, meaning q points to an integer</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">  	cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">  cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Using-string-Objects-as-Filenames-for-File-Stream-Objects"><a href="#Using-string-Objects-as-Filenames-for-File-Stream-Objects" class="headerlink" title="Using string Objects as Filenames for File Stream Objects"></a>Using string Objects as Filenames for File Stream Objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open file, each time write positioning to the end</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofile</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>, ofstream::app | ofstream::out)</span></span>;</span><br></pre></td></tr></table></figure>

<p>In earlier C++ standards, the filename parameter (that is, <code>&quot;out.txt&quot;</code> in the above code) was only allowed to be a C-style array.</p>
<p>In C++11, filenames can be both C-style arrays and string objects.</p>
<p>So, the above code can also be written as:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">filename</span><span class="params">(<span class="string">&quot;out.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// Open file, each time write positioning to the end</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofile</span><span class="params">(filename, ofstream::app | ofstream::out)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="STL-Container-Related-Features"><a href="#STL-Container-Related-Features" class="headerlink" title="STL Container Related Features"></a>STL Container Related Features</h3><h4 id="array-and-forward-list-Containers"><a href="#array-and-forward-list-Containers" class="headerlink" title="array and forward_list Containers"></a>array and forward_list Containers</h4><table>
<thead>
<tr>
<th align="center">Container Name</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">array</td>
<td align="center">Fixed-size array. Supports fast random access. Cannot add or remove elements.</td>
</tr>
<tr>
<td align="center">forward_list</td>
<td align="center">Singly linked list. Only supports unidirectional sequential access. Insert/delete operations at any position in the list are very fast.</td>
</tr>
</tbody></table>
<p><code>forward_list</code> and <code>array</code> are new container types added in the C++11 standard.</p>
<p>Compared to built-in arrays, array provides a safer and easier-to-use array type.</p>
<p>Similar to built-in types, the size of array is fixed. Therefore, array does not support adding, deleting elements, or changing container size.</p>
<p><code>array</code> is a template that can store any number and type of elements. It can also handle exceptions and const objects directly.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>,3&gt; x = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>Compared to built-in types, <code>std::array</code> has two obvious advantages:</p>
<ol>
<li>It is a real object type (supports assignment operations).</li>
<li>It does not implicitly convert to a pointer to elements (passing an array degenerates to a pointer).</li>
</ol>
<p>However, <code>std::array</code> also has downsides. We cannot deduce the number of elements based on the length of the initializer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3 elements</span></span><br><span class="line">array&lt;<span class="type">int</span>, 3&gt; x = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error, too few template arguments for class template &#x27;array&#x27;</span></span><br><span class="line">array&lt;<span class="type">int</span>&gt; z = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>More operations supported by <code>std::array</code> can be seen here: <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/container/array">std::array - cppreference</a>.</p>
<p>The design goal of <code>forward_list</code> is to achieve performance comparable to the best handmade singly linked list data structures.</p>
<p>Consequently, <code>forward_list</code> lacks a <code>size</code> operation, as maintaining or calculating its size would incur additional overhead compared to a handwritten list.</p>
<p>For other containers, size guarantees a fast constant time operation. </p>
<ul>
<li><code>forward_list</code> has its own dedicated <code>emplace</code> and <code>insert</code>.</li>
<li><code>forward_list</code> does not support <code>push_back</code> and <code>emplace_back</code> operations.<h4 id="initializer-list-Parameter"><a href="#initializer-list-Parameter" class="headerlink" title="initializer_list Parameter"></a>initializer_list Parameter</h4></li>
</ul>
<p>If the number of actual parameters for a function is unknown, but <strong>all actual parameters are of the same type</strong>, then you can use a parameter of type <code>initializer_list</code>.</p>
<p><code>initializer_list</code> is a standard library type used to represent an array of values of a specific type. It is defined in the header file of the same name (initializer_list). Like <code>vector</code>, <code>initializer_list</code> is also a <code>template type</code>, and you must specify the type of the elements contained in the initializer_list when defining an initializer_list object.</p>
<table>
<thead>
<tr>
<th align="center">Operations Provided by initializer_list</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">initializer_list<T> lst;</td>
<td align="center">Default initialization: empty list of type T</td>
</tr>
<tr>
<td align="center">initializer_list<T> lst{a,b,c,d….}</td>
<td align="center">lst has the same number of elements as initial values;</p>lst’s elements are copies of corresponding initial values; elements in the list are const</td>
</tr>
<tr>
<td align="center">lst2(lst)</p>lst2=lst</td>
<td align="center">Copying or assigning an initializer_list object does not copy the elements in the list; the original list and the copy share elements after copying</td>
</tr>
<tr>
<td align="center">lst.size()</td>
<td align="center">Number of elements in the list</td>
</tr>
<tr>
<td align="center">lst.begin()</td>
<td align="center">Get a pointer to the first element in lst</td>
</tr>
<tr>
<td align="center">lst.end()</td>
<td align="center">Get a pointer to the position after the last element in lst</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(<span class="type">const</span> initializer_list&lt;T&gt; initList)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;index:initList)&#123;</span><br><span class="line">  		cout&lt;&lt;index;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output 123456</span></span><br><span class="line">initializer_list&lt;<span class="type">int</span>&gt; x&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="built_in">error_msg</span>(x);</span><br></pre></td></tr></table></figure>

<p>You can also use a <code>braced-init-list &#123;&#125;</code> to pass to the function with an initializer_list parameter:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: This code will produce an error under template &lt;class T&gt;, directly using initializer_list&lt;string&gt; will succeed</span></span><br><span class="line"><span class="comment">// error: no matching function for call to &#x27;error_msg&#x27;</span></span><br><span class="line"><span class="comment">// note: candidate template ignored: deduced conflicting types for parameter &#x27;T&#x27; (&#x27;const char *&#x27; vs. &#x27;std::__cxx11::basic_string&lt;char&gt;&#x27;)</span></span><br><span class="line">string name=<span class="string">&quot;Charley&quot;</span>;</span><br><span class="line"><span class="built_in">error_msg</span>(&#123;<span class="string">&quot;My&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;is&quot;</span>,name&#125;);</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/05.webp"></p>
<p>You can also use <code>initializer_list</code> to store existing variables of the same type and then pass them to a function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;T&gt;&amp; initList)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> index:initList)&#123;</span><br><span class="line">  		cout&lt;&lt;*index&lt;&lt;<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">11</span>,c=<span class="number">12</span>;</span><br><span class="line">	initializer_list&lt;<span class="type">int</span>&gt; test&#123;a,b,c&#125;;</span><br><span class="line">	<span class="built_in">error_msg</span>&lt;<span class="type">int</span>&gt;(test);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>A reference to an initializer_list object is a const reference, and obtaining a pointer to an initializer_list object is also a const pointer.</p>
</blockquote>
<p>The following content is taken from cppreference——<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/utility/initializer_list">initializer_list</a>:</p>
<p>An object of type <code>std::initializer_list</code> is a lightweight proxy object that provides access to an array of objects of type <code>const T</code>.</p>
<p>A <code>std::initializer_list</code> object is automatically constructed when:</p>
<ul>
<li>a <em>braced-init-list</em> is used in <a href="../language/list_initialization.html">list-initialization</a>, including function-call list initialization and assignment expressions</li>
<li>a <em>braced-init-list</em> is bound to <a href="../language/auto.html">auto</a>, including in a <a href="../language/range-for.html">ranged for loop</a></li>
</ul>
<p>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a <code>std::initializer_list</code> does not copy the underlying objects.</p>
<table>
<thead>
<tr>
<th align="center">Member Type</th>
<th align="center">Definition</th>
</tr>
</thead>
<tbody><tr>
<td align="center">value_type</td>
<td align="center">T</td>
</tr>
<tr>
<td align="center">reference</td>
<td align="center">const T&amp;</td>
</tr>
<tr>
<td align="center">const_reference</td>
<td align="center">const T&amp;</td>
</tr>
<tr>
<td align="center">size_type</td>
<td align="center">std::size_t</td>
</tr>
<tr>
<td align="center">iterator</td>
<td align="center">const T*</td>
</tr>
<tr>
<td align="center">const_iterator</td>
<td align="center">const T*</td>
</tr>
</tbody></table>
<p>From the table above, if we pass an initializer_list object using &amp; or an iterator, we cannot modify its value.</p>
<p>By Value is possible, but the modified object will not be the actual parameter. #### Non-Member Function Swap for Containers</p>
<p>In C++11, containers provide both member function versions of swap and non-member function versions of swap. </p>
<p>Earlier standard versions only provided the member function version of swap. The non-member function version of swap is very important in generic programming. It is a good habit to uniformly use the non-member function version.</p>
<p><code>swap</code> swaps the contents of two containers of the same type. After calling swap, the elements in the two containers will be exchanged.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">// Vector with 10 elements</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec2</span><span class="params">(<span class="number">20</span>)</span></span>;	<span class="comment">// Vector with 20 elements</span></span><br><span class="line"><span class="comment">// Before swapping, the number of elements in svec1 and svec2</span></span><br><span class="line">cout&lt;&lt;svec1.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;svec2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="built_in">swap</span>(svec1,svec2);</span><br><span class="line"><span class="comment">// After swapping, the number of elements in svec1 and svec2</span></span><br><span class="line">cout&lt;&lt;svec1.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;svec2.<span class="built_in">size</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>Running result:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/07.webp"></p>
<p>The operation of swapping the contents of two containers is guaranteed to be fast—elements themselves are not swapped; swap just exchanges the internal data structures of the two containers.</p>
<p>Except for <code>array</code>, swap does not perform any copy, delete, or insert operations on any elements; thus, it can be guaranteed to complete in constant time.</p>
<blockquote>
<p>The fact that elements do not move means that, except for <code>string</code>, iterators, references, and pointers pointing to the containers will not be invalidated after swap. They will still point to the elements they pointed to before the swap operation. However, after the swap, these elements belong to different containers now.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec1&#123;<span class="string">&quot;My&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;zhalipeng&quot;</span>&#125;;	<span class="comment">// Vector with 10 elements</span></span><br><span class="line">vector&lt;string&gt; svec2&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;family&quot;</span>&#125;;	<span class="comment">// Vector with 20 elements</span></span><br><span class="line"><span class="keyword">auto</span> svec1_index=svec1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> svec2_index=svec2.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">swap</span>(svec1,svec2);</span><br><span class="line"><span class="comment">// At this time, we output svec1_index and svec2_index</span></span><br><span class="line">cout&lt;&lt;*svec1_index&lt;&lt;endl&lt;&lt;*svec2_index&lt;&lt;endl;</span><br><span class="line"><span class="comment">// The result obtained is</span></span><br><span class="line">My</span><br><span class="line">I</span><br><span class="line"><span class="comment">// In fact, modifying the value of svec1_index now actually modifies the value of the element in the svec2 container, and the same goes for svec2_index</span></span><br></pre></td></tr></table></figure>

<p><strong>Note: Calling swap on a string container will cause iterators, pointers, and references to be invalidated.</strong></p>
<blockquote>
<p>Unlike other containers, swapping two <code>array</code> containers actually swaps their elements. Therefore, the time required to swap two arrays is proportional to the number of elements in the array.<br>Thus, for <code>array</code> containers, after swap, the elements bound to pointers, references, and iterators remain unchanged, but their values have been swapped with the corresponding elements in the other array.</p>
</blockquote>
<h4 id="Return-Type-of-Insert-in-Containers"><a href="#Return-Type-of-Insert-in-Containers" class="headerlink" title="Return Type of Insert in Containers"></a>Return Type of Insert in Containers</h4><p>We can use the member function insert of a container to insert a range of elements.</p>
<table>
<thead>
<tr>
<th align="center">Insert Version</th>
<th align="center">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c.insert(p,t)</td>
<td align="center">Creates an element with value t before the element pointed to by iterator p, returning an iterator to the newly added element</td>
</tr>
<tr>
<td align="center">c.insert(p,b,e)</td>
<td align="center">Inserts the elements in the range specified by iterators b and e before the element pointed to by iterator p</td>
</tr>
<tr>
<td align="center">c.insert(p,n,t)</td>
<td align="center">Inserts n elements with value t before the element pointed to by iterator p, returning an iterator to the first new element added; if n is 0, it returns p</td>
</tr>
</tbody></table>
<p><strong>In the new standard, the insert version that accepts the number of elements or returns returns an iterator to the first newly added element. In older standards, these operations return void.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec1&#123;<span class="string">&quot;My&quot;</span>,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;is&quot;</span>,<span class="string">&quot;zhalipeng&quot;</span>&#125;;	<span class="comment">// Vector with 10 elements</span></span><br><span class="line">vector&lt;string&gt; svec2&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;love&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;family&quot;</span>&#125;;	<span class="comment">// Vector with 20 elements</span></span><br><span class="line"><span class="keyword">auto</span> x=svec1.<span class="built_in">insert</span>(svec1.<span class="built_in">end</span>(),svec2.<span class="built_in">begin</span>(),svec2.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">typeid</span>(x)==<span class="built_in">typeid</span>(vector&lt;string&gt;::iterator))&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Compiling with C++11 (-std=c++11) (otherwise auto won&#x27;t compile), result is yes</span></span><br></pre></td></tr></table></figure>

<h4 id="Emplace-Operation"><a href="#Emplace-Operation" class="headerlink" title="Emplace Operation"></a>Emplace Operation</h4><p>The new standard introduces three new members—<code>emplace_front</code>, <code>emplace</code>, and <code>emplace_back</code>, these operations <code>construct</code> rather than copy elements.</p>
<p>These operations correspond to <code>push_front</code>, <code>insert</code>, and <code>push_back</code>, allowing us to place elements at the front of the container, before a specified position, or at the end of the container.</p>
<ul>
<li><p><code>forward_list</code> has its own dedicated <code>emplace</code> and <code>insert</code></p>
</li>
<li><p><code>forward_list</code> does not support <code>push_back</code> and <code>emplace_back</code> operations</p>
</li>
<li><p><code>vector</code> and <code>string</code> do not support <code>push_front</code> and <code>emplace_front</code></p>
</li>
</ul>
<p>When calling member functions push or insert, we pass an object of the element type to them, which is copied into the container. However, when we call an emplace member function, we pass the parameters to the constructor of the element type. Emplace members directly construct an element in the memory space managed by the container using these parameters.</p>
<p>For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume we now have a class test</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">test</span>():<span class="built_in">test</span>(<span class="string">&quot;&quot;</span>,<span class="number">0</span>)&#123;&#125;</span><br><span class="line">	<span class="built_in">test</span>(<span class="type">const</span> string strinput,<span class="type">int</span> iyear):<span class="built_in">year</span>(iyear),<span class="built_in">name</span>(strinput)&#123;&#125;</span><br><span class="line">	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; in,test &amp;object);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> year;</span><br><span class="line">	string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Overload &lt;&lt; operator</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; in,test&amp; object)&#123;</span><br><span class="line">	in&lt;&lt;object.name&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;object.year;</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we use emplace_back to add test objects:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;test&gt; x;</span><br><span class="line"><span class="comment">// Use emplace_back to construct a test object at the tail of x</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">  	<span class="comment">// Use the two-parameter constructor of test</span></span><br><span class="line">	x.<span class="built_in">emplace_back</span>(<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:x)&#123;</span><br><span class="line">	cout&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Running result:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/08.webp"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Let&#x27;s try using push_back</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">	<span class="comment">// This is incorrect</span></span><br><span class="line">  	<span class="comment">// error: no matching member function for call to &#x27;push_back&#x27;</span></span><br><span class="line">  	<span class="comment">// note: candidate function not viable: requires single argument &#x27;__x&#x27;, but 2 arguments were provided</span></span><br><span class="line">  	<span class="comment">// note: candidate function not viable: requires single argument &#x27;__x&#x27;, but 2 arguments were provided</span></span><br><span class="line">	x.<span class="built_in">push_back</span>(<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The correct way is to explicitly call the constructor of test</span></span><br><span class="line">x.<span class="built_in">push_back</span>(<span class="built_in">test</span>(<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>+i));</span><br></pre></td></tr></table></figure>

<p>As you can see, the calls to emplace_back and push_back both create a new test object. When calling emplace, the object is created directly in the memory space managed by the container. While calling push_back creates a local temporary object and pushes it into the container.</p>
<blockquote>
<p>The parameters of emplace functions vary based on the element type; the parameters must match the constructor of the element type.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;test&gt; x;</span><br><span class="line"><span class="comment">// Call the default constructor of test</span></span><br><span class="line">x.<span class="built_in">emplace_back</span>();</span><br><span class="line"><span class="comment">// Insert a test object before x.begin(), calling the constructor with two parameters</span></span><br><span class="line">x.<span class="built_in">emplace</span>(x.<span class="built_in">begin</span>(),<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `vector` and `string` do not support emplace_front (constructing elements at the front of the container)</span></span><br><span class="line">list&lt;test&gt; y&#123;&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">2001</span>&#125;,&#123;<span class="string">&quot;lisi&quot;</span>,<span class="number">2002</span>&#125;&#125;;</span><br><span class="line">y.<span class="built_in">emplace_front</span>(<span class="string">&quot;zhalipeng&quot;</span>,<span class="number">1994</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index:y)&#123;</span><br><span class="line">	cout&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="String-Numeric-Conversion-Functions"><a href="#String-Numeric-Conversion-Functions" class="headerlink" title="String Numeric Conversion Functions"></a>String Numeric Conversion Functions</h4><p>C++11 introduced several functions that can convert numeric data to and from standard library strings.</p>
<table>
<thead>
<tr>
<th align="center">Function</th>
<th align="left">Operation Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">to_string(val)</td>
<td align="left">A set of overloaded functions that returns the string representation of the numeric value val. val can be any arithmetic type. There is a corresponding version of to_string for each floating-point type and int or larger integer types.</td>
</tr>
<tr>
<td align="center">stoi(s,p,b)<p>stol(s,p,b)<p>stoul(s,p,b)<p>stoll(s,p,b)<p>stoull(s,p,b)<p></td>
<td align="left">Returns the numeric value of the substring of s (representing integer content) starting at position p, with return types of int/long/long long/unsigned long/unsigned long long. b specifies the base used for conversion, default is 10. p is a pointer to store the index of the first non-numeric character in s, p defaults to 0, meaning the function does not store the index.</td>
</tr>
<tr>
<td align="center">stof(s,p)<p>stod(s,p)<p>stold(s,p)</td>
<td align="left">Returns the numeric value of the substring of s (representing floating-point content), with return types of float/double/long double. The role of parameter p is the same as in integer conversion functions.</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to_string</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">string s = <span class="built_in">to_string</span>(i);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string object s = &quot;</span>&lt;&lt;s &lt;&lt;endl&lt;&lt;<span class="string">&quot;s.size() = &quot;</span>&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;endl;</span><br><span class="line"><span class="type">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line">string pistr = <span class="built_in">to_string</span>(pi);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string object pistr = &quot;</span> &lt;&lt; pistr &lt;&lt; endl &lt;&lt; <span class="string">&quot;pistr.size() = &quot;</span> &lt;&lt; pistr.<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>Running result:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/09.webp"></p>
<p>Converting double to string will result in floating-point rounding—see <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE754</a> for details.</p>
<p>Converting from string to other arithmetic types:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stod</span></span><br><span class="line"><span class="function">string <span class="title">pi</span><span class="params">(<span class="string">&quot;pi=3.14159&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> dpi = <span class="built_in">stod</span>(pi.<span class="built_in">substr</span>(pi.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br><span class="line">cout &lt;&lt; dpi &lt;&lt; endl;</span><br><span class="line"><span class="comment">// stoi</span></span><br><span class="line"><span class="function">string <span class="title">elevenstr</span><span class="params">(<span class="string">&quot;eleven=11&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> ieleven=<span class="built_in">stoi</span>(elevenstr.<span class="built_in">substr</span>(elevenstr.<span class="built_in">find_first_of</span>(<span class="string">&quot;+-.0123456789&quot;</span>)));</span><br><span class="line">cout&lt;&lt;ieleven&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>Running result:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/10.webp"></p>
<p>The above uses two member functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// substr() returns a substring of the string starting at index and length num characters. If not specified, the default is string::npos. Thus, substr() simply returns the remainder of the string starting from index.</span></span><br><span class="line"><span class="function">basic_string <span class="title">substr</span><span class="params">( size_type index, size_type num = npos )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find_first_of has four overload versions</span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">( <span class="type">const</span> basic_string &amp;str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, size_type index, size_type num )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">( <span class="type">char</span> ch, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="comment">// The find_first_of() function: </span></span><br><span class="line"><span class="comment">// Searches for the first character that matches any character in str in the string, returning its position. The search starts from index, returning string::npos if not found. </span></span><br><span class="line"><span class="comment">// Searches for the first character that matches any character in str in the string, returning its position. The search starts from index, at most searching num characters. If not found, it returns string::npos. </span></span><br><span class="line"><span class="comment">// Searches for the first character that matches ch in the string, returning its position. The search starts from index. </span></span><br></pre></td></tr></table></figure>

<h4 id="Functions-for-Managing-Capacity"><a href="#Functions-for-Managing-Capacity" class="headerlink" title="Functions for Managing Capacity"></a>Functions for Managing Capacity</h4><table>
<thead>
<tr>
<th align="center">Member Function</th>
<th align="center">Operation Behavior</th>
<th align="center">Applicable Scope</th>
</tr>
</thead>
<tbody><tr>
<td align="center">c.shrink_to_fit()</td>
<td align="center">Reduces capacity() to the same size as size()</td>
<td align="center">Applicable only to vector, string, and deque</td>
</tr>
<tr>
<td align="center">c.capacity()</td>
<td align="center">How many elements c can hold without reallocating memory</td>
<td align="center">Applicable only to vector and string</td>
</tr>
<tr>
<td align="center">c.reserve(n)</td>
<td align="center">Allocates enough memory space to hold at least n elements</td>
<td align="center">Applicable only to vector and string</td>
</tr>
</tbody></table>
<blockquote>
<p>The reserve operation does not change the number of elements in the container; it affects how much memory space vector preallocates.</p>
<p>Only when the required memory space exceeds the current capacity will a reserve call change the capacity of a vector. If the required size is greater than the current capacity, <code>reserve</code> allocates at least the same amount of memory space as the requirement (possibly larger).</p>
<p>If the required size is less than or equal to the current capacity, <code>reserve</code> does nothing. Especially when the required size is less than the current capacity, the container does not free memory space, so after calling reserve, the capacity will be greater than or equal to the parameter passed to reserve.</p>
<p>Thus, calling reserve will never reduce the memory space the container occupies.</p>
<p>Similarly, the resize member function changes only the number of elements in the container and not the capacity of the container. Thus, resize cannot be used to reduce the reserved memory space of the container.</p>
</blockquote>
<p>In the C++11 standard, we can call <code>shrink_to_fit</code> to request <code>vector</code>, <code>deque</code>, or <code>string</code> to release unused memory space.</p>
<p>This function indicates that we no longer need any extra memory space. However, the specific implementation may choose to ignore this request, meaning that calling <code>shrink_to_fit</code> does not guarantee the return of memory space.</p>
<h5 id="Difference-between-Capacity-and-Size"><a href="#Difference-between-Capacity-and-Size" class="headerlink" title="Difference between Capacity and Size"></a>Difference between Capacity and Size</h5><ul>
<li>size: Refers to the number of elements currently stored in the container</li>
<li>capacity: Refers to how many elements can be stored without reallocating memory</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; x;</span><br><span class="line"><span class="comment">// The value of size is 0, the value of capacity depends on specific implementation</span></span><br><span class="line">cout&lt;&lt;x.<span class="built_in">capacity</span>()&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;x.<span class="built_in">size</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>The code above yields different results under different compilation environments:</p>
<table>
<thead>
<tr>
<th align="center">Compilation Environment</th>
<th align="center">Result</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Visual Studio2015</td>
<td align="center">0    0</td>
</tr>
<tr>
<td align="center">Clang 3.7.0 x86_64-w64-windows-gnu</td>
<td align="center">0    0</td>
</tr>
<tr>
<td align="center">g++ 5.2.0 x86_64-posix-seh-rev1</td>
<td align="center">0    0</td>
</tr>
</tbody></table>
<h4 id="Unordered-Containers"><a href="#Unordered-Containers" class="headerlink" title="Unordered Containers"></a>Unordered Containers</h4><p>C++11 defines four <code>unordered associative containers</code>.</p>
<p>These are: <code>unordered_map</code>, <code>unordered_set</code>, <code>unordered_multimap</code>, <code>unordered_multiset</code>. When using the corresponding unordered containers, you also need to include the respective header files (container names).</p>
<p>These containers do not organize elements using comparison operators but use a <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">hash function</a> and the <code>== operator</code> for the keyword type. Unordered containers are very useful when elements of the keyword type do not have a clear sequence relationship. In some applications, maintaining the sequence of elements can be very costly, making unordered containers very useful.</p>
<blockquote>
<p>If the keyword type is inherently unordered, or performance testing reveals issues that can be solved through hashing techniques, unordered containers can be used.</p>
</blockquote>
<h5 id="Using-Unordered-Containers"><a href="#Using-Unordered-Containers" class="headerlink" title="Using Unordered Containers"></a>Using Unordered Containers</h5><p>In addition to hashing management operations, unordered containers provide the same operations as ordered containers (find, insert, etc.). This means that the operations usable on <code>map</code> and <code>set</code> can also be used on <code>unordered_map</code> and <code>unordered_set</code>. Similarly, unordered containers also have versions that allow duplicate keywords.</p>
<p>Generally, an unordered container can replace its corresponding ordered container and vice versa. However, since elements are not stored in order, the output of a program using an unordered container will often differ from that of the ordered container version.</p>
<p>For example, you can write a word count program using <code>unordered_map</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string,<span class="type">size_t</span>&gt; word_count;</span><br><span class="line">string word;</span><br><span class="line"><span class="comment">// Read a line of string</span></span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">	++word_count[word];</span><br><span class="line">  	<span class="comment">// Check if reading the end of the line with &#x27;\n&#x27;</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">getchar</span>()==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;w:word_count)</span><br><span class="line">  cout&lt;&lt;w.first&lt;&lt;<span class="string">&quot; occurs&quot;</span>&lt;&lt;(w.second&lt;&lt;(w.second&gt;<span class="number">1</span>)?<span class="string">&quot; times&quot;</span>:<span class="string">&quot; time&quot;</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>Note that because it is an <strong>unordered container</strong>, the order of the output is unlikely to follow the order of input.</p>
<h5 id="Managing-Buckets"><a href="#Managing-Buckets" class="headerlink" title="Managing Buckets"></a>Managing Buckets</h5><p>Unordered containers are organized in storage as a group of buckets, with each bucket storing zero or more elements. Unordered containers map elements to buckets using a hash function. To access an element, the container first calculates the hash value of the element, which indicates which bucket to search in. The container keeps all elements with a specific hash value in the same bucket. If the container allows duplicate keywords, all elements with the same keyword will also reside in one bucket. Thus, the <code>performance of unordered containers</code> depends on the quality of the hash function and the count size of the buckets.</p>
<p>For the same parameters, a hash function must always produce the same result. Ideally, the hash function should also map each specific value to a unique bucket. However, mapping different keywords to the same bucket is also permissible.</p>
<p>When a bucket holds multiple elements, a sequential search for those elements must be conducted to find the one we want. Calculating a uniform hash value and searching within a bucket are generally fast operations. However, if a bucket holds many elements, finding a specific element requires numerous comparison operations.</p>
<p>Unordered containers provide a set of functions to manage buckets. These member functions allow us to query the status of the container as well as force the container to restructure when necessary.</p>
<table>
<thead>
<tr>
<th align="center">Functions for Managing Buckets</th>
<th align="left">Operation Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Bucket Interface</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">c.bucket_count()</td>
<td align="left">The number of buckets currently in use</td>
</tr>
<tr>
<td align="center">c.max_bucket_count()</td>
<td align="left">The maximum number of buckets the container can hold</td>
</tr>
<tr>
<td align="center">c.bucket_size(n)</td>
<td align="left">The number of elements in the nth bucket</td>
</tr>
<tr>
<td align="center">c.bucket(k)</td>
<td align="left">Which bucket contains the elements with the keyword k</td>
</tr>
<tr>
<td align="center"><strong>Bucket Iterators</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">local_iterator</td>
<td align="left">Iterator type used to access elements in buckets</td>
</tr>
<tr>
<td align="center">const_local_iterator</td>
<td align="left">Const version of the bucket iterator</td>
</tr>
<tr>
<td align="center">c.begin(n)/c.end(n)</td>
<td align="left">Iterate over the first element and the end after for the nth bucket</td>
</tr>
<tr>
<td align="center">c.cbegin(n)/c.cend(n)</td>
<td align="left">Similar to the previous two functions, but returns const_local_iterator</td>
</tr>
<tr>
<td align="center"><strong>Hash Strategy</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">c.loadfactor()</td>
<td align="left">The average number of elements per bucket, returns a float value</td>
</tr>
<tr>
<td align="center">c.max_load_factor()</td>
<td align="left">c attempts to maintain the average bucket size, return float values. c will add new buckets when necessary to ensure that load_factor &lt;= max_load_factor and restructure storage so that bucket_count &gt;= n</td>
</tr>
<tr>
<td align="center">c.rehash(n)</td>
<td align="left">Restructure the storage, ensuring that bucket_count &gt;= n and bucket_count &gt; size/max_load_factor</td>
</tr>
<tr>
<td align="center">c.reserve(n)</td>
<td align="left">Restructure the storage to allow c to hold n elements without needing to rehash</td>
</tr>
</tbody></table>
<h5 id="Requirements-for-Keyword-Types-in-Unordered-Containers"><a href="#Requirements-for-Keyword-Types-in-Unordered-Containers" class="headerlink" title="Requirements for Keyword Types in Unordered Containers"></a>Requirements for Keyword Types in Unordered Containers</h5><p>By default, unordered containers use the <code>== operator</code> of the keyword type to compare elements, and they also use an object of type <code>hash&lt;key_type&gt;</code> to generate the hash value for each element. The standard library provides hash templates for built-in types (including pointers). Hashes have also been defined for some standard library types, including <code>string</code> and smart pointer types, allowing us to directly define unordered containers with keywords of <code>built-in types (including pointer types)</code>, <code>string</code>, or <code>smart pointer types</code>.</p>
<blockquote>
<p>Note: While unordered containers support keywords of built-in types (including pointer types), <code>string</code>, or <code>smart pointer types</code>, we cannot directly define unordered containers with custom types as keywords.</p>
<p>Unlike containers, you cannot directly use the hash template and must provide your own hash template version. This will be discussed in the section on <code>template specialization</code>.</p>
</blockquote>
<p>We do not use the default hash but instead use another method, similar to <code>overloading</code> the default comparison operation for the keyword type in ordered containers.</p>
<p>To allow our custom type to act as a keyword for unordered containers, we need to provide functions that replace the <code>== operator</code> and the <code>hash calculation function</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume we now have a custom class book</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">book</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">book</span>(<span class="type">const</span> <span class="type">int</span> &amp;in=<span class="number">0</span>):<span class="built_in">isbn</span>(in)&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getisbn</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isbn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> book &amp;rhs);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> isbn;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> book::<span class="keyword">operator</span>==(<span class="type">const</span> book &amp;rhs)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">getisbn</span>()==rhs.<span class="built_in">getisbn</span>())&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can start defining these overloaded functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hasher</span><span class="params">(<span class="type">const</span> book &amp;bk)</span></span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(bk.<span class="built_in">getisbn</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The function replacing the == operator can be ignored if overloaded in the class</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eqOq</span><span class="params">(<span class="type">const</span> book &amp;lhs,<span class="type">const</span> book &amp;rhs)</span></span>&#123;</span><br><span class="line">	  <span class="keyword">return</span> lhs.<span class="built_in">getisbn</span>()==rhs.<span class="built_in">getisbn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If we do not overload the <code>== operator</code> of the class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> BK_multiset=unordered_multiset&lt;book, <span class="keyword">decltype</span>(hasher)*,<span class="keyword">decltype</span>(eqOq)*&gt;;</span><br><span class="line"><span class="comment">// Parameters are bucket size, hash function pointer, and equality judgement operator pointer</span></span><br><span class="line"><span class="function">BK_multiset <span class="title">bookstore</span><span class="params">(<span class="number">10</span>,hasher,eqOq)</span></span>;</span><br></pre></td></tr></table></figure>

<p>If we have overloaded the <code>== operator</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;book,<span class="title">decltype</span><span class="params">(bkHash)</span>*&gt; <span class="title">bkset</span><span class="params">(<span class="number">10</span>,bkHash)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-Expressions"><a href="#Lambda-Expressions" class="headerlink" title="Lambda Expressions"></a>Lambda Expressions</h3><p>We can pass any category of <strong>callable object</strong> to an algorithm.<br>An object or expression is considered callable if the <strong>call operator ()</strong> can be applied to it.<br>Before C++11, the callable objects we could use were <strong>functions</strong>, <strong>function pointers</strong>, and <strong>classes that overload the call operator</strong>.<br>C++11 introduced a new callable object—<strong>lambda</strong><br>A lambda expression represents a callable code unit. We can think of it as an unnamed inline function.<br>Lambda expressions are also known as <strong>anonymous functions</strong>.<br>Like any function, <strong>a lambda has a return type (must use trailing return type), a parameter list, and a function body.</strong><br>However, unlike a function, a lambda may be defined within a function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list)-&gt; <span class="keyword">return</span> type&#123;function body&#125;</span><br><span class="line">[捕获列表](参数列表)-&gt;返回类型&#123;函数体&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>capture list</code> is a list of local variables defined in the enclosing function that the lambda will use. The <code>parameter list</code>, <code>return type</code>, and <code>function body</code> are similar to those of ordinary functions.<br>You can also omit the lambda’s parameter list and return type; omitting the parentheses and parameter list is equivalent to specifying an empty parameter list. However, you must always include the capture list and function body. If the return type is omitted, the lambda deduces its return type from the code in the function body. If the function body is just a return statement, the return type is deduced from the returned expression’s type; otherwise, the return type is void.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f=[]&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line"><span class="comment">// Output 42</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">f</span>()&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>If the function body of a lambda includes anything other than a single return statement (C++14 allows multiple as long as they are the same type) and the return type is not specified, then the return type will be void.</p>
</blockquote>
<p><strong>Note:</strong> Lambdas can not only be passed as parameters but can also be used to initialize a variable declared as auto or <code>std::function&lt;R(AL)&gt;</code>, where R is the return type and AL is the argument list type.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error, cannot infer the type of an auto variable before using it (recursion)</span></span><br><span class="line"><span class="keyword">auto</span> rev=[&amp;rev](<span class="type">char</span> *b,<span class="type">char</span>* e)&#123;<span class="keyword">if</span>(<span class="number">1</span>&lt;e-b)&#123;<span class="built_in">swap</span>(*b,*--e);<span class="built_in">rev</span>(++b,e);&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok, ensures the type is known before using rev</span></span><br><span class="line">std::function&lt;<span class="type">void</span>(<span class="type">char</span>* b,<span class="type">char</span> *e)&gt; rev=[&amp;rev](<span class="type">char</span> *b,<span class="type">char</span>* e)&#123;<span class="keyword">if</span>(<span class="number">1</span>&lt;e-b)&#123;<span class="built_in">swap</span>(*b,*--e);<span class="built_in">rev</span>(++b,e);&#125;&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">rev</span>(&amp;s1[<span class="number">0</span>],&amp;s1[<span class="number">0</span>]+s1.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">rev</span>(&amp;s2[<span class="number">0</span>],&amp;s2[<span class="number">0</span>]+s2.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<p>If you just want to give a lambda a name without recursive usage, you can use auto.<br>If a lambda captures nothing, it can be assigned to a pointer to the correct type of function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> (*p1)(<span class="type">double</span>)=[](<span class="type">double</span> a)&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a);&#125;;</span><br><span class="line"><span class="built_in">double</span> (*p2)(<span class="type">double</span>)=[&amp;](<span class="type">double</span> a)&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a);&#125;;  <span class="comment">// Error, lambda captured something</span></span><br><span class="line"><span class="built_in">double</span> (*p3)(<span class="type">int</span>)=[](<span class="type">int</span> a)&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(a);&#125;; <span class="comment">// Error, type of parameter does not match</span></span><br></pre></td></tr></table></figure>

<h4 id="Passing-Parameters-to-Lambda"><a href="#Passing-Parameters-to-Lambda" class="headerlink" title="Passing Parameters to Lambda"></a>Passing Parameters to Lambda</h4><p>Similar to an ordinary function, actual parameters provided when calling a lambda are used to initialize the lambda’s formal parameters.<br>Generally, the types of the actual parameters must match those of the formal parameters. However, unlike ordinary functions, <code>lambda cannot have default parameters</code>; hence, the number of actual parameters must match the number of formal parameters. Once the formal parameters are initialized, the function body can be executed.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  vector&lt;string&gt; word&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;need&quot;</span>,<span class="string">&quot;to&quot;</span>,<span class="string">&quot;follow&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;heart&quot;</span>&#125;;</span><br><span class="line">  <span class="comment">// Call stable_sort to sort the word container based on element length in ascending order</span></span><br><span class="line">  <span class="built_in">stable_sort</span>(word.<span class="built_in">begin</span>(),word.<span class="built_in">end</span>(),[](<span class="type">const</span> string&amp; a,<span class="type">const</span> string&amp; b)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();&#125;);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">auto</span> index:word)&#123;</span><br><span class="line">  	cout&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Executing result:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/11.webp"></p>
<p>The prototype of stable_sort: For more detailed content, refer here——<a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/algorithm/stable_sort">stable_sort - cppreference</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parameters first and last indicate elements in the range, comp is a predicate parameter which is a comparison function, returning true if the first parameter is less than the second parameter</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> RandomIt, <span class="keyword">class</span> Compare &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">stable_sort</span><span class="params">( RandomIt first, RandomIt last, Compare comp )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cmp&#x27;s declaration should be like this</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type1</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Type1 &amp;a, <span class="type">const</span> Type2 &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cmp definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type1</span>&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Type1 &amp;a, <span class="type">const</span> Type2 &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thus, we can use lambdas to replace the cmp function (after all, lambda is a form of function, but it’s an anonymous function).</p>
<h4 id="Using-Capture-Lists"><a href="#Using-Capture-Lists" class="headerlink" title="Using Capture Lists"></a>Using Capture Lists</h4><h5 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h5><p>Before introducing the lambda capture list, let’s get familiar with the concept of a <code>predicate</code>.</p>
<p>A <code>predicate</code> is a callable expression whose result is a value that can be used as a condition (bool).</p>
<p>Standard library algorithms use two types of predicates: <code>unary predicates</code> (meaning they can accept a single parameter) and <code>binary predicates</code> (meaning they can accept two parameters). Algorothems accepting predicate arguments call the predicate on the elements in the input sequence, so the element type must be convertible to the predicate parameter types.</p>
<p>While a lambda can appear inside a function, using its local variables, it can only use those variables that are explicitly specified. A lambda indicates which variables it will use by including them in its capture list. The capture list gives the lambda the information needed to access the local variables.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num=<span class="number">5</span>;</span><br><span class="line">vector&lt;string&gt; word&#123;<span class="string">&quot;I&quot;</span>,<span class="string">&quot;need&quot;</span>,<span class="string">&quot;to&quot;</span>,<span class="string">&quot;follow&quot;</span>,<span class="string">&quot;my&quot;</span>,<span class="string">&quot;heart&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// If the capture list is empty, using num within the lambda function body is incorrect</span></span><br><span class="line"><span class="comment">// error: cannot implicitly capture &quot;num&quot; because the default capture mode has not been specified</span></span><br><span class="line"><span class="keyword">auto</span> oneIndex=<span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(),word.<span class="built_in">end</span>(),[num](<span class="type">const</span> string&amp; a)&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;=num;&#125;);</span><br><span class="line"><span class="comment">// This gets the first element of word longer than 5</span></span><br><span class="line">cout&lt;&lt;*oneIndex&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>In the above code, the lambda will capture num to use in the lambda body.</p>
<p>Let’s rewrite the above code to output all the elements in a container of length greater than X.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> index = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), [num](<span class="type">const</span> string&amp; a) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= num; &#125;); index != word.<span class="built_in">end</span>();) &#123;</span><br><span class="line">	cout &lt;&lt; *index &lt;&lt; endl;</span><br><span class="line">	index= <span class="built_in">find_if</span>(index + <span class="number">1</span>, word.<span class="built_in">end</span>(), [num](<span class="type">const</span> string&amp; a) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= num; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Running result:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/12.webp"></p>
<h3 id="Lambda-Capture-and-Return"><a href="#Lambda-Capture-and-Return" class="headerlink" title="Lambda Capture and Return"></a>Lambda Capture and Return</h3><p>When a lambda is defined, the compiler generates a new (unnamed) class type corresponding to the lambda.</p>
<p>When passing a lambda to a function, a new type and an unnamed object of that type are defined simultaneously: the passed parameter is an unnamed object of the class type generated by this compiler.</p>
<p>When we define a variable initialized by a lambda with auto, we define an object of the type generated from the lambda.</p>
<p>By default, classes generated from lambdas include a data member corresponding to the local variables captured by the lambda. Like any ordinary class data members, the data members of a lambda object are initialized when the lambda object is created.</p>
<p>The choice between value capture and reference capture is based on the same criteria as function parameters.<br>If we want to write to a captured object, or the captured object is large, we should use references. For <code>lambda</code>, we should also be cautious that its lifetime may exceed that of its caller.</p>
<p>When passing a <code>lambda</code> to other threads, generally, <strong>value capture ([=])</strong> is preferable: accessing the stack contents of other threads through references or pointers is a dangerous operation (for correctness and performance), and more seriously, viewing the content of a terminated thread’s stack may lead to errors that are hard to detect.</p>
<p>If you want to capture <code>variadic templates</code>, you can use <code>...</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typaname ...Var&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algo</span><span class="params">(<span class="type">int</span> s,Var ...v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> helper=[&amp;s,&amp;v...]&#123;<span class="keyword">return</span> s*(<span class="built_in">h1</span>(v...)+<span class="built_in">h2</span>(v...));&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Value-Capture"><a href="#Value-Capture" class="headerlink" title="Value Capture"></a>Value Capture</h4><p>Like parameter passing, the capture method of variables can be either by value or by reference.</p>
<p>Similar to passing by value parameters, the precondition for value capture is that the variable can be copied. Unlike parameters, the captured variable’s value is copied when the lambda is created, not when called.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">auto</span> printX=[x]()&#123;cout&lt;&lt;x&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="built_in">printX</span>();</span><br><span class="line"><span class="comment">// Will print the value of x: 11</span></span><br></pre></td></tr></table></figure>

<p>Note: Using value capture does not allow you to directly modify the captured variable’s value in the lambda.</p>
<p>If we intend to modify the value of the object captured by value, it will result in a compilation error, whereas reference capture will not:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value capture</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// Error: &quot;x&quot;: Cannot modify by copy captured variable in a non-mutable lambda</span></span><br><span class="line"><span class="comment">// error: cannot assign to a variable captured by copy in a non-mutable lambda</span></span><br><span class="line"><span class="keyword">auto</span> printX = [x]() &#123;cout &lt;&lt; x &lt;&lt; endl; <span class="keyword">return</span> ++x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reference capture</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">auto</span> printY = [&amp;y]() &#123;cout &lt;&lt; y &lt;&lt; endl; <span class="keyword">return</span> ++y; &#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">printX</span>();</span><br><span class="line"><span class="comment">// Output result:</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>If you want to modify a value captured object within the lambda’s function body, you can use <code>reference capture</code>, or you can use the <code>mutable</code> keyword on a value-captured lambda, which will be introduced later, but we’ll leave it aside for now.</p>
<p>cppreference states this:</p>
<blockquote>
<p>Unless the keyword <code>mutable</code> was used in the lambda-expression, the function-call operator is const-qualified and the objects that were captured by copy are non-modifiable from inside this operator().<br>Link: <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/lambda">Lambda functions (since C++11)</a></p>
</blockquote>
<h4 id="Reference-Capture"><a href="#Reference-Capture" class="headerlink" title="Reference Capture"></a>Reference Capture</h4><p>We define a lambda using <code>reference capture</code>, capturing variables by adding an &amp; sign before them.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">auto</span> printX=[&amp;x]()&#123;cout&lt;&lt;x&lt;&lt;endl;&#125;;</span><br><span class="line"><span class="built_in">printX</span>();</span><br><span class="line"><span class="comment">// Will print the value of x: 11</span></span><br></pre></td></tr></table></figure>

<p><code>Reference capture</code> and <code>returning references</code> have the same problems and limitations: if we capture a variable via reference, we need to ensure the referenced object exists at the time the lambda executes.</p>
<p>Lambdas capture only <code>local variables</code>, and these variables are no longer valid after the function ends. If a lambda may execute after a function ends, a reference to a captured variable will have disappeared.</p>
<p><code>Reference capture</code> can sometimes be necessary, for instance, when we need to capture an <code>ostream</code> since IO objects cannot be copied, and thus must be captured by reference.</p>
<p>You can also return a lambda from a function. A function can directly return a callable object or return a class object that contains callable objects as data members. If a function returns a lambda, like a function that cannot return a reference to a local variable, this lambda also cannot contain reference captures.</p>
<h4 id="Implicit-Capture"><a href="#Implicit-Capture" class="headerlink" title="Implicit Capture"></a>Implicit Capture</h4><p>In addition to explicitly listing the variables we want to use from the containing function, we can also <strong>allow the compiler to infer which variables to use based on the code inside the lambda body</strong> (meaning the compiler will only capture the variables that are used in the function body). To indicate that the compiler should infer the capture list, either <code>&amp;</code> or <code>=</code> should be written in the capture list. <code>&amp;</code> indicates that the compiler should use capture by reference, while <code>=</code> indicates capture by value.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">11</span>;</span><br><span class="line"><span class="type">double</span> dval = <span class="number">11.11</span>;</span><br><span class="line"><span class="comment">// Using implicit value capture</span></span><br><span class="line"><span class="keyword">auto</span> printByValue = [=]() &#123; cout &lt;&lt; ival &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; dval &lt;&lt; endl; &#125;;</span><br><span class="line"><span class="comment">// Using implicit reference capture</span></span><br><span class="line"><span class="keyword">auto</span> printByReference = [&amp;]() &#123; cout &lt;&lt; ival &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; dval &lt;&lt; endl; &#125;;</span><br></pre></td></tr></table></figure>

<p>We can also use a <code>mixed capture method</code>, applying one capture method to some variables while applying another capture method to others.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">11</span>;</span><br><span class="line"><span class="type">double</span> dval = <span class="number">11.11</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;HelloWorld!&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">// Using implicit value capture</span></span><br><span class="line"><span class="comment">// ival and dval are captured by value, str is captured by reference</span></span><br><span class="line"><span class="keyword">auto</span> printByValue = [=, &amp;str]() &#123; cout &lt;&lt; ival &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; dval &lt;&lt; str &lt;&lt; endl; &#125;;</span><br><span class="line"><span class="comment">// Using implicit reference capture</span></span><br><span class="line"><span class="comment">// ival and dval are captured by reference, str is captured by value</span></span><br><span class="line"><span class="keyword">auto</span> printByReference = [&amp; , str]() &#123; cout &lt;&lt; ival &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; dval &lt;&lt; str &lt;&lt; endl; &#125;;</span><br></pre></td></tr></table></figure>

<p>When we <code>mix implicit captures and explicit captures</code>, the first element in the capture list must be either <code>&amp;</code> or <code>=</code>. This symbol specifies the default capture mode as reference or value.</p>
<blockquote>
<p>When mixing implicit captures and explicit captures, the explicitly captured variables must use a different method from the implicit captures. That is, if the implicit capture method is value capture, then the explicitly captured variables must use reference capture, and vice versa. </p>
</blockquote>
<h4 id="Various-Capture-Methods-of-Lambda"><a href="#Various-Capture-Methods-of-Lambda" class="headerlink" title="Various Capture Methods of Lambda"></a>Various Capture Methods of Lambda</h4><table>
<thead>
<tr>
<th align="center">Capture Method</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[]</td>
<td align="left">Empty capture list. Lambda cannot use variables from the containing function. A lambda can only use captured variables after they are captured.</td>
</tr>
<tr>
<td align="center">[names]</td>
<td align="left">names is a comma-separated list of names, all of which are local variables from the containing function. By default, the variables in the capture list are copied. If <code>&amp;</code> is used before a name, it indicates capture by reference.</td>
</tr>
<tr>
<td align="center">[&amp;]</td>
<td align="left">Implicit capture list. Uses capture by reference. All entities used in the lambda body from the containing function are accessed by reference.</td>
</tr>
<tr>
<td align="center">[=]</td>
<td align="left">Implicit capture list. Uses capture by value. The lambda body will copy the values of the entities used from the containing function.</td>
</tr>
<tr>
<td align="center">[&amp;,identifier_list]</td>
<td align="left">identifier_list is a comma-separated list containing zero or more variables from the containing function. These variables are captured by value, while any implicitly captured variables are captured by reference. The capture list can include this. Names in identifier_list cannot use <code>&amp;</code> before them.</td>
</tr>
<tr>
<td align="center">[=,identifier_list]</td>
<td align="left">Variables in identifier_list are captured by reference, while any implicitly captured variables are captured by value. Names in identifier_list cannot include this, and must be preceded by <code>&amp;</code>.</td>
</tr>
</tbody></table>
<h4 id="Lambda-Capturing-this-in-Member-Functions"><a href="#Lambda-Capturing-this-in-Member-Functions" class="headerlink" title="Lambda Capturing this in Member Functions"></a>Lambda Capturing <code>this</code> in Member Functions</h4><p>When a lambda is used inside a member function, how can we access members of the class? We can add <code>this</code> to the capture list, making the class members available in the set of captured names.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">  function&lt;map&lt;string, string&gt;(<span class="type">const</span> map&lt;string, string&gt;&amp;)&gt; oper;  <span class="comment">// operation</span></span><br><span class="line">  map&lt;string, string&gt; values;  <span class="comment">// parameters</span></span><br><span class="line">  map&lt;string, string&gt; results; <span class="comment">// target</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Request</span>(<span class="type">const</span> string&amp; s); <span class="comment">// parse and store the request</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    [<span class="keyword">this</span>]() &#123; results = <span class="built_in">oper</span>(values); &#125; <span class="comment">// Perform the corresponding operation based on results</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Members are captured by reference, which means that <code>[this]</code> signifies that members are accessed via this and not copied into the lambda.</p>
<p><strong>[this] is incompatible with [=], so a slight oversight may cause race conditions in multi-threaded programs.</strong></p>
<h4 id="Mutable-Lambda"><a href="#Mutable-Lambda" class="headerlink" title="Mutable Lambda"></a>Mutable Lambda</h4><p>By default, a lambda will not change the value of a variable that has been captured by copy.</p>
<p>If we wish to change the value of a captured variable, we must add <code>mutable</code> after the <code>parameter list</code>. Thus, a mutable lambda can omit the parameter list.</p>
<p>For reference captures, there’s no need to explicitly add the <code>mutable</code> keyword after the parameter list, but it is certainly required for value capture.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">11</span>;</span><br><span class="line"><span class="type">double</span> dval = <span class="number">11.11</span>;</span><br><span class="line"><span class="comment">// Using reference capture does not require explicitly adding the mutable keyword; the function modifies the actual value of the referenced object, similar to standard function&#x27;s reference parameters</span></span><br><span class="line"><span class="keyword">auto</span> print = [&amp;]() &#123; cout &lt;&lt; --ival &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; --dval &lt;&lt; endl; &#125;;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; ival &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; dval &lt;&lt; endl;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 10 10.11</span></span><br><span class="line"><span class="comment">// 10 10.11</span></span><br></pre></td></tr></table></figure>

<p>However, a lambda that uses value capture must use <code>mutable</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">11</span>;</span><br><span class="line"><span class="type">double</span> dval = <span class="number">11.11</span>;</span><br><span class="line"><span class="comment">// Not using mutable will result in a compile error</span></span><br><span class="line"><span class="comment">// Error: &quot;x&quot;: cannot modify a variable captured by copy in a non-mutable lambda</span></span><br><span class="line"><span class="comment">// auto print = [=]() &#123; cout &lt;&lt; --ival &lt;&lt; &quot;\t&quot; &lt;&lt; --dval &lt;&lt; endl; &#125;;</span></span><br><span class="line"><span class="comment">// Correct approach: use mutable</span></span><br><span class="line"><span class="keyword">auto</span> print = [=]() <span class="keyword">mutable</span> &#123; cout &lt;&lt; --ival &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; --dval &lt;&lt; endl; &#125;;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line">cout &lt;&lt; ival &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; dval &lt;&lt; endl;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// 10 10.11</span></span><br><span class="line"><span class="comment">// 11 11.11</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Whether a variable captured by reference in a lambda can be modified depends on whether this reference points to a const type or a non-const type.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ival = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// Error: &quot;ival&quot;: cannot modify a variable captured by copy in a non-mutable lambda</span></span><br><span class="line"><span class="comment">// Error: cannot assign to variable &#x27;ival&#x27; with const-qualified type &#x27;const int&#x27;</span></span><br><span class="line"><span class="keyword">auto</span> print = [&amp;]() &#123; cout &lt;&lt; --ival &lt;&lt; endl; &#125;;</span><br></pre></td></tr></table></figure>

<p>The same issue applies to value capture:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ival = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">auto</span> print = [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="comment">// The type of the object captured by value is exactly the same as that of the outer function&#x27;s local variable (like here, const int)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(<span class="type">const</span> <span class="type">int</span>) == <span class="built_in">typeid</span>(ival)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="comment">// Execution result: yes</span></span><br></pre></td></tr></table></figure>

<p>So, the type of an object captured by value is exactly the same as that of the function’s local variable.</p>
<h4 id="Specifying-the-Return-Type-of-Lambda"><a href="#Specifying-the-Return-Type-of-Lambda" class="headerlink" title="Specifying the Return Type of Lambda"></a>Specifying the Return Type of Lambda</h4><p>By default, if a lambda body contains any statement other than return, the compiler assumes this lambda returns void. Similar to other void functions, a lambda that is inferred to return void cannot return a value.</p>
<blockquote>
<p>The return type of a lambda expression can be inferred from the lambda expression itself, which ordinary functions cannot do.<br>If the body of a lambda <strong>contains only a single return statement</strong>, then the return type of this lambda is the type of that return expression. (In C++14, it is possible to have multiple return statements without explicitly specifying the type, as long as it is guaranteed that each return returns the same type, see further details later).</p>
</blockquote>
<p>First, recognize the following forms of lambda definitions:</p>
<table>
<thead>
<tr>
<th align="left">Syntax</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[ capture-list ] ( params ) mutable(optional) exception attribute -&gt; ret { body }</td>
</tr>
<tr>
<td align="left">[ capture-list ] ( params ) -&gt; ret { body }</td>
</tr>
<tr>
<td align="left">[ capture-list ] ( params ) { body }</td>
</tr>
<tr>
<td align="left">[ capture-list ] { body }</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">Explanation</th>
<th>Effect</th>
</tr>
</thead>
<tbody><tr>
<td align="center">mutable</td>
<td>allows body to modify the parameters captured by copy, and to call their non-const member functions</td>
</tr>
<tr>
<td align="center">exception</td>
<td>provides the <a href="except_spec.html">exception specification</a> or the <a href="noexcept_spec.html">noexcept clause</a> for operator() of the closure type</td>
</tr>
<tr>
<td align="center">attribute</td>
<td>provides the <a href="attributes.html">attribute specification</a> for operator() of the closure type</td>
</tr>
<tr>
<td align="center">capture-list</td>
<td>a comma-separated list of zero or more <a href="lambda.html#Lambda_capture">captures</a>, optionally beginning with a capture-default. Capture list can be passed as follows (see below for the detailed description): <code>**[a,&amp;b]**</code> where <em>a</em> is captured by value and <em>b</em> is captured by reference. <code>**[this]**</code> captures the <a href="this.html"><code>**this**</code> pointer</a> by value <code>**[&amp;]**</code> captures all <a href="storage_duration.html">automatic</a> variables <a href="definition.html#ODR-use">odr-used</a> in the body of the lambda by reference <code>**[=]**</code> captures all <a href="storage_duration.html">automatic</a> variables <a href="definition.html#ODR-use">odr-used</a> in the body of the lambda by value <code>**[]**</code> captures nothing</td>
</tr>
<tr>
<td align="center">params</td>
<td>The list of parameters, as in <a href="function.html">named functions</a>, except that <a href="default_arguments.html">default arguments</a> are not allowed (until C++14). If <code>auto</code> is used as a type of a parameter, the lambda is a <em>generic lambda</em> (since C++14)</td>
</tr>
<tr>
<td align="center">ret</td>
<td>Return type. If not present it’s implied by function return statements (or void if it doesn’t return any value)</td>
</tr>
<tr>
<td align="center">body</td>
<td>Function body</td>
</tr>
</tbody></table>
<p>Consider the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transform all values in a sequence to their absolute values</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index : v)</span><br><span class="line">  cout &lt;&lt; index &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), [](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i; &#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> index : v)</span><br><span class="line">  cout &lt;&lt; index &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>Execution result:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/13.webp"></p>
<p>The <code>transform</code> algorithm is defined in the <code>algorithm</code> header file, and its function prototype is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> InputIt, <span class="keyword">class</span> OutputIt, <span class="keyword">class</span> UnaryOperation &gt;</span></span><br><span class="line"><span class="function">OutputIt <span class="title">transform</span><span class="params">(InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op)</span></span>;</span><br></pre></td></tr></table></figure>

<p>In the code above, we passed a lambda to transform that returns the absolute value of its parameter. The body of the lambda is a single return statement that returns the result of an expression, so we don’t need to specify the return type, as it can be inferred from the conditional operator.</p>
<p>However, if we use an <strong>apparently</strong> equivalent if statement, it will produce an error:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Incorrect usage in C++11; it doesn&#x27;t support implicit deduction of multiple return expressions</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), [](<span class="type">int</span> i) &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> -i; &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> i; &#125; &#125;);</span><br><span class="line"><span class="comment">// Correct usage, explicitly using trailing return type</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), [](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> -i; &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> i; &#125; &#125;);</span><br></pre></td></tr></table></figure>

<p>However, I did not get any errors when compiling with clang++ and g++. (WTF).</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/14.webp"></p>
<p>Upon researching, I found: <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/language/lambda">Lambda functions (since C++11) - cppreference</a> and <a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/cpp14-language">C++14 Language Extensions</a>.</p>
<p>C++11 permitted automatically deducing the return type of a lambda function whose body consisted of only a single <code>return</code> statement:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line">[=]() -&gt; some_type &#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok</span></span><br><span class="line">[=]                &#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok, deduces &quot;-&gt; some_type&quot;</span></span><br></pre></td></tr></table></figure>

<p>This capability was expanded in two ways. First, it now works even with more complex function bodies containing more than one return statement, as long as all return statements return the same type:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14</span></span><br><span class="line">[=] &#123;                                     <span class="comment">// ok, deduces &quot;-&gt; some_type&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">something</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>;            <span class="comment">// works with arbitrary control flow</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar.<span class="built_in">baz</span>(<span class="number">84</span>);                   <span class="comment">// &amp; multiple returns</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Second, it now works with all functions, not just lambdas:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11, explicitly named return type</span></span><br><span class="line"><span class="function">some_type <span class="title">f</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> -&gt; some_type </span>&#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span>              </span>&#123; <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>; &#125; <span class="comment">// ok, deduces &quot;-&gt; some_type&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">g</span><span class="params">()</span> </span>&#123;                                <span class="comment">// ok, deduces &quot;-&gt; some_type&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">something</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expr) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">foo</span>() * <span class="number">42</span>;            <span class="comment">// with arbitrary control flow</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar.<span class="built_in">baz</span>(<span class="number">84</span>);                   <span class="comment">// &amp; multiple returns</span></span><br><span class="line">&#125;                                         <span class="comment">//   (types must be the same)</span></span><br></pre></td></tr></table></figure>

<p>Of course, this requires the function body to be visible.</p>
<p>Finally, someone will ask: “Does this work for recursive functions?” The answer is yes, as long as a <code>return</code> precedes the recursive call.</p>
<p>See also:</p>
<ul>
<li>[N3638] Jason Merrill: <a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3638.html">Return type deduction for normal functions</a>.</li>
</ul>
<p>In summary:</p>
<p>C++14 can have multiple return expressions without using <code>trailing return</code> (multiple return), but the types of these return values must be the same.</p>
<p>However, C++11 does not have this property, so I suspect it might be a bug in the compiler…</p>
<h3 id="Parameter-Binding"><a href="#Parameter-Binding" class="headerlink" title="Parameter Binding"></a>Parameter Binding</h3><p>For simple operations that are only used in one or two places, lambda expressions can be used. However, if we need to use the same operation in many places, it is often better to define a function instead of rewriting the same lambda expression multiple times.</p>
<p>If the capture list of a lambda is empty, a function can usually substitute it.</p>
<p>For example, in the sample code used to introduce lambdas:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">vector&lt;string&gt; word&#123;<span class="string">&quot;I&quot;</span>, <span class="string">&quot;need&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;follow&quot;</span>, <span class="string">&quot;my&quot;</span>, <span class="string">&quot;heart&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// If the capture list is empty, using num within the lambda function is erroneous</span></span><br><span class="line"><span class="comment">// error: cannot implicitly capture &quot;num&quot; as the default capture mode has not been specified</span></span><br><span class="line"><span class="keyword">auto</span> oneIndex = <span class="built_in">find_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), [num](<span class="type">const</span> string&amp; a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= num; &#125;);</span><br><span class="line"><span class="comment">// Get the first element in word whose length exceeds 5</span></span><br><span class="line">cout &lt;&lt; *oneIndex &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>We can implement it using either a lambda (as shown above) or by defining a function:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, we cannot use this function as a parameter to <code>find_if</code>. As introduced in lambdas, find_if requires a “unary predicate” parameter, meaning the given parameter must accept a single argument. To replace the lambda with check_size, we need to solve the problem of how to pass a parameter to the sz parameter.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The calling form of check_size</span></span><br><span class="line"><span class="built_in">check_size</span>(strObj, sizeNum);</span><br><span class="line"><span class="comment">// find_if can only accept predicates, and currently we need to solve how to call check_size while only taking one unary predicate</span></span><br><span class="line"><span class="built_in">check_size</span>(strObj);</span><br></pre></td></tr></table></figure>

<h4 id="Standard-Bind-Function"><a href="#Standard-Bind-Function" class="headerlink" title="Standard Bind Function"></a>Standard Bind Function</h4><p>By using the bind function, we can resolve the issue of passing a length parameter to check_size.</p>
<p>The <code>bind</code> standard library function is defined in the <code>functional</code> header file. You can think of the bind function as a generalized function adapter, creating a new callable object to “adapt” the parameter list of the original object.</p>
<p>The general form to call bind is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list);</span><br></pre></td></tr></table></figure>

<p>Here, <code>newCallable</code> itself is a callable object, and arg_list is a comma-separated list of parameters corresponding to the parameters of the given callable. That is, when we call newCallable, it will call callable and pass the parameters specified in arg_list.</p>
<p>The parameters in <code>arg_list</code> may contain names like <code>_n</code>, where n is an integer. These are “placeholders” representing the parameters of newCallable, occupying the positions of the parameters passed to newCallable. The number n indicates the position of the parameter in the generated callable object: <code>_1</code> represents the first parameter of newCallable, <code>_2</code> represents the second parameter, and so on.</p>
<h4 id="Using-Placeholders"><a href="#Using-Placeholders" class="headerlink" title="Using Placeholders"></a>Using Placeholders</h4><p>Note: The names <code>_n</code> are defined in a namespace called <code>placeholders</code>, which itself is defined in the <code>std</code> namespace.</p>
<p>So when we use <code>_1</code>, <code>_2</code>, etc. in bind, we must use the std::placeholders namespace:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All names in this namespace can be used in the program</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="comment">// Or specify a single name using std::placeholders</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders::_1;</span><br><span class="line"><span class="comment">// Or specify the namespace directly at the place of use</span></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size, std::placeholders::_1, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>Otherwise, there will be a compile error:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/2441/15.webp"></p>
<h4 id="Binding-Parameters-with-Bind"><a href="#Binding-Parameters-with-Bind" class="headerlink" title="Binding Parameters with Bind"></a>Binding Parameters with Bind</h4><p><strong>By binding the sz parameter of check_size via bind</strong>, we generate a unary predicate that accepts a single parameter.</p>
<p>As mentioned earlier, we need to pass check_size, which accepts two parameters, to a function that must accept a unary predicate, so we need to generate an object that invokes check_size via bind.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check6 is a callable object that accepts a string type parameter</span></span><br><span class="line"><span class="comment">// and uses this string and 6 to call check_size</span></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size, _1, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>This bind call only has one placeholder, indicating that check6 accepts a single parameter. The placeholder appears in the first position of <code>arg_list</code>, signifying this parameter corresponds to the first parameter of check_size. This parameter is a const string&amp;. Thus, calling check6 must involve passing a string-type parameter to it, and check6 will pass this parameter to check_size.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">bool</span> bl = <span class="built_in">check6</span>(s);</span><br></pre></td></tr></table></figure>

<p>Using <code>gprof</code>, we can see that check_size was called once.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> %   cumulative   self              self     total</span><br><span class="line">time   seconds   seconds    calls  Ts/call  Ts/call  name</span><br><span class="line"> <span class="number">0.00</span>      <span class="number">0.00</span>     <span class="number">0.00</span>        <span class="number">1</span>     <span class="number">0.00</span>     <span class="number">0.00</span>  <span class="built_in">check_size</span>(<span class="comment">/* omitted parameters for brevity */</span>)</span><br></pre></td></tr></table></figure>

<p>With bind, we can replace the original lambda-based find_if call:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [sz](<span class="type">const</span> string&amp; a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure>

<p>With the version that uses check_size:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(check_size, _1, sz));</span><br></pre></td></tr></table></figure>

<p>This bind call generates a callable object that binds the second parameter of check_size to the value of sz. When <code>find_if</code> calls this object on each string in words, it will invoke check_size, passing the given string and sz to it. Thus, find_if can effectively compare the size of each string with sz in the input sequence.</p>
<h4 id="Bind-Parameter-Details"><a href="#Bind-Parameter-Details" class="headerlink" title="Bind Parameter Details"></a>Bind Parameter Details</h4><p>As previously mentioned, we can use bind to fix the values of parameters. More generally, bind can also be used to bind parameters in callable objects or rearrange the order of their parameters.</p>
<p>For instance, if f is a callable object with five parameters, then the following call to bind:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f, a, b, _2, c, _1);</span><br></pre></td></tr></table></figure>

<p>The above code will generate a callable object with two parameters, represented by placeholders _1 and _2. This new callable object will pass its parameters as the third and fifth parameters to f. The first, second, and fourth parameters of f are bound to the given values a, b, and c respectively.</p>
<p>The parameters passed to g will be bound to the placeholders according to their positions. Thus, when we call g, its first parameter will be passed to f as the last parameter, and the second parameter will be passed as the third parameter.</p>
<p>In effect, this call will map <code>g(_1, _2)</code> to <code>f(a, b, _2, c, _1)</code>. That is, a call to g will invoke f with g’s parameters replacing the placeholders, plus the bound parameters a, b, and c. For example, calling g(X,Y) would result in invoking f with parameters a, b, Y, c, X.</p>
<h5 id="Using-Bind-to-Rearrange-Parameter-Order"><a href="#Using-Bind-to-Rearrange-Parameter-Order" class="headerlink" title="Using Bind to Rearrange Parameter Order"></a>Using Bind to Rearrange Parameter Order</h5><p>Note: <code>sort</code> is defined in the <code>algorithm</code> header file and must be included before use.</p>
<p>We can use sort to order the contents of a container, first defining a binary predicate.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string&amp; s1, <span class="type">const</span> string&amp; s2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can use sort to order a vector<string> storing data (in ascending order):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; words&#123;<span class="string">&quot;I&quot;</span>, <span class="string">&quot;need&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;follow&quot;</span>, <span class="string">&quot;my&quot;</span>, <span class="string">&quot;heart&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> index : words)</span><br><span class="line">    cout &lt;&lt; index &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>The result is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I to my need heart follow</span><br></pre></td></tr></table></figure>

<p>The sort result is ordered in ascending, but what if we want it in descending order? Can we simply modify the implementation of isShorter?</p>
<p>Not necessarily, we can use bind to reorder the parameters to achieve this.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Switch the first parameter of the sort predicate to be the second parameter of isShorter</span></span><br><span class="line"><span class="comment">// Switch the second parameter of the sort predicate to be the first parameter of isShorter</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(isShorter, _2, _1));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> index : words)</span><br><span class="line">    cout &lt;&lt; index &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>The result will be:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">follow heart need to my I</span><br></pre></td></tr></table></figure>

<h4 id="Binding-Reference-Parameters-ref-n"><a href="#Binding-Reference-Parameters-ref-n" class="headerlink" title="Binding Reference Parameters (ref(_n))"></a>Binding Reference Parameters (ref(_n))</h4><p>By default, parameters that are not placeholders in bind are copied into the callable object returned by bind. However, similar to lambda, we hope to pass some bound parameters by reference, or the type of the parameter we want to bind cannot be copied (I/O objects cannot be copied or assigned).</p>
<p>For example, to replace a captured <code>ostream</code> (which cannot be copied) with a lambda:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os is a local variable, referencing an output stream</span></span><br><span class="line"><span class="comment">// c is a local variable of type char</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [&amp;os](<span class="type">const</span> string&amp; s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br></pre></td></tr></table></figure>

<p>We can easily write a function to perform the same task:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> string&amp; s, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, we cannot directly use bind to replace the capture of os:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error, cannot copy os</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, os, _1, <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>The reason is that bind copies its parameters, and we cannot copy an ostream. If we want to pass an object to bind without copying it, we must use the <code>standard library ref function</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os), _1, <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>The ref function returns an object that contains a given reference, and this object is copyable. The standard library also has a <code>cref</code> function that generates a class that holds a const reference. </p>
<h4 id="Backward-Compatibility-Parameter-Binding"><a href="#Backward-Compatibility-Parameter-Binding" class="headerlink" title="Backward Compatibility: Parameter Binding"></a>Backward Compatibility: Parameter Binding</h4><p>Older versions of the standard library (before C++11) defined two functions named <code>bind1st</code> and <code>bind2nd</code>. Similar to bind, these two functions accept a function as a parameter and generate a new callable object that calls the given function and passes the bound parameter to it. However, these functions can only bind the first or second parameter, respectively. Due to their limitations, these functions have been deprecated in the new standard. The term deprecated means that the feature is no longer supported in newer versions. In new C++ programs, bind should be used.</p>

    </div>

    
    
        
        
          
            <blockquote class="blockquote-center">
              
                The article is finished. If you have any questions, please comment and communicate.
              
            <br/>
            
                <div class="qr-code" onclick="return false">
                    <script src="/js/qrcode.min.js"></script>
                    <div id="qrcode">
                      
                        <img src="https://imzlp.com/images/wechat-qrcode.webp">
                      
                    <p>Scan the QR code on WeChat and follow me.</p>
                    </div>
                </div>
            
            </blockquote>
          
        

        
          <div class="postCopyright" style="clear:both;">
             <span>Title:</span><a href="/posts/2441/" target="_blank">C++11 syntactic sugar</a><br/>
             <span>Author:</span><a href="/about" target="_blank" title="查看 LIPENGZHA 的资料">LIPENGZHA</a><br/>
             <span>Publish Date:</span>2016/05/12 22:30<br/>
             
             <span>Word Count:</span><span class="page-count">44k Words</span><br/>
             
             <span>Link:</span><a href="/posts/2441/" target="_blank" title="C++11 syntactic sugar">https://en.imzlp.com/posts/2441/</a>
             <span class="copy-path" data-clipboard-text="Link: https://en.imzlp.com/posts/2441/ Author: LIPENGZHA" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
             <script src="/js/jquery.min.js"></script>
             <script src="/js/clipboard.min.js"></script>
             <script> var clipboard = new Clipboard('.copy-path'); </script>
             <br/>
             
             <span>License:</span><i class="fab fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">CC BY-NC-SA 4.0</a><br/>
             
             <span>Reprinting of the full article is prohibited.</span>
          </div>
        
    

        
  <div class="reward-container">
    <div>Your donation will encourage me to keep creating!</div>
    <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
      Donate
    </button>
    <div id="qr" style="display: none;">
        
        <div style="display: inline-block;">
          <img src="/images/reward/wechatpay.webp" alt="LIPENGZHA WeChat Pay">
          <p>WeChat Pay</p>
        </div>

    </div>
  </div>



      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/C-11/" rel="tag"># C++11</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/58483/" rel="prev" title="Operating system interprocess communication">
      <i class="fa fa-chevron-left"></i> Operating system interprocess communication
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/50773/" rel="next" title="Memory leak caused by STL releasing pointer elements">
      Memory leak caused by STL releasing pointer elements <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-utteranc">utteranc</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane utteranc" id="comment-utteranc">
              
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="hxhb/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#List-Initialization"><span class="nav-number">1.</span> <span class="nav-text">List Initialization</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List-Initialization-1"><span class="nav-number">1.1.</span> <span class="nav-text">List Initialization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Initializer-List"><span class="nav-number">1.2.</span> <span class="nav-text">Initializer List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Return-Value-of-List-Initialization"><span class="nav-number">1.3.</span> <span class="nav-text">Return Value of List Initialization</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List-Initialization-of-Associative-Containers"><span class="nav-number">1.4.</span> <span class="nav-text">List Initialization of Associative Containers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Return-Type-of-List-Initialization-Pair"><span class="nav-number">1.5.</span> <span class="nav-text">Return Type of List Initialization Pair</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nullptr-Constant"><span class="nav-number">2.</span> <span class="nav-text">nullptr Constant</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr"><span class="nav-number">3.</span> <span class="nav-text">constexpr</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr-Variables"><span class="nav-number">3.1.</span> <span class="nav-text">constexpr Variables</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr-Pointers"><span class="nav-number">3.2.</span> <span class="nav-text">constexpr Pointers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr-Functions"><span class="nav-number">3.3.</span> <span class="nav-text">constexpr Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Constexpr-Constructors"><span class="nav-number">3.4.</span> <span class="nav-text">Constexpr Constructors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Address-Constant-Expressions"><span class="nav-number">3.5.</span> <span class="nav-text">Address Constant Expressions</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Type-Deduction"><span class="nav-number">4.</span> <span class="nav-text">Type Deduction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Auto-Type-Specifier"><span class="nav-number">4.1.</span> <span class="nav-text">Auto Type Specifier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#decltype-Type-Specifier"><span class="nav-number">4.2.</span> <span class="nav-text">decltype Type Specifier</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#decltype-and-References"><span class="nav-number">4.2.1.</span> <span class="nav-text">decltype and References</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Simplifying-Declarations-with-auto-and-decltype"><span class="nav-number">4.3.</span> <span class="nav-text">Simplifying Declarations with auto and decltype</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-string-Objects-as-Filenames-for-File-Stream-Objects"><span class="nav-number">5.</span> <span class="nav-text">Using string Objects as Filenames for File Stream Objects</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STL-Container-Related-Features"><span class="nav-number">6.</span> <span class="nav-text">STL Container Related Features</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#array-and-forward-list-Containers"><span class="nav-number">6.1.</span> <span class="nav-text">array and forward_list Containers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#initializer-list-Parameter"><span class="nav-number">6.2.</span> <span class="nav-text">initializer_list Parameter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Return-Type-of-Insert-in-Containers"><span class="nav-number">6.3.</span> <span class="nav-text">Return Type of Insert in Containers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Emplace-Operation"><span class="nav-number">6.4.</span> <span class="nav-text">Emplace Operation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String-Numeric-Conversion-Functions"><span class="nav-number">6.5.</span> <span class="nav-text">String Numeric Conversion Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Functions-for-Managing-Capacity"><span class="nav-number">6.6.</span> <span class="nav-text">Functions for Managing Capacity</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Difference-between-Capacity-and-Size"><span class="nav-number">6.6.1.</span> <span class="nav-text">Difference between Capacity and Size</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Unordered-Containers"><span class="nav-number">6.7.</span> <span class="nav-text">Unordered Containers</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Using-Unordered-Containers"><span class="nav-number">6.7.1.</span> <span class="nav-text">Using Unordered Containers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Managing-Buckets"><span class="nav-number">6.7.2.</span> <span class="nav-text">Managing Buckets</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Requirements-for-Keyword-Types-in-Unordered-Containers"><span class="nav-number">6.7.3.</span> <span class="nav-text">Requirements for Keyword Types in Unordered Containers</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-Expressions"><span class="nav-number">7.</span> <span class="nav-text">Lambda Expressions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Passing-Parameters-to-Lambda"><span class="nav-number">7.1.</span> <span class="nav-text">Passing Parameters to Lambda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-Capture-Lists"><span class="nav-number">7.2.</span> <span class="nav-text">Using Capture Lists</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Predicate"><span class="nav-number">7.2.1.</span> <span class="nav-text">Predicate</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-Capture-and-Return"><span class="nav-number">8.</span> <span class="nav-text">Lambda Capture and Return</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Value-Capture"><span class="nav-number">8.1.</span> <span class="nav-text">Value Capture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reference-Capture"><span class="nav-number">8.2.</span> <span class="nav-text">Reference Capture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Implicit-Capture"><span class="nav-number">8.3.</span> <span class="nav-text">Implicit Capture</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Various-Capture-Methods-of-Lambda"><span class="nav-number">8.4.</span> <span class="nav-text">Various Capture Methods of Lambda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda-Capturing-this-in-Member-Functions"><span class="nav-number">8.5.</span> <span class="nav-text">Lambda Capturing this in Member Functions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mutable-Lambda"><span class="nav-number">8.6.</span> <span class="nav-text">Mutable Lambda</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Specifying-the-Return-Type-of-Lambda"><span class="nav-number">8.7.</span> <span class="nav-text">Specifying the Return Type of Lambda</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parameter-Binding"><span class="nav-number">9.</span> <span class="nav-text">Parameter Binding</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Standard-Bind-Function"><span class="nav-number">9.1.</span> <span class="nav-text">Standard Bind Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-Placeholders"><span class="nav-number">9.2.</span> <span class="nav-text">Using Placeholders</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binding-Parameters-with-Bind"><span class="nav-number">9.3.</span> <span class="nav-text">Binding Parameters with Bind</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bind-Parameter-Details"><span class="nav-number">9.4.</span> <span class="nav-text">Bind Parameter Details</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Using-Bind-to-Rearrange-Parameter-Order"><span class="nav-number">9.4.1.</span> <span class="nav-text">Using Bind to Rearrange Parameter Order</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Binding-Reference-Parameters-ref-n"><span class="nav-number">9.5.</span> <span class="nav-text">Binding Reference Parameters (ref(_n))</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Backward-Compatibility-Parameter-Binding"><span class="nav-number">9.6.</span> <span class="nav-text">Backward Compatibility: Parameter Binding</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person" oncontextmenu="return false" οndragstart="return false">
    <img class="site-author-image" itemprop="image" alt="LIPENGZHA"
      src="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
  <p class="site-author-name" itemprop="name">LIPENGZHA</p>
  <div class="site-description" itemprop="description">"I think, therefore I am"</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
             
          <span class="site-state-item-count">190</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">95</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">190</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxhb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxhb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/lipengzha" title="Linkedin → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;lipengzha" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/imzlp" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;imzlp" rel="noopener" target="_blank"><i class="fa fa-custom zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat-qrcode-offical.webp" title="微信公众号 → &#x2F;images&#x2F;wechat-qrcode-offical.webp"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imzlp@foxmail.com" title="E-Mail → mailto:imzlp@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://consolehelp.imzlp.com/" title="https:&#x2F;&#x2F;consolehelp.imzlp.com&#x2F;" rel="noopener" target="_blank">UE Console Help</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/opensource/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;opensource&#x2F;" rel="noopener" target="_blank">Open Source Projects</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/posts/11515/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;posts&#x2F;11515&#x2F;" rel="noopener" target="_blank">UE C++ API Dash Documents</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ue5wiki.com/" title="https:&#x2F;&#x2F;ue5wiki.com&#x2F;" rel="noopener" target="_blank">Unreal Engine Wiki</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LIPENGZHA</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.5m</span>
</div>
  <div class="powered-by-other">
    
	    <center>Github Pages | Actions | NeXT | Cloudflare | Hexo Deploy</center>
      
  </div>

<script>
function checkWebp(callback) {
    var img = new Image();
    img.onload = function () { callback((img.width > 0) && (img.height > 0)); };
    img.onerror = function () { callback(false); };
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
}
function showImage(useWebp) {
    var imgs = [].slice.call(document.querySelectorAll('img'));
    imgs.forEach(function (e) {
        if (!useWebp) {
            var src = e.getAttribute('data-src')
            src = src.replace(/\.webp$/, '.png');
            e.setAttribute('data-src', src);
        }
    });
}
checkWebp(showImage);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animejs/3.2.1/anime.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.5.1/jquery.min.js"></script>
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



<script src="/js/code-unfold.js"></script>

  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  
  <script src="//img.imzlp.com/imgs/zlp/picgo/2021/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://en.imzlp.com/posts/2441/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    var requiredFields = 'nick';
    requiredFields = requiredFields.split(',');
    
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oCE6RMVkVoi5MgUhvFsn1EvV-gzGzoHsz',
      appKey     : 'K9SOaNYJ8PV6xaoFggWG5xvv',
      placeholder: "Leave something behind~",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields: requiredFields
    });
  }, window.Valine);
});
</script>

</body>
</html>
