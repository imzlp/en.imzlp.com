<!DOCTYPE html>
<html lang="en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-tilt-brush.png">
  <link rel="mask-icon" href="/images/favicon-32x32-tilt-brush.png" color="#222">
  <meta name="google-site-verification" content="ttIkhAIFZQM9Huj8roB0l95ePN2Tv2zv2wRFksi09WA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Pacifico:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"en.imzlp.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"width":280},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"code_unfold":{"enable":true,"CODE_MAX_HEIGHT":600},"path":"search.xml"};
  </script>

  <meta name="description" content="In C++, when the operand types of an operator are inconsistent, these operands will be converted to the same type. Type conversion is divided into implicit conversion and explicit conversion.">
<meta property="og:type" content="article">
<meta property="og:title" content="Detailed analysis of type conversion in C++">
<meta property="og:url" content="https://en.imzlp.com/posts/27258/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="In C++, when the operand types of an operator are inconsistent, these operands will be converted to the same type. Type conversion is divided into implicit conversion and explicit conversion.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27258/arithmetic-type-in-cpp.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27258/signedToUnsigned.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27258/4294967185.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27258/!const2const-Point-address.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27258/C:/Users/visionsmile/Desktop/doubleVal2voidPoint2doublePoint.webp">
<meta property="article:published_time" content="2016-05-04T19:35:17.000Z">
<meta property="article:modified_time" content="2016-05-04T19:35:17.000Z">
<meta property="article:author" content="LIPENGZHA">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="技术笔记">
<meta property="article:tag" content="读书笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27258/arithmetic-type-in-cpp.webp">

<link rel="canonical" href="https://en.imzlp.com/posts/27258/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Detailed analysis of type conversion in C++ | Z's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDCJ41EFP5"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FDCJ41EFP5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Z's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-edit fa-fw"></i>Notes</a>

  </li>


      
        
            
  <li class="menu-item menu-item-essay">

    <a href="/essay/" rel="section"><i class="fas fa-feather-alt fa-fw"></i>Essay</a>

  </li>


      
        
            
  <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-inbox fa-fw"></i>Resources</a>

  </li>


      
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fas fa-link fa-fw"></i>Friends</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me</a>

  </li>


      
        <li class="menu-item menu-item-showcase">

    <a href="/showcase/" rel="section"><i class="fa fa-solid fa-trophy fa-fw"></i>ShowCase</a>

  </li>
        <li class="menu-item menu-item-changelog">

    <a href="/changelog/" rel="section"><i class="fa fa-history fa-fw"></i>Site Log</a>

  </li>
        <li class="menu-item menu-item-opensource">

    <a href="/opensource/" rel="section"><i class="fas fa-code-branch fa-fw"></i>Open Source</a>

  </li>
        <li class="menu-item menu-item-uewiki">

    <a href="https://ue5wiki.com/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>Unreal Wiki</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>



<script type="text/javascript">
  let domain='en.imzlp.com';
  let domain_str = atob(domain);
  let pathname = location.pathname;
  if (domain_str!= location.host.toLowerCase()){
        console.log(`this host is not safe,jump to https://${domain_str}${pathname}`);
        location.href=`https://${domain_str}${pathname}`;
  }
</script>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <div class="l10n-header-widget">
    <script>
      // 获取当前页面的 URL
      const currentUrl = window.location.href;
      // 替换 URL 中的部分内容
      const jumpToL10nLink = currentUrl.replace('en.imzlp.com', 'imzlp.com');
      // 将 jumpToL10nLink 绑定到一个全局变量
      window.jumpToL10nLink = jumpToL10nLink;
    </script>

    <a href="#" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: none;" rel="noopener" target="_blank" onclick="window.open(window.jumpToL10nLink, '_blank'); return false;">
      <i class="fa fa-solid fa-language"></i>
    </a>
  </div>



    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en"
  >
    <link itemprop="mainEntityOfPage" href="https://en.imzlp.com/posts/27258/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
      <meta itemprop="name" content="LIPENGZHA">
      <meta itemprop="description" content=""I think, therefore I am"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Detailed analysis of type conversion in C++<a href="https://github.com/imzlp/blog-md/blob/en/_posts/2016-05-04-27258.md" class="post-edit-link" title="Edit this post" style="float: right;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a><a href="https://imzlp.com/posts/27258/" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-solid fa-language"></i></a>
        </h1>

        
          <div class="post-subtitle" style="text-align: center;line-height: 1;">
            <sub text-align="center" style="font-size: 15px;align-content: center;font-style: italic;bottom: 0em;">详细分析C++中的类型转换</sub>
          </div>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-04 19:35 19:35:17:35" itemprop="dateCreated datePublished" datetime="2016-05-04T19:35:17+00:00">2016-05-04 19:35</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span id="/posts/27258/" class="post-meta-item leancloud_visitors" data-flag-title="Detailed analysis of type conversion in C++" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>43 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>In C++, when the operand types of an operator are inconsistent, these operands will be converted to the same type. Type conversion is divided into <strong>implicit conversion</strong> and <strong>explicit conversion</strong>.</p>
<span id="more"></span>

<p>First, let’s understand the meaning of built-in types in C++ and their standard defined sizes:</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Meaning</th>
<th align="center">Minimum Size</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">Boolean Type</td>
<td align="center">Undefined</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
<td align="center">8 bits</td>
</tr>
<tr>
<td align="center">wchar_t</td>
<td align="center">Wide Character</td>
<td align="center">16 bits</td>
</tr>
<tr>
<td align="center">char16_t</td>
<td align="center">Unicode Character</td>
<td align="center">16 bits</td>
</tr>
<tr>
<td align="center">char32_t</td>
<td align="center">Unicode Character</td>
<td align="center">32 bits</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short Integer</td>
<td align="center">16 bits</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
<td align="center">16 bits</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long Integer</td>
<td align="center">32 bits</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">Long Long Integer</td>
<td align="center">64 bits</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Single Precision Floating Point</td>
<td align="center">6 Significant Digits</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double Precision Floating Point</td>
<td align="center">10 Significant Digits</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">Extended Precision Floating Point</td>
<td align="center">10 Significant Digits</td>
</tr>
</tbody></table>
<p>The following code can be used to detect the sizes of built-in types across different systems (32-bit and 64-bit):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;bool&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">bool</span>),<span class="built_in">sizeof</span>(<span class="type">bool</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;char&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">char</span>),<span class="built_in">sizeof</span>(<span class="type">char</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;wchar_t&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">wchar_t</span>),<span class="built_in">sizeof</span>(<span class="type">wchar_t</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;char16_t&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">char16_t</span>),<span class="built_in">sizeof</span>(<span class="type">char16_t</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;char32_t&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">char32_t</span>),<span class="built_in">sizeof</span>(<span class="type">char32_t</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;short&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">short</span>),<span class="built_in">sizeof</span>(<span class="type">short</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;int&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>),<span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;long&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">long</span>),<span class="built_in">sizeof</span>(<span class="type">long</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;long long&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>),<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;float&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">float</span>),<span class="built_in">sizeof</span>(<span class="type">float</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;double&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">double</span>),<span class="built_in">sizeof</span>(<span class="type">double</span>)*<span class="number">8</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%11s\t%3d byte\t%3d bit\n&quot;</span>,<span class="string">&quot;long double&quot;</span>,<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>),<span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>)*<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/27258/arithmetic-type-in-cpp.webp"></p>
<h2 id="Implicit-Type-Conversion"><a href="#Implicit-Type-Conversion" class="headerlink" title="Implicit Type Conversion"></a>Implicit Type Conversion</h2><p>In C++, three situations trigger <strong>(implicit) type conversion</strong>:</p>
<ol>
<li>In a mixed-type expression, the operands are converted to the same type (integer promotion).</li>
<li>When used as a conditional expression, they are converted to bool (non-zero becomes true).</li>
<li>When an expression initializes a variable or assigns a value to a variable, the value of that expression is converted to the type of that variable.</li>
</ol>
<p>The basic rules for <strong>(implicit) type conversion</strong> in C++ are:</p>
<ul>
<li><strong>Integer Promotion</strong>: Converts smaller integer types to larger integer types.</li>
<li><strong>Truncation</strong>: When converting from higher precision to lower precision, truncation occurs (e.g., converting from float to int discards the decimal part).</li>
<li><strong>Arithmetic types to bool</strong>: Non-zero becomes true, while all others become false.</li>
<li><strong>Conversion between signed and unsigned</strong>: This has side effects (e.g., assigning a negative value to an unsigned type).</li>
</ul>
<h3 id="Integer-Promotion"><a href="#Integer-Promotion" class="headerlink" title="Integer Promotion"></a>Integer Promotion</h3><p>For types such as <code>bool</code>, <code>char</code>, <code>signed char</code>, <code>unsigned char</code>, <code>short</code>, and <code>unsigned short</code>, they will be promoted to <code>int</code> if all their possible values can fit in <code>int</code>, otherwise, they will be promoted to <code>unsigned int</code>.</p>
<p>Larger <code>char</code> types (<code>wchar_t</code>, <code>char16_t</code>, <code>char32_t</code>) are promoted to the <strong>smallest type</strong> among <code>int</code>, <code>unsigned int</code>, <code>long</code>, <code>unsigned long</code>, <code>long long</code>, and <code>unsigned long long</code>, provided that the <strong>converted type must be able to hold all possible values of the original type</strong>.</p>
<p>If all possible values of a bit-field can be represented by <code>int</code>, it is converted to <code>int</code>; otherwise, if all values can be represented by <code>unsigned int</code>, it is converted to <code>unsigned int</code>; if neither <code>int</code> nor <code>unsigned int</code> can represent all values, no integer promotion is performed.<br><code>Bit-field</code>: You can specify the number of bits occupied by members using a struct to define it as a bit-field.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 32-bit bit-field example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PPN</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> PFN:<span class="number">22</span>;</span><br><span class="line">  <span class="type">int</span>:<span class="number">3</span>;  <span class="comment">// Unused bits</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> CCA:<span class="number">3</span>;</span><br><span class="line">  <span class="type">bool</span> nonreachable:<span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span> dirty:<span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span> valid:<span class="number">1</span>;</span><br><span class="line">  <span class="type">bool</span> global:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The bool value converts to int, where false becomes 0 and true becomes 1.</p>
<h3 id="Conversion-of-Floating-Point-Types"><a href="#Conversion-of-Floating-Point-Types" class="headerlink" title="Conversion of Floating Point Types"></a>Conversion of Floating Point Types</h3><p>For floating-point operations and rounding, you can refer to these two articles: <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IEEE_754">IEEE 754</a> and <a target="_blank" rel="noopener" href="https://imzlp.com/2015/08/18/two-iterator-init-container-result-in-floating-point-rounding/">Floating-point rounding in two iterator initialization containers</a>.</p>
<p>Given a floating-point value, we can convert it to other floating-point types. If the original value can be completely represented by the target type, the resultant value is equal to the original value. If the original value lies between two adjacent target values, one of them is taken. In other cases, the result is undefined.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d1=DBL_MAX;  <span class="comment">// The largest double precision floating-point value</span></span><br><span class="line"><span class="type">float</span> f1=d1;  <span class="comment">// If DBL_MAX &gt; FLT_MAX, the result is undefined.</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">double</span> ld=numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"><span class="type">double</span> d1=ld; <span class="comment">// If sizeof(long double) &gt; sizeof(double), the result is undefined.</span></span><br></pre></td></tr></table></figure>

<p><strong>Conversion from high precision to low precision involves truncation.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dPI=<span class="number">3.14159</span>;</span><br><span class="line"><span class="comment">// iPI results in 3, truncation occurs</span></span><br><span class="line"><span class="type">int</span> iPI=dPI;</span><br></pre></td></tr></table></figure>

<p><strong>Conversion from low precision to high precision involves widening.</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival=<span class="number">3</span>;</span><br><span class="line"><span class="comment">// fval becomes 3.00000</span></span><br><span class="line"><span class="type">float</span> fval=ival;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Additionally, earlier versions of C++ allowed rounding up or down for results to be negative, while the C++11 standard stipulates that division is always truncated toward zero (i.e., truncation -&gt; direct removal of the decimal part).</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">-12</span>;</span><br><span class="line"><span class="type">int</span> y=<span class="number">5</span>;</span><br><span class="line"><span class="comment">// Result is -2</span></span><br><span class="line">cout&lt;&lt;x/y&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>Using <code>numeric_limits</code> ensures that truncation occurs in a portable manner. During initialization, the <code>&#123;&#125;</code> initializer helps prevent truncation.</p>
<h3 id="Conversion-Between-Unsigned-Types"><a href="#Conversion-Between-Unsigned-Types" class="headerlink" title="Conversion Between Unsigned Types"></a>Conversion Between Unsigned Types</h3><p>If the target type is unsigned, the resulting value occupies the same number of bits as the target type (losing leading bits if necessary). More accurately, the value of the integer before conversion is the result of taking the modulus with respect to $2^n$, where n is the number of bits the target type occupies.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In binary 1111111111: uc&#x27;s value becomes binary 111111, which is 255</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> uc=<span class="number">1023</span>;</span><br></pre></td></tr></table></figure>
<p>If the target type is signed, when the original value can be represented by the target type, it remains unchanged; otherwise, the resulting value depends on the specific implementation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Depends on the implementation, result is 127 or -1</span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> sc=<span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>A bool value or a regular enum value can be implicitly converted to an equivalent integer type.</p>
<p>If an operand is of an unsigned type, then the result of the conversion will depend on the relative sizes of the integer types in the machine.</p>
<blockquote>
<p>Because the standard specifies that <strong>int</strong> is not less than <strong>short</strong>, <strong>long</strong> is not less than <strong>int</strong>, and <strong>long long</strong> is not less than <strong>long</strong>, there is a possibility that <strong>int (default is signed)</strong> may not fit <strong>unsigned short</strong> or <strong>long</strong> may not fit <strong>unsigned int</strong>, and <strong>long long</strong> may not fit <strong>unsigned long</strong>. Special care should be taken in such cases.</p>
</blockquote>
<p><strong>When an expression contains short and int, short is converted to int.</strong></p>
<p>When the int type can adequately represent all <strong>unsigned short</strong> values, <strong>unsigned short</strong> is converted to int; otherwise, both operands will be converted to <strong>unsigned int.</strong></p>
<p><strong>Converting from unsigned int to long</strong> and <strong>from unsigned long to long long</strong> follows the same principle.</p>
<p><strong>In addition, note the following:</strong></p>
<ul>
<li><strong>Assign a value to an unsigned type:</strong> The result is the initial value modulo the total number of values that the unsigned type can represent $2^n$ (for example, unsigned char can contain values from 0 to 255, so it can represent 256 values).</li>
<li><strong>Converting from signed (default) type to unsigned type</strong> may cause <strong>side effects (assigning a negative value to unsigned)</strong>.</li>
<li><strong>Assigning a value outside its range to a signed type:</strong> The result is <strong>undefined</strong>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> x=<span class="number">258</span>;</span><br><span class="line"><span class="comment">// out:2</span></span><br><span class="line">cout&lt;&lt;x;</span><br><span class="line"><span class="comment">// The result is the value of 258 % 256</span></span><br></pre></td></tr></table></figure>

<p><strong>Assigning a negative value to an unsigned type</strong><br>Negative values in computers involve the concept of two’s complement; for detailed explanations, refer to these articles: <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/IEEE_754">IEEE 754: Binary Floating-Point Arithmetic Standard</a>, <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2009/08/twos_complement.html">About Two’s Complement</a>, <a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html">Original Code, One’s Complement, Two’s Complement Explained</a>.</p>
<p>We will briefly cover the basics of the concepts of original code, one’s complement, and two’s complement:</p>
<blockquote>
<p><strong>Original code:</strong> The method for handling sign and magnitude is to allocate a sign bit to represent the sign: setting this bit (usually the most significant bit) to 0 denotes a positive number, and 1 denotes a negative number.</p>
<p><strong>One’s complement:</strong> The binary representation of a number in one’s complement form is achieved by inverting its magnitude (the sign bit remains the same, but all other bits are inverted).</p>
<p><strong>Two’s complement:</strong> When a number is greater than or equal to 0, its two’s complement remains the same as its original code; if the number is less than zero, it is obtained by keeping the sign bit the same while inverting all other bits, and then adding 1 (i.e., adding 1 to the one’s complement).</p>
</blockquote>
<p>Signed data is typically encoded in computers using two’s complement, as both original and one’s complement representations have two forms for zero: <code>-0</code> and <code>+0</code>.</p>
<p>Let’s test assigning a negative number to an unsigned type:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// To make things easier, we&#x27;ll use a 1-byte char here</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> x=<span class="number">-2</span>;</span><br><span class="line"><span class="comment">// Output the value of character x (since there are many null characters in char, direct output sometimes can&#x27;t intuitively show test results)</span></span><br><span class="line">cout&lt;&lt;(<span class="type">int</span>)x;</span><br></pre></td></tr></table></figure>

<p>After compiling and running, the result is: 254.</p>
<p>Since a number’s two’s complement is the way it is stored in a computer, assigning a negative value to an unsigned type causes the sign bit to act as a value. Thus, the actual value stored after assigning a negative value to an unsigned type is <strong>the total number of values it can represent minus the absolute value of that negative number</strong>.</p>
<p>To illustrate assigning -2 to an unsigned char:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/27258/signedToUnsigned.webp"></p>
<p>Let’s test other types:</p>
<p>Assuming that an <code>int</code> variable is 4 bytes (32 bits) on one platform, it can represent a range from [−2147483648 ($-2^{31}$), 2147483647 ($2^{31}$-1)].</p>
<p>Let’s choose a number: −111.</p>
<p>[Original] 1 0000000000000000000000001101111<br>[One’s complement] 1 1111111111111111111111110010000<br>[Two’s complement] 1 1111111111111111111111110010001  </p>
<p>We will estimate that assigning this to an <code>unsigned int</code> variable yields a value of 4294967185.</p>
<p>Let’s verify with a custom base conversion wheel:</p>
<blockquote>
<p>binary 11111111111111111111111110010001 converts to decimalism is:4294967185</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x = <span class="number">-111</span>;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>Run the result:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/27258/4294967185.webp"></p>
<h3 id="Arrays-Converting-to-Pointers"><a href="#Arrays-Converting-to-Pointers" class="headerlink" title="Arrays Converting to Pointers"></a>Arrays Converting to Pointers</h3><p>In most expressions involving arrays, the array automatically converts to a pointer to the first element of the array.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An array containing 10 int elements</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// ia converts to point to the first element of the array</span></span><br><span class="line"><span class="type">int</span> *ip=ia;</span><br></pre></td></tr></table></figure>

<p>When an array is used as an argument of the <code>decltype</code> keyword, or as operands for operators such as <strong>address-of (&amp;)</strong>, <strong>sizeof</strong>, and <strong>typeid</strong>, the above conversion does not occur.</p>
<p>Similarly, if <strong>an array is initialized with a reference</strong>, the above conversion will not occur.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ia[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// ip points to an array containing 10 int elements</span></span><br><span class="line"><span class="built_in">int</span> (*ip)[<span class="number">10</span>]=&amp;ia;</span><br></pre></td></tr></table></figure>

<h3 id="Pointer-Conversions"><a href="#Pointer-Conversions" class="headerlink" title="Pointer Conversions"></a>Pointer Conversions</h3><p>C++ also specifies several other ways for pointer conversions.</p>
<ol>
<li>Constant integer value 0 or literal <code>nullptr</code> (C++11 feature) can convert to any pointer type.</li>
<li>A pointer to any non-constant can convert to <code>void*</code>.</li>
<li>A pointer to any object can convert to <code>const void*</code>.</li>
<li><strong>Pointer conversion among classes with inheritance:</strong> A pointer or reference to a <strong>derived class object</strong> can be used in places where a <strong>base class reference</strong> is required, and a pointer to a <strong>derived class object</strong> can be used in places where a <strong>base class pointer</strong> is required.</li>
</ol>
<blockquote>
<p>Note: Pointers to functions and pointers to members cannot be implicitly converted to <code>void*</code>, and there is no conversion from pointer types to numeric types.</p>
</blockquote>
<p>Constant expressions that evaluate to 0 can implicitly be converted to any pointer type, including member pointer types. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=(<span class="number">1</span>+<span class="number">2</span>)*(<span class="number">2</span>*(<span class="number">1</span><span class="number">-1</span>)); <span class="comment">// Correct, but curious</span></span><br></pre></td></tr></table></figure>
<p>It’s best to directly use <code>nullptr</code>.</p>
<p><code>T*</code> can implicitly be converted to <code>const T*</code>, and similarly <code>T&amp;</code> can implicitly be converted to <code>const T&amp;</code>.</p>
<h3 id="Pointer-Conversions-Between-Inherited-Classes"><a href="#Pointer-Conversions-Between-Inherited-Classes" class="headerlink" title="Pointer Conversions Between Inherited Classes"></a>Pointer Conversions Between Inherited Classes</h3><p>Pointer conversions between classes with inheritance have another way:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base item; <span class="comment">// Base class object</span></span><br><span class="line">Derived bulk; <span class="comment">// Derived class object</span></span><br><span class="line">Base *p=&amp;item; <span class="comment">// p points to Base object</span></span><br><span class="line">p=&amp;bulk; <span class="comment">// p points to the Base part of bulk</span></span><br><span class="line">Base &amp;r=bulk; <span class="comment">// r binds to the Base part of bulk</span></span><br></pre></td></tr></table></figure>

<p>This conversion is known as <strong>derived to base</strong> type conversion. Like other type conversions, the compiler will implicitly perform the conversion from derived class to base class.<br>A pointer (or reference) to a derived class can implicitly convert to a pointer (or reference) to its accessible and unambiguous base class.</p>
<p>This implicit nature means:</p>
<ul>
<li>You can use <strong>derived class objects</strong> or <strong>references to derived class objects</strong> in places that require base class references.</li>
<li>You can also use <strong>pointers to derived class objects</strong> in places that require base class pointers.</li>
</ul>
<p><strong>Derived class objects contain components corresponding to their base class</strong>, this fact is the key to <strong>inheritance</strong>.</p>
<h3 id="Conversion-of-bool-Types"><a href="#Conversion-of-bool-Types" class="headerlink" title="Conversion of bool Types"></a>Conversion of bool Types</h3><p>Pointers, integers, and floating points can be implicitly converted to bool types. Non-zero values correspond to true, and zero values correspond to false.</p>
<p>When a pointer is implicitly converted to bool, it is false only when it is <code>nullptr</code>/<code>NULL</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span>(p)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;true&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;false&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *ivalp=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ivalp)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;true&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;false&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When converting a non-bool value to a bool value, <strong>only the initial value of 0 results in false</strong>, otherwise it will be true.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true only when test=0; true when test_bool&gt;0 or test_bool&lt;0</span></span><br><span class="line"><span class="type">bool</span> test_bool = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">if</span>(test_bool)&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;True!&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;False&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Assigning a bool type value to a non-bool type will result in 0 if the initial value is false, and 1 if the initial value is true.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> boolToInt_1=<span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> boolToInt_2=<span class="literal">false</span>;</span><br><span class="line"><span class="comment">// Output: 1    0</span></span><br><span class="line">cout&lt;&lt;boolToInt_1&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;boolToInt_2&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h3 id="Conversion-of-Enum-Types"><a href="#Conversion-of-Enum-Types" class="headerlink" title="Conversion of Enum Types"></a>Conversion of Enum Types</h3><p>C++ automatically converts enum members (enumerator) to integers, and the conversion result can be used wherever an integer value is required.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// point2d is 2, point2w is 3, point3d is 3, point3w is 4</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Points</span>&#123;point2d=<span class="number">2</span>, point2w, point3d=<span class="number">3</span>, point3w&#125;;</span><br><span class="line"><span class="comment">// Can also use auto (C++11) to infer the smallest type that can hold point3d</span></span><br><span class="line"><span class="type">int</span> array3d=point3d;</span><br><span class="line">cout&lt;&lt;array3d&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>Note the following points:</p>
<ul>
<li>The type to which an enum object or enum member is promoted is machine-defined (depends on whether the machine type can accommodate it) and depends on the maximum value of the enum member.</li>
<li>Enum objects or members are at least promoted to int.</li>
<li>If the int type cannot represent the maximum value of the enum member (using auto to infer the type that can hold the enum member), it is promoted to the smallest type that can represent all enum member values and is larger than int (unsigned int, long, unsigned long, long long, unsigned long long).</li>
</ul>
<h3 id="Conversion-to-Constant-const-Objects"><a href="#Conversion-to-Constant-const-Objects" class="headerlink" title="Conversion to Constant (const) Objects"></a>Conversion to Constant (const) Objects</h3><ul>
<li><p>When a non-const object is used to initialize a <strong>const reference</strong>, the system will convert the non-const object to a const object.</p>
</li>
<li><p>You can also convert a pointer to a non-const object (or non-const pointer) to a pointer to a const object.</p>
</li>
<li><p>It is not allowed to convert a const object to a non-const object.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;x=i;</span><br><span class="line"><span class="comment">// Output 10</span></span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line"><span class="comment">// i can be modified, but x cannot be modified</span></span><br><span class="line">i=<span class="number">12</span>;</span><br><span class="line"><span class="comment">// Output 12</span></span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>A non-const pointer becomes a const pointer:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">cout&lt;&lt;&amp;i&lt;&lt;endl;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *x=&amp;i;</span><br><span class="line"><span class="comment">// i can be modified, but the value pointed to by x cannot be modified</span></span><br><span class="line">i=<span class="number">12</span>;</span><br><span class="line"><span class="comment">// *x=13  This is incorrect</span></span><br><span class="line"><span class="comment">//error: read-only variable is not assignable</span></span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot; is &quot;</span>&lt;&lt;*x&lt;&lt;endl;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *z=x;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;z&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/27258/!const2const-Point-address.webp"></p>
<p>If T is a type, we can convert a pointer or reference to T into a pointer or reference to const T.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">// Convert a non-const to a const int reference</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;j=i;</span><br><span class="line"><span class="comment">// The address of the const object becomes the const pointer</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p=&amp;i;</span><br><span class="line"><span class="comment">// Error: Converting const to non-const is not allowed</span></span><br><span class="line"><span class="type">int</span> &amp;r=j,*p=p;</span><br><span class="line"><span class="comment">// error: binding value of type &#x27;const int&#x27; to reference to type &#x27;int&#x27; drops &#x27;const&#x27; qualifier</span></span><br><span class="line"><span class="comment">// error: cannot initialize a variable of type &#x27;int *&#x27; with an lvalue of type &#x27;const int *&#x27;</span></span><br></pre></td></tr></table></figure>

<p>The reverse conversion does not exist, as it attempts to remove the underlying const.</p>
<h2 id="Explicit-Type-Conversion"><a href="#Explicit-Type-Conversion" class="headerlink" title="Explicit Type Conversion"></a>Explicit Type Conversion</h2><p>Sometimes we wish to explicitly convert an object to another type (for example, if the result of dividing two integers should also be of integer type, discarding the precision after the decimal point, which sometimes is not the desired result), we need to use <strong>explicit type conversion</strong>. C++’s explicit type conversion operations specify several different capabilities of conversion operations for stronger controls over conversion privileges. Although all four of these conversion operations can be accomplished using C-style conversion, it is safer to use explicit type conversion.</p>
<h3 id="C-Style-Explicit-Type-Conversion"><a href="#C-Style-Explicit-Type-Conversion" class="headerlink" title="C-Style Explicit Type Conversion"></a>C-Style Explicit Type Conversion</h3><blockquote>
<p>In C, the <strong>casting operator (type)</strong> is used to force conversion of types when needed.</p>
</blockquote>
<p>Refer to the following code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">12</span>,y=<span class="number">5</span>;</span><br><span class="line"><span class="type">float</span> z=(<span class="type">float</span>)x/y;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>,z);</span><br></pre></td></tr></table></figure>

<p>If we do not use the casting operator, the output of z would be 2.000000; by using the casting operator, x is first converted to float type, and then division is performed. Since the implicit type conversion of different types within the same expression goes from lower precision to higher precision, y will also be implicitly converted to float, resulting in: 2.400000.</p>
<blockquote>
<p>Earlier versions of C++ also supported the <code>type(expression)</code> method for type conversion.</p>
</blockquote>
<h3 id="Explicit-Type-Conversion-in-C"><a href="#Explicit-Type-Conversion-in-C" class="headerlink" title="Explicit Type Conversion in C++"></a>Explicit Type Conversion in C++</h3><p>C++ does support C-style explicit type conversions (casting operator), but there are better alternatives in C++. C++ offers several different ways to perform explicit type conversions.</p>
<p>A named cast has the following form:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure>

<p>Where <strong>cast-name</strong> determines the type of conversion being executed, <strong>type</strong> is the target type, and <strong>expression</strong> is the value to be converted.</p>
<ul>
<li><p>If type is a reference type, the result is an <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%80%BC_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">lvalue</a>.</p>
</li>
<li><p>Cast-name can be one of <code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, or <code>reinterpret_cast</code>.</p>
</li>
</ul>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>The role of <code>static_cast</code> is to reverse a well-defined implicit type conversion.</p>
<p>Any type conversion with a clear definition that does not involve <strong>underlying const</strong> (indicating that the object pointed to by the pointer is a constant) can use <code>static_cast</code>.</p>
<p>Note: <code>static_cast</code> cannot handle pointer conversions, as pointer conversions are bit-pattern conversions and should use <code>reinterpret_cast</code> (to disguise as another type of pointer):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> x=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> *p1=&amp;x; <span class="comment">// Error, no implicit conversion from char* to int*</span></span><br><span class="line"><span class="type">int</span> *p2=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x);  <span class="comment">// Error, no implicit conversion from char* to int*</span></span><br><span class="line"><span class="type">int</span> *p3=<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x); <span class="comment">// OK, at your own risk</span></span><br></pre></td></tr></table></figure>

<p>Where it applies:</p>
<ol>
<li><strong>Floating point precision loss (double -&gt; float)</strong> and <strong>assigning a larger arithmetic type to a smaller arithmetic type (int -&gt; char)</strong>, using <strong>static_cast</strong> signifies that we understand and do not care about these risks. :)</li>
<li>Type conversions that the compiler cannot automatically carry out *<em>(void</em> -&gt; otherType)**.</li>
<li>When the compiler detects that a larger data type is trying to be assigned to a smaller data type, it will raise a warning; using explicit type conversion will suppress the warning.</li>
</ol>
<p>Refer to the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">12</span>,y=<span class="number">5</span>;</span><br><span class="line"><span class="comment">// Use static_cast to forcibly convert int x to double before computing </span></span><br><span class="line"><span class="type">float</span> z=<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(x)/y;</span><br><span class="line"><span class="comment">// Output result 2.4</span></span><br><span class="line">cout&lt;&lt;z&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dPI=<span class="number">3.14159</span>;</span><br><span class="line"><span class="comment">// iPI is 3.</span></span><br><span class="line"><span class="type">int</span> iPI=<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(dPI);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">65</span>;</span><br><span class="line"><span class="type">char</span> capital_a=<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(x);</span><br></pre></td></tr></table></figure>

<p>Using <code>static_cast</code> to retrieve an existing *<em>void**</em> pointer:</p>
<blockquote>
<p><code>void*</code> is a special pointer type that can store the address of any non-constant object.</p>
<p>However, the operations that <code>void</code> can perform are very limited: <strong>comparing it with other pointers, using it as an input or output to functions, and assigning it to another <code>void*</code> object</strong>. We cannot directly manipulate a <code>void*</code> pointer because we do not know what type this object is and what operations can be performed on it.</p>
</blockquote>
<p>Therefore, when we have a <code>void*</code> whose object type is known, but we are still unable to operate on that <code>void</code> type, the current approach is to use <code>static_cast</code> to convert <code>void*</code> back to the known pointer type the <code>void*</code> points to.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval=<span class="number">3.1415926</span>;</span><br><span class="line"><span class="comment">// Assuming we have a void* and vpoint could be a function return value or another pointer type that is not directly visible</span></span><br><span class="line"><span class="type">void</span> *vpoint=&amp;dval;</span><br><span class="line"><span class="comment">// We can use static_cast to convert void* to double*</span></span><br><span class="line"><span class="type">double</span> *p=<span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(vpoint);</span><br></pre></td></tr></table></figure>

<p>When we store a pointer in <code>void*</code> and use <code>static_cast</code> to forcefully convert it back to its original type, we must ensure that the pointer’s value remains unchanged. In other words, the result of the cast must equal the original address value.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output the address of dval and the address of the pointer after forcibly converting void* back to double*</span></span><br><span class="line">cout&lt;&lt;&amp;dval&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;p&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/27258/C:/Users/visionsmile/Desktop/doubleVal2voidPoint2doublePoint.webp"></p>
<p>Both addresses output the same.</p>
<p>Thus, we must ensure that the resulting type matches the type of the pointer being pointed to. If the types do not match, it will result in an undefined error (not knowing what kind of result will occur).</p>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>The role of <code>const_cast</code> is to grant write access to certain objects declared as const.</p>
<p><code>const_cast</code> can only change the <strong>underlying const</strong> (the object pointed to by the pointer is a constant), which means <strong>making the object pointed to by a constant pointer modifiable</strong>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *pchar;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pchar);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The act of converting a constant object into a non-constant is termed “removing the const nature (cast away the const)”. Once a const nature is removed from an object, the compiler does not prevent operations that modify this object.</p>
</blockquote>
<p><strong>If the object itself is not a constant, it is legal to use a cast to obtain write permission. If the object is a constant, attempting to perform write operations using <code>const_cast</code> would result in undefined behavior.</strong></p>
<p>The underlying const object itself is a variable:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pchar=&amp;a;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pchar);</span><br><span class="line"><span class="comment">// Modify the object pointed to by p (i.e., the char object a) to b</span></span><br><span class="line">*p=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="comment">// Output b</span></span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>The underlying const object itself is a constant:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *a=<span class="string">&quot;HelloWorld&quot;</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pchar=a;</span><br><span class="line"><span class="type">char</span> *p=<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pchar);</span><br><span class="line"><span class="comment">// Compilation passes, but results in undefined behavior</span></span><br><span class="line">*p=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p><code>const_cast</code> is particularly useful in <strong>overloaded functions</strong>.</p>
<p>When our function accepts a const reference of an object and returns a reference to the modified object, since the parameter is declared as const, the return value will also have const properties, which obviously isn’t always the result we want.</p>
<p>Assuming we need a function that compares and returns the longer of two strings, we may have the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The function&#x27;s parameter and return value are both const string</span></span><br><span class="line"><span class="function"><span class="type">const</span> string&amp; <span class="title">longString</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> s1.<span class="built_in">size</span>()&gt;s2.<span class="built_in">size</span>()?s1:s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>When we call longString with two non-const string arguments, the return value will still be a const reference to string. So we need a new longString function, and when its arguments are not constants, we wish for the result to be a regular reference, using <code>const_cast</code> can achieve this.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Overloaded longString function, which calls this version when parameters are non-const, returning a non-const object</span></span><br><span class="line"><span class="function">string &amp;<span class="title">longString</span><span class="params">(string &amp;s1,string &amp;s2)</span></span>&#123;</span><br><span class="line">  <span class="comment">// Call the version that accepts two const parameters and returns a const object</span></span><br><span class="line">  <span class="comment">// r&#x27;s type is const string&amp;</span></span><br><span class="line">  <span class="keyword">auto</span> &amp;r=<span class="built_in">longString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">  <span class="comment">// Use const_cast to convert r from const string&amp; to string&amp;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">const_case</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p><code>reinterpret_cast</code> usually provides a lower-level reinterpretation of the bit patterns of the operands (a function for changing bit patterns).</p>
<p>The following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ipoint;</span><br><span class="line"><span class="type">char</span> *cpoint=<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(ipoint);</span><br></pre></td></tr></table></figure>

<p>We must keep in mind that <code>cpoint</code> points to an <code>int</code>, not a <code>char</code>; using <code>cpoint</code> as a regular char pointer can lead to run-time errors.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This doesn&#x27;t report an error, but may lead to various problems during execution.</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(cpoint)</span></span>;</span><br></pre></td></tr></table></figure>

<p>If we initialize the string object with <code>ipoint</code> without using <code>reinterpret_cast</code>, it will throw an error:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ipoint;</span><br><span class="line"><span class="comment">// char *cpoint=reinterpret_cast&lt;char*&gt;(ipoint);</span></span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(ipoint)</span></span>;</span><br><span class="line"><span class="comment">// Compilation error: error: no matching constructor for initialization of &#x27;string&#x27; (aka &#x27;basic_string&lt;char&gt;&#x27;)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Using <code>reinterpret_cast</code> is very dangerous.</strong> As shown in the examples, the problem is that the type is changed, but the compiler doesn’t warn or report errors. Since explicitly stating this action is legal, the compiler will not issue any warnings or errors. After using <code>reinterpret_cast&lt;char*&gt;(ipoint);</code>, when we use <code>cpoint</code>, it will consider it a <code>char*</code> type, and the compiler cannot know that it actually stores a pointer to <code>int</code>.</p>
</blockquote>
<p>You can also manually specify an address to convert to a specified type pointer:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=<span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="number">0xff00</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Note: The compiler cannot determine whether the integer <code>0xff00</code> is a valid int type address; hence the correctness of this statement depends entirely on the programmer.</strong></p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p><code>dynamic_cast</code>: Checks class hierarchy dynamically.<br><strong>The role of <code>dynamic_cast</code> is to</strong>: Safely convert a <strong>base class</strong> pointer or reference to a <strong>derived class (inherited class)</strong> pointer or reference.</p>
<p>The usage format for <code>dynamic_cast</code> is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e must be a valid pointer</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e);</span><br><span class="line"><span class="comment">// e must be an lvalue</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e);</span><br><span class="line"><span class="comment">// e cannot be an lvalue</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e);</span><br></pre></td></tr></table></figure>

<p>Where <code>type</code> must be a class type, and <strong>typically</strong> that type has <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9A%E5%87%BD%E6%95%B0_(%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80)">virtual functions</a>.</p>
<p>In the three forms of <code>dynamic_cast</code>, the type of e must meet at least one of the following three conditions:</p>
<ul>
<li>The type of e is a <strong>public derived class</strong> of the target type.</li>
<li>The type of e is a <strong>public base class</strong> of the target type.</li>
<li>The type of e is <strong>the type of the target type</strong>.</li>
</ul>
<p>If any of these conditions are met, the conversion succeeds; otherwise, it fails.</p>
<p>If the <strong>dynamic_cast</strong> conversion target is of <strong>pointer type</strong> and fails, the result is 0.</p>
<p>If the <strong>dynamic_cast</strong> conversion target is of <strong>reference type</strong> and fails, the <strong>dynamic_cast</strong> operator will throw a <strong>bad_cast exception</strong>.</p>
<h5 id="Pointer-Type-dynamic-cast"><a href="#Pointer-Type-dynamic-cast" class="headerlink" title="Pointer Type dynamic_cast"></a>Pointer Type dynamic_cast</h5><p>Assuming the Base class has at least one <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%99%9A%E5%87%BD%E6%95%B0_(%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80)">virtual function</a>, and Derived is a public derived type of Base, if we have a pointer to Base <code>bp</code>, then we can convert it to a pointer to Derived at runtime.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check if the conversion is successful; pointer bp cannot be accessed outside of the if</span></span><br><span class="line"><span class="comment">// The dynamic_cast operation in the condition part ensures that the type conversion and result check occur in the same expression</span></span><br><span class="line"><span class="keyword">if</span>(Derived *dp = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(bp))&#123;</span><br><span class="line">  <span class="comment">// Use the Derived object pointed to by dp</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// bp points to a Base object</span></span><br><span class="line">  <span class="comment">// Use dp to reference the Base object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If <code>bp</code> points to a Derived object, the type conversion initializes <code>dp</code> and points it to the Derived object pointed to by <code>bp</code>. At this point, using <code>dp</code> safely refers to Derived operations. Otherwise, the type conversion results in 0, meaning the condition of the if statement fails, and the else clause executes the relevant Base operations.</p>
<blockquote>
<p>You can execute dynamic_cast on a null pointer, which will yield a null pointer of the desired type.</p>
</blockquote>
<h5 id="Reference-Type-dynamic-cast"><a href="#Reference-Type-dynamic-cast" class="headerlink" title="Reference Type dynamic_cast"></a>Reference Type dynamic_cast</h5><p>The reference type <code>dynamic_cast</code> differs from the pointer type <code>dynamic_cast</code> in terms of error reporting.</p>
<p>Because <strong>there is no null reference</strong>, it cannot use the same error reporting strategy as pointer types. When the type conversion fails for reference types, the program throws an exception named <code>std::bad_cast</code>, which is defined in the <code>typeinfo</code> standard header.</p>
<p>Rewrite the program above to use reference types:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Base &amp;b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">  		<span class="type">const</span> Derived &amp;d=<span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(b);</span><br><span class="line">      	<span class="comment">// Use the Derived object referenced by b</span></span><br><span class="line">  	&#125; <span class="built_in">catch</span> (bad_cast) &#123;</span><br><span class="line">      	<span class="comment">// Handle the type conversion failure</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
        
        
          
            <blockquote class="blockquote-center">
              
                The article is finished. If you have any questions, please comment and communicate.
              
            <br/>
            
                <div class="qr-code" onclick="return false">
                    <script src="/js/qrcode.min.js"></script>
                    <div id="qrcode">
                      
                        <img src="https://imzlp.com/images/wechat-qrcode.webp">
                      
                    <p>Scan the QR code on WeChat and follow me.</p>
                    </div>
                </div>
            
            </blockquote>
          
        

        
          <div class="postCopyright" style="clear:both;">
             <span>Title:</span><a href="/posts/27258/" target="_blank">Detailed analysis of type conversion in C++</a><br/>
             <span>Author:</span><a href="/about" target="_blank" title="查看 LIPENGZHA 的资料">LIPENGZHA</a><br/>
             <span>Publish Date:</span>2016/05/04 19:35<br/>
             
             <span>Word Count:</span><span class="page-count">17k Words</span><br/>
             
             <span>Link:</span><a href="/posts/27258/" target="_blank" title="Detailed analysis of type conversion in C++">https://en.imzlp.com/posts/27258/</a>
             <span class="copy-path" data-clipboard-text="Link: https://en.imzlp.com/posts/27258/ Author: LIPENGZHA" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
             <script src="/js/jquery.min.js"></script>
             <script src="/js/clipboard.min.js"></script>
             <script> var clipboard = new Clipboard('.copy-path'); </script>
             <br/>
             
             <span>License:</span><i class="fab fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">CC BY-NC-SA 4.0</a><br/>
             
             <span>Reprinting of the full article is prohibited.</span>
          </div>
        
    

        
  <div class="reward-container">
    <div>Your donation will encourage me to keep creating!</div>
    <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
      Donate
    </button>
    <div id="qr" style="display: none;">
        
        <div style="display: inline-block;">
          <img src="/images/reward/wechatpay.webp" alt="LIPENGZHA WeChat Pay">
          <p>WeChat Pay</p>
        </div>

    </div>
  </div>



      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" rel="tag"># 技术笔记</a>
              <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag"># 读书笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/34573/" rel="prev" title="Use Gprof to analyze code performance bottlenecks">
      <i class="fa fa-chevron-left"></i> Use Gprof to analyze code performance bottlenecks
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/34569/" rel="next" title="Summary of some object-oriented knowledge in C++">
      Summary of some object-oriented knowledge in C++ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-utteranc">utteranc</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane utteranc" id="comment-utteranc">
              
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="hxhb/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Implicit-Type-Conversion"><span class="nav-number">1.</span> <span class="nav-text">Implicit Type Conversion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Integer-Promotion"><span class="nav-number">1.1.</span> <span class="nav-text">Integer Promotion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conversion-of-Floating-Point-Types"><span class="nav-number">1.2.</span> <span class="nav-text">Conversion of Floating Point Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conversion-Between-Unsigned-Types"><span class="nav-number">1.3.</span> <span class="nav-text">Conversion Between Unsigned Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays-Converting-to-Pointers"><span class="nav-number">1.4.</span> <span class="nav-text">Arrays Converting to Pointers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pointer-Conversions"><span class="nav-number">1.5.</span> <span class="nav-text">Pointer Conversions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pointer-Conversions-Between-Inherited-Classes"><span class="nav-number">1.6.</span> <span class="nav-text">Pointer Conversions Between Inherited Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conversion-of-bool-Types"><span class="nav-number">1.7.</span> <span class="nav-text">Conversion of bool Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conversion-of-Enum-Types"><span class="nav-number">1.8.</span> <span class="nav-text">Conversion of Enum Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conversion-to-Constant-const-Objects"><span class="nav-number">1.9.</span> <span class="nav-text">Conversion to Constant (const) Objects</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Explicit-Type-Conversion"><span class="nav-number">2.</span> <span class="nav-text">Explicit Type Conversion</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-Style-Explicit-Type-Conversion"><span class="nav-number">2.1.</span> <span class="nav-text">C-Style Explicit Type Conversion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Explicit-Type-Conversion-in-C"><span class="nav-number">2.2.</span> <span class="nav-text">Explicit Type Conversion in C++</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static-cast"><span class="nav-number">2.2.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-cast"><span class="nav-number">2.2.2.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reinterpret-cast"><span class="nav-number">2.2.3.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic-cast"><span class="nav-number">2.2.4.</span> <span class="nav-text">dynamic_cast</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Pointer-Type-dynamic-cast"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">Pointer Type dynamic_cast</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Reference-Type-dynamic-cast"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">Reference Type dynamic_cast</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person" oncontextmenu="return false" οndragstart="return false">
    <img class="site-author-image" itemprop="image" alt="LIPENGZHA"
      src="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
  <p class="site-author-name" itemprop="name">LIPENGZHA</p>
  <div class="site-description" itemprop="description">"I think, therefore I am"</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
             
          <span class="site-state-item-count">190</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">95</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">190</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxhb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxhb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/lipengzha" title="Linkedin → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;lipengzha" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/imzlp" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;imzlp" rel="noopener" target="_blank"><i class="fa fa-custom zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat-qrcode-offical.webp" title="微信公众号 → &#x2F;images&#x2F;wechat-qrcode-offical.webp"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imzlp@foxmail.com" title="E-Mail → mailto:imzlp@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://consolehelp.imzlp.com/" title="https:&#x2F;&#x2F;consolehelp.imzlp.com&#x2F;" rel="noopener" target="_blank">UE Console Help</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/opensource/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;opensource&#x2F;" rel="noopener" target="_blank">Open Source Projects</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/posts/11515/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;posts&#x2F;11515&#x2F;" rel="noopener" target="_blank">UE C++ API Dash Documents</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ue5wiki.com/" title="https:&#x2F;&#x2F;ue5wiki.com&#x2F;" rel="noopener" target="_blank">Unreal Engine Wiki</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LIPENGZHA</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.5m</span>
</div>
  <div class="powered-by-other">
    
	    <center>Github Pages | Actions | NeXT | Cloudflare | Hexo Deploy</center>
      
  </div>

<script>
function checkWebp(callback) {
    var img = new Image();
    img.onload = function () { callback((img.width > 0) && (img.height > 0)); };
    img.onerror = function () { callback(false); };
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
}
function showImage(useWebp) {
    var imgs = [].slice.call(document.querySelectorAll('img'));
    imgs.forEach(function (e) {
        if (!useWebp) {
            var src = e.getAttribute('data-src')
            src = src.replace(/\.webp$/, '.png');
            e.setAttribute('data-src', src);
        }
    });
}
checkWebp(showImage);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animejs/3.2.1/anime.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.5.1/jquery.min.js"></script>
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



<script src="/js/code-unfold.js"></script>

  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  
  <script src="//img.imzlp.com/imgs/zlp/picgo/2021/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://en.imzlp.com/posts/27258/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    var requiredFields = 'nick';
    requiredFields = requiredFields.split(',');
    
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oCE6RMVkVoi5MgUhvFsn1EvV-gzGzoHsz',
      appKey     : 'K9SOaNYJ8PV6xaoFggWG5xvv',
      placeholder: "Leave something behind~",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields: requiredFields
    });
  }, window.Valine);
});
</script>

</body>
</html>
