<!DOCTYPE html>
<html lang="en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-tilt-brush.png">
  <link rel="mask-icon" href="/images/favicon-32x32-tilt-brush.png" color="#222">
  <meta name="google-site-verification" content="ttIkhAIFZQM9Huj8roB0l95ePN2Tv2zv2wRFksi09WA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Pacifico:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"en.imzlp.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"width":280},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"code_unfold":{"enable":true,"CODE_MAX_HEIGHT":600},"path":"search.xml"};
  </script>

  <meta name="description" content="There are countless resources on C&#x2F;C++ available online, but I often find that, after reading some articles, it seems the authors themselves don’t fully understand what they wrote (looking back at my">
<meta property="og:type" content="article">
<meta property="og:title" content="Some excerpts from the C&#x2F;C++ standard">
<meta property="og:url" content="https://en.imzlp.com/posts/19242/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="There are countless resources on C&#x2F;C++ available online, but I often find that, after reading some articles, it seems the authors themselves don’t fully understand what they wrote (looking back at my">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/19242/lvalueAndRvalue.webp">
<meta property="article:published_time" content="2016-11-12T01:19:51.000Z">
<meta property="article:modified_time" content="2017-04-05T15:19:57.000Z">
<meta property="article:author" content="LIPENGZHA">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="标准解读">
<meta property="article:tag" content="C++标准">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/19242/lvalueAndRvalue.webp">

<link rel="canonical" href="https://en.imzlp.com/posts/19242/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Some excerpts from the C/C++ standard | Z's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDCJ41EFP5"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FDCJ41EFP5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Z's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-edit fa-fw"></i>Notes</a>

  </li>


      
        
            
  <li class="menu-item menu-item-essay">

    <a href="/essay/" rel="section"><i class="fas fa-feather-alt fa-fw"></i>Essay</a>

  </li>


      
        
            
  <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-inbox fa-fw"></i>Resources</a>

  </li>


      
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fas fa-link fa-fw"></i>Friends</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me</a>

  </li>


      
        <li class="menu-item menu-item-showcase">

    <a href="/showcase/" rel="section"><i class="fa fa-solid fa-trophy fa-fw"></i>ShowCase</a>

  </li>
        <li class="menu-item menu-item-changelog">

    <a href="/changelog/" rel="section"><i class="fa fa-history fa-fw"></i>Site Log</a>

  </li>
        <li class="menu-item menu-item-opensource">

    <a href="/opensource/" rel="section"><i class="fas fa-code-branch fa-fw"></i>Open Source</a>

  </li>
        <li class="menu-item menu-item-uewiki">

    <a href="https://ue5wiki.com/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>Unreal Wiki</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>



<script type="text/javascript">
  let domain='en.imzlp.com';
  let domain_str = atob(domain);
  let pathname = location.pathname;
  if (domain_str!= location.host.toLowerCase()){
        console.log(`this host is not safe,jump to https://${domain_str}${pathname}`);
        location.href=`https://${domain_str}${pathname}`;
  }
</script>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <div class="l10n-header-widget">
    <script>
      // 获取当前页面的 URL
      const currentUrl = window.location.href;
      // 替换 URL 中的部分内容
      const jumpToL10nLink = currentUrl.replace('en.imzlp.com', 'imzlp.com');
      // 将 jumpToL10nLink 绑定到一个全局变量
      window.jumpToL10nLink = jumpToL10nLink;
    </script>

    <a href="#" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: none;" rel="noopener" target="_blank" onclick="window.open(window.jumpToL10nLink, '_blank'); return false;">
      <i class="fa fa-solid fa-language"></i>
    </a>
  </div>



    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en"
  >
    <link itemprop="mainEntityOfPage" href="https://en.imzlp.com/posts/19242/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
      <meta itemprop="name" content="LIPENGZHA">
      <meta itemprop="description" content=""I think, therefore I am"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Some excerpts from the C/C++ standard<a href="https://github.com/imzlp/blog-md/blob/en/_posts/2016-11-12-19242.md" class="post-edit-link" title="Edit this post" style="float: right;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a><a href="https://imzlp.com/posts/19242/" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-solid fa-language"></i></a>
        </h1>

        
          <div class="post-subtitle" style="text-align: center;line-height: 1;">
            <sub text-align="center" style="font-size: 15px;align-content: center;font-style: italic;bottom: 0em;">C/C++标准的一些摘录</sub>
          </div>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-11-12 01:19 01:19:51:19" itemprop="dateCreated datePublished" datetime="2016-11-12T01:19:51+00:00">2016-11-12 01:19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2017-04-05 15:19 15:19:57:19" itemprop="dateModified" datetime="2017-04-05T15:19:57+00:00">2017-04-05 15:19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">标准解读</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/C-%E6%A0%87%E5%87%86/" itemprop="url" rel="index"><span itemprop="name">C++标准</span></a>
                </span>
            </span>

          
            <span id="/posts/19242/" class="post-meta-item leancloud_visitors" data-flag-title="Some excerpts from the C/C++ standard" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>49k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2:02</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>There are countless resources on C/C++ available online, but I often find that, after reading some articles, it seems the authors themselves don’t fully understand what they wrote (looking back at my own earlier articles, my perspective was too one-sided and superficial at that time). Therefore, for C/C++ materials, I believe it’s essential to refer directly to the standard documentation, as standards do not introduce ambiguities. One should not blindly search the internet and trust second-hand digested materials.</p>
<p>I think consulting these four documents is enough for understanding the features of the C/C++ languages (click to preview online or download):</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://doc.imzlp.com/viewer.html?file=docs/standard/isoc99.pdf">ISO/IEC 9899:1999 (E)</a> (C99 standard)</li>
<li><a target="_blank" rel="noopener" href="http://doc.imzlp.com/viewer.html?file=docs/clang/TCPL2E.pdf">The C Programming Language Second Edition</a> (The major work of C language creators Dennis Ritchie and Brian Kernighan)</li>
<li><a target="_blank" rel="noopener" href="http://doc.imzlp.com/viewer.html?file=docs/standard/isocpp2014.pdf">ISO/IEC 14882:2014(E)</a> (C++14 standard)</li>
<li><a target="_blank" rel="noopener" href="http://doc.imzlp.com/viewer.html?file=docs/cpp/TCPPPL4E.pdf">The C++ Programming Language Fourth Edition</a> (Written by the father of C++, based on the C++11 standard)</li>
</ul>
<p>The reason the C language standard does not follow the latest C11 standard is that the current C++ standard (C++14) references <strong>ISO/IEC 9899:1999</strong> in its <code>Normative references</code>, which means TCPL and TC++PL can serve as applicable descriptions for the C/C++ standards and can corroborate each other.</p>
<p>For more about C++ <code>Normative references</code>, refer to <a target="_blank" rel="noopener" href="https://o66j3dueo.qnssl.com/Document/ISOIEC.14882.2014%28C++14%29.pdf">ISO/IEC 14882:2014(E)</a> §1.2 Normative references.</p>
<p>I will gradually extract some commonly ambiguous language features from the standard norms here to ensure that what I write is backed by the standard documentation.</p>
<span id="more"></span>

<h2 id="exit-behavior"><a href="#exit-behavior" class="headerlink" title="exit() behavior"></a>exit() behavior</h2><p>function prototype:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The attribute-token noreturn specifies that a function does not return.</span></span><br><span class="line">[[noreturn]] <span class="function"><span class="type">void</span> <span class="title">exit</span><span class="params">(<span class="type">int</span> status)</span></span></span><br></pre></td></tr></table></figure>
<p>The function exit() has additional behavior in this International Standard:</p>
<ul>
<li>First, objects with thread storage duration and associated with the current thread are destroyed. Next, objects with static storage duration are destroyed and functions registered by calling atexit are called. See 3.6.3 for the order of destructions and calls. (Automatic objects are not destroyed as a result of calling exit().)<br>If control leaves a registered function called by exit because the function does not provide a handler for a thrown exception, std::terminate() shall be called (15.5.1).</li>
<li>Next, all open C streams (as mediated by the function signatures declared in <cstdio>) with unwritten buffered data are flushed, all open C streams are closed, and all files created by calling tmpfile() are removed.</li>
<li>Finally, control is returned to the host environment. If status is zero or EXIT_SUCCESS, an implementation-defined form of the status successful termination is returned. If status is EXIT_FAILURE, an implementation-defined form of the status unsuccessful termination is returned. Otherwise, the status returned is implementation-defined.</li>
</ul>
<h2 id="return-statement"><a href="#return-statement" class="headerlink" title="return statement"></a>return statement</h2><p>A function returns to its caller by the return statement.<br>A return statement with neither an expression nor a braced-init-list can be used only in functions that do not return a value, that is, a function with the return type cv void, a constructor (12.1), or a destructor (12.4).<br>A return statement with an expression of non-void type can be used only in functions returning a value; the value of the expression is returned to the caller of the function. The value of the expression is implicitly converted to the return type of the function in which it appears. A return statement can involve the construction and copy or move of a temporary object (12.2). [ Note: A copy or move operation associated with a return statement may be elided or considered as an rvalue for the purpose of overload resolution in selecting a constructor (12.8). — end note ] A return statement with a braced-init-list initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;std::string,<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;p,x&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A return statement with an expression of type void can be used only in functions with a return type of cv void; the expression is evaluated just before the function returns to its caller.</p>
<p>Flowing off the end of a function is equivalent to a return with no value; this results in undefined behavior in a value-returning function. (Note: the main function does not adhere to this rule.)<br>Since the return value of the main function is used as the argument to std::exit, the standard explicitly states that not returning explicitly at the end of the main function is equivalent to <code>return 0</code>; A return statement in main has the effect of leaving the main function (destroying any objects with automatic storage duration) and calling std::exit with the return value as the argument. If control reaches the end of main without encountering a return statement, the effect is that of executing</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>For a more detailed discussion on the prototype and return value of the main function, see: <a target="_blank" rel="noopener" href="https://github.com/FrankHB/pl-docs/blob/master/zh-CN/main-function.md">关于main函数的原型和返回值</a></p>
<h2 id="non-deduced-context"><a href="#non-deduced-context" class="headerlink" title="non-deduced context"></a>non-deduced context</h2><p>The non-deduced contexts are:</p>
<ul>
<li>The nested-name-specifier of a type that was specified using a qualified-id.</li>
<li>The expression of a decltype-specifier.</li>
<li>A non-type template argument or an array bound in which a subexpression references a template parameter.</li>
<li>A template parameter used in the parameter type of a function parameter that has a default argument that is being used in the call for which argument deduction is being done.</li>
<li>A function parameter for which argument deduction cannot be done because the associated function argument is a function, or a set of overloaded functions (13.4), and one or more of the following apply:<ul>
<li>more than one function matches the function parameter type (resulting in an ambiguous deduction), or</li>
<li>no function matches the function parameter type, or</li>
<li>the set of functions supplied as an argument contains one or more function templates.</li>
</ul>
</li>
<li>A function parameter for which the associated argument is an initializer list (8.5.4) but the parameter does not have std::initializer_list or reference to possibly cv-qualified std::initializer_list type.<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">g</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="built_in">g</span>(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;); <span class="comment">// error: no argument deduced for T</span></span><br></pre></td></tr></table></figure></li>
<li>A function parameter pack that does not occur at the end of the parameter-declaration-list.</li>
</ul>
<h2 id="异常抛出时的构造和析构"><a href="#异常抛出时的构造和析构" class="headerlink" title="异常抛出时的构造和析构"></a>异常抛出时的构造和析构</h2><p>An object of any storage duration whose initialization or destruction is terminated by an exception will have destructors executed for all of its fully constructed subobjects (excluding the variant members of a union-like class), that is, for subobjects for which the principal constructor (12.6.2) has completed execution and the destructor has not yet begun execution.</p>
<h2 id="对象析构时的执行顺序"><a href="#对象析构时的执行顺序" class="headerlink" title="对象析构时的执行顺序"></a>对象析构时的执行顺序</h2><blockquote>
<p>After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class X calls the destructors for X’s direct non-variant non-static data members, the destructors for X’s direct base classes and, if X is the type of the most derived class (12.6.2), its destructor calls the destructors for X’s virtual base classes. All destructors are called as if they were referenced with a qualified name, that is, ignoring any possible virtual overriding destructors in more derived classes. Bases and members are destroyed in the reverse order of the completion of their constructor (see 12.6.2). A return statement (6.6.3) in a destructor might not directly return to the caller; before transferring control to the caller, the destructors for the members and bases are called. Destructors for elements of an array are called in reverse order of their construction (see 12.6).</p>
</blockquote>
<h2 id="对象构造时的执行顺序"><a href="#对象构造时的执行顺序" class="headerlink" title="对象构造时的执行顺序"></a>对象构造时的执行顺序</h2><p>In a non-delegating constructor, initialization proceeds in the following order:</p>
<ul>
<li>First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where “left-to-right” is the order of appearance of the base classes in the derived class base-specifier-list.</li>
<li>Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers).</li>
<li>Then, non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers).</li>
<li>Finally, the compound-statement of the constructor body is executed.</li>
</ul>
<p>[ Note: The declaration order is mandated to ensure that base and member subobjects are destroyed in the reverse order of initialization. - end note ]</p>
<h2 id="类的内置类型数据成员初始化"><a href="#类的内置类型数据成员初始化" class="headerlink" title="类的内置类型数据成员初始化"></a>类的内置类型数据成员初始化</h2><p>If no constructor is provided to explicitly initialize this member, its value is undefined. – 在标准12.6.2 Initializing bases and members(P268)</p>
<blockquote>
<p>Note: An abstract class (10.4) is never a most derived class, thus its constructors never initialize virtual base classes; therefore, the corresponding mem-initializers may be omitted. - end note ] An attempt to initialize more than one non-static data member of a union renders the program ill-formed. [ Note: After the call to a constructor for class X for an object with automatic or dynamic storage duration has completed, if the constructor was not invoked as part of value-initialization and a member of X is neither initialized nor given a value during execution of the compound-statement of the body of the constructor, the member has an indeterminate value. - end note</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="built_in">A</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">	<span class="built_in">B</span>(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	<span class="built_in">C</span>() &#123; &#125; <span class="comment">// initializes members as follows:</span></span><br><span class="line">	A a; <span class="comment">// OK: calls A::A()</span></span><br><span class="line">	<span class="type">const</span> B b; <span class="comment">// error: B has no default constructor</span></span><br><span class="line">	<span class="type">int</span> i; <span class="comment">// OK: i has indeterminate value</span></span><br><span class="line">	<span class="type">int</span> j = <span class="number">5</span>; <span class="comment">// OK: j has the value 5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If a given non-static data member has both a <em>brace-or-equal-initializer</em> and a <em>mem-initializer</em>, the <em>initialization</em> specified by the <em>mem-initializer</em> is performed, and the <em>non-static</em> data member’s <em>brace-or-equal-initializer</em> is ignored. [ Example: Given</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="comment">/* some integer expression with side effects */</span> ;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> arg) : <span class="built_in">i</span>(arg) &#123; &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>the A(int) constructor will simply initialize i to the value of arg, and the side effects in i’s <em>brace-or-equal-initializer</em> will not take place. - end example ]</p>
<h2 id="Undefined-Behavior"><a href="#Undefined-Behavior" class="headerlink" title="Undefined Behavior"></a>Undefined Behavior</h2><p>Behavior for which this International Standard imposes no requirements [ Note: Undefined behavior may be expected when this International Standard omits any explicit definition of behavior or when a program uses an erroneous construct or erroneous data. Permissible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message). Many erroneous program constructs do not engender undefined behavior; they are required to be diagnosed. - end note ]</p>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>C++ has no defined order of evaluation for sub-expressions in an expression. You cannot assume the expression is evaluated from left to right.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// There&#x27;s no definite specification whether f() or g() is called first</span></span><br><span class="line"><span class="type">int</span> x=<span class="built_in">f</span>(<span class="number">2</span>)+<span class="built_in">g</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>And the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">v[i]=i++; <span class="comment">// UB</span></span><br></pre></td></tr></table></figure>
<p>The assignment behavior may execute as v[1]=1 or v[2]=1;</p>
<h2 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h2><p>Let’s directly refer to the standard…<br>ISOIEC 14882 2014(C++14) §5.1.2 p90</p>
<p>**The evaluation of a lambda-expression results in a prvalue temporary (12.2). This temporary is called the **<code>closure object</code>. A lambda-expression shall not appear in an unevaluated operand (Clause 5), in a template-argument, in an alias-declaration, in a typedef declaration, or in the declaration of a function or function template outside its function body and default arguments. [ Note: The intention is to prevent lambdas from appearing in a signature. - end note ] [ Note: A closure object behaves like a function object (20.9). - endnote ]<br>The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non-union class type - called the closure type - whose properties are described below. This class type is neither an aggregate (8.5.1) nor a literal type (3.9). The closure type is declared in the smallest block scope, class scope, or namespace scope that contains the corresponding lambda-expression. [ Note: This determines the set of namespaces and classes associated with the closure type (3.4.2). The parameter types of a lambda-declarator do not affect these associated namespaces and classes. - end note ] An implementation may define the closure type differently from what is described below provided this does not alter the observable behavior of the program other than by changing:</p>
<ul>
<li>the size and/or alignment of the closure type,</li>
<li>whether the closure type is trivially copyable (Clause 9),</li>
<li>whether the closure type is a standard-layout class (Clause 9), or</li>
<li>whether the closure type is a POD class (Clause 9).</li>
</ul>
<h2 id="Lvalue-and-rvalue"><a href="#Lvalue-and-rvalue" class="headerlink" title="Lvalue and rvalue"></a>Lvalue and rvalue</h2><p>Expressions are categorized according to the taxonomy in Figure.</p>
<p> <img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/19242/lvalueAndRvalue.webp"></p>
<ul>
<li><strong>An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object.</strong> [ Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example, the result of calling a function whose return type is an lvalue reference is an lvalue. - end example ]</li>
<li><strong>An xvalue (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references (8.3.2).</strong> [ Example: The result of calling a function whose return type is an rvalue reference is an xvalue. - end example ]</li>
<li><strong>A glvalue (“generalized” lvalue) is an lvalue or an xvalue.</strong></li>
<li><strong>An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment expression) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated with an object.</strong></li>
<li><strong>A prvalue (“pure” rvalue) is an rvalue that is not an xvalue.</strong> [ Example: The result of calling a function whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is also a prvalue. - end example ]</li>
</ul>
<p>Every expression belongs to exactly one of the fundamental classifications in this taxonomy: lvalue, xvalue, or prvalue. This property of an expression is called its value category. [ Note: The discussion of each built-in operator in Clause 5 indicates the category of the value it yields and the value categories of the operands it expects. For example, the built-in assignment operators expect that the left operand is an lvalue and that the right operand is a prvalue and yield an lvalue as the result. User-defined operators are functions, and the categories of values they expect and yield are determined by their parameter and return types. - end note ]</p>
<h2 id="构造不允许int-gt-double的原因"><a href="#构造不允许int-gt-double的原因" class="headerlink" title="{}构造不允许int-&gt;double的原因"></a>{}构造不允许int-&gt;double的原因</h2><p>Because if int and double occupy the same number of bits, then some such int to double conversions must lose information.</p>
<p>It sometimes comes as a surprise that {}-construction doesn’t allow int to double conversion, but if (as is not uncommon) the size of an int is the same as the size of a double, then some such conversions must lose information. Consider:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)==<span class="built_in">sizeof</span>(<span class="type">double</span>),<span class="string">&quot;unexpected sizes&quot;</span>);</span><br><span class="line"><span class="type">int</span> x = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();  <span class="comment">//largest possible integer</span></span><br><span class="line"><span class="type">double</span> d = x;</span><br><span class="line"><span class="type">int</span> y = x;</span><br></pre></td></tr></table></figure>
<p>We will not get x==y. However, we can still initialize a double with an integer literal that can be represented exactly.</p>
<h2 id="char带不带符号由实现定义"><a href="#char带不带符号由实现定义" class="headerlink" title="char带不带符号由实现定义"></a>char带不带符号由实现定义</h2><p>It is implementation-defined whether a plain char is considered signed or unsigned. –[TCPL 6.2.3.1]</p>
<p><strong>[14882:2014(E) § 3.9.1]:</strong><br>A char, a signed char, and an unsigned char occupy the same amount of storage and have the same alignment requirements.<br>In any particular implementation, a plain char object can take on either the same values as a signed char or an unsigned char; which one is implementation-defined.</p>
<p>For each value i of type unsigned char in the range 0 to 255 inclusive, there exists a value j of type char such that the result of an integral conversion (4.7) from i to char is j, and the result of an integral conversion from j to unsigned char is i.</p>
<h2 id="默认参数的几个反例"><a href="#默认参数的几个反例" class="headerlink" title="默认参数的几个反例"></a>默认参数的几个反例</h2><p>Default arguments for a member function of a class template shall be specified on the initial declaration of the member function within the class template.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i = <span class="number">3</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j = <span class="number">99</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::f</span><span class="params">(<span class="type">int</span> i = <span class="number">3</span>)</span> </span>&#123; <span class="comment">// error: default argument already</span></span><br><span class="line">&#125; <span class="comment">// specified in class scope</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">C::g</span><span class="params">(<span class="type">int</span> i = <span class="number">88</span>, <span class="type">int</span> j)</span> </span>&#123; <span class="comment">// in this translation unit,</span></span><br><span class="line">&#125; <span class="comment">// C::g can be called with no argument</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Local variables shall not be used in a default argument. Example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>=<span class="number">0</span>)</span></span>; <span class="comment">// yes</span></span><br><span class="line">	<span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span>=i)</span></span>; <span class="comment">// error</span></span><br><span class="line">	<span class="built_in">g</span>();</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;g(void)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;g(int)\t&quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The keyword this shall not be used in a default argument of a member function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(A* p = <span class="keyword">this</span>)</span> </span>&#123; &#125; <span class="comment">// error</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>For more content, please refer to <strong>ISO/IEC 14882:2014(E) § 8.3.6</strong></p>
<h2 id="对象的几种初始化方式"><a href="#对象的几种初始化方式" class="headerlink" title="对象的几种初始化方式"></a>对象的几种初始化方式</h2><h2 id="zero-initialize"><a href="#zero-initialize" class="headerlink" title="zero-initialize"></a>zero-initialize</h2><p>To zero-initialize an object or reference of type T means:</p>
<ul>
<li>if T is a scalar type (3.9), the object is initialized to the value obtained by converting the integer literal 0 (zero) to T;</li>
<li>if T is a (possibly cv-qualified) non-union class type, each non-static data member and each base-class subobject is zero-initialized and padding is initialized to zero bits;</li>
<li>if T is a (possibly cv-qualified) union type, the object’s first non-static named data member is zero-initialized and padding is initialized to zero bits;</li>
<li>if T is an array type, each element is zero-initialized;</li>
<li>if T is a reference type, no initialization is performed.</li>
</ul>
<h2 id="default-initialize"><a href="#default-initialize" class="headerlink" title="default-initialize"></a>default-initialize</h2><p>To default-initialize an object of type T means:</p>
<ul>
<li>if T is a (possibly cv-qualified) class type (Clause 9), the default constructor (12.1) for T is called (and the initialization is ill-formed if T has no default constructor or overload resolution (13.3) results in an ambiguity or in a function that is deleted or inaccessible from the context of the initialization);</li>
<li>if T is an array type, each element is default-initialized;</li>
<li>otherwise, no initialization is performed.</li>
</ul>
<p>If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type with a user-provided default constructor.</p>
<h2 id="value-initialize"><a href="#value-initialize" class="headerlink" title="value-initialize"></a>value-initialize</h2><p>To value-initialize an object of type T means:</p>
<ul>
<li>if T is a (possibly cv-qualified) class type (Clause 9) with either no default constructor (12.1) or a default constructor that is user-provided or deleted, then the object is default-initialized;</li>
<li>if T is a (possibly cv-qualified) class type without a user-provided or deleted default constructor, then the object is zero-initialized and the semantic constraints for default-initialization are checked, and if T has a non-trivial default constructor, the object is default-initialized;</li>
<li>if T is an array type, then each element is value-initialized;</li>
<li>otherwise, the object is zero-initialized.</li>
</ul>
<p>An object that is value-initialized is deemed to be constructed and thus subject to provisions of this International Standard applying to “constructed” objects, objects “for which the constructor has completed,” etc., even if no constructor is invoked for the object’s initialization.</p>
<h2 id="Initialization-of-non-local-variables"><a href="#Initialization-of-non-local-variables" class="headerlink" title="Initialization of non-local variables"></a>Initialization of non-local variables</h2><p>There are two broad classes of named non-local variables: those with static storage duration (3.7.1) and those with thread storage duration (3.7.2). Non-local variables with static storage duration are initialized as a consequence of program initiation. Non-local variables with thread storage duration are initialized as a consequence of thread execution. Within each of these phases of initiation, initialization occurs as follows.<br><code>Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place.</code> A constant initializer for an object o is an expression that is a constant expression, except that it may also invoke constexpr constructors for o and its subobjects even if those objects are of non-literal class types [ Note: such a class may have a non-trivial destructor - end note ]. Constant initialization is performed:</p>
<ul>
<li>if each full-expression (including implicit conversions) that appears in the initializer of a reference with static or thread storage duration is a constant expression (5.19) and the reference is bound to an lvalue designating an object with static storage duration, to a temporary (see 12.2), or to a function;</li>
<li>if an object with static or thread storage duration is initialized by a constructor call, and if the initialization full-expression is a constant initializer for the object;</li>
<li>if an object with static or thread storage duration is not initialized by a constructor call and if either the object is value-initialized or every full-expression that appears in its initializer is a constant expression.</li>
</ul>
<p>Together, zero-initialization and constant initialization are called static initialization; all other initialization is dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place. Dynamic initialization of a non-local variable with static storage duration is either ordered or unordered. Definitions of explicitly specialized class template static data members have ordered initialization. Other class template static data members (i.e., implicitly or explicitly instantiated specializations) have unordered initialization. Other non-local variables with static storage duration have ordered initialization.<br>Variables with ordered initialization defined within a single translation unit shall be initialized in the order of their definitions in the translation unit. If a program starts a thread (30.3), the subsequent initialization of a variable is unsequenced with respect to the initialization of a variable defined in a different translation unit. Otherwise, the initialization of a variable is indeterminately sequenced with respect to the initialization of a variable defined in a different translation unit. If a program starts a thread, the subsequent unordered initialization of a variable is unsequenced with respect to every other dynamic initialization. Otherwise, the unordered initialization of a variable is indeterminately sequenced with respect to every other dynamic initialization. [ Note: This definition permits initialization of a sequence of ordered variables concurrently with another sequence. - end note ] [ Note: The initialization of local static variables is described in 6.7.- end note ]## value and/or reference semantics<br><a target="_blank" rel="noopener" href="https://isocpp.org/wiki/faq/value-vs-ref-semantics">What is value and/or reference semantics, and which is best in C++?</a></p>
<p>With reference semantics, assignment is a pointer-copy (i.e., a reference). Value (or “copy”) semantics mean assignment copies the value, not just the pointer. C++ gives you the choice: use the assignment operator to copy the value (copy/value semantics), or use a pointer-copy to copy a pointer (reference semantics). C++ allows you to override the assignment operator to do anything your heart desires, however the default (and most common) choice is to copy the value.</p>
<p>Pros of reference semantics: flexibility and dynamic binding (you get dynamic binding in C++ only when you pass by pointer or pass by reference, not when you pass by value).</p>
<p>Pros of value semantics: speed. “Speed” seems like an odd benefit for a feature that requires an object (vs. a pointer) to be copied, but the fact of the matter is that one usually accesses an object more than one copies the object, so the cost of the occasional copies is (usually) more than offset by the benefit of having an actual object rather than a pointer to an object.</p>
<p>There are three cases when you have an actual object as opposed to a pointer to an object: local objects, global/static objects, and fully contained member objects in a class. The most important of these is the last (“composition”).</p>
<p>More info about copy-vs-reference semantics is given in the next FAQs. Please read them all to get a balanced perspective. The first few have intentionally been slanted toward value semantics, so if you only read the first few of the following FAQs, you’ll get a warped perspective.</p>
<p>Assignment has other issues (e.g., shallow vs. deep copy) which are not covered here.</p>
<h2 id="Increment-and-decrement-prefix-and-postfix"><a href="#Increment-and-decrement-prefix-and-postfix" class="headerlink" title="Increment and decrement(prefix and postfix)"></a>Increment and decrement(prefix and postfix)</h2><p>1 The user-defined function called operator++ implements the prefix and postfix ++ operator. If this function is a member function with no parameters, or a non-member function with one parameter, it defines the prefix increment operator ++ for objects of that type. If the function is a member function with one parameter (which shall be of type int) or a non-member function with two parameters (the second of which shall be of type int), it defines the postfix increment operator ++ for objects of that type. When the postfix increment is called as a result of using the ++ operator, the int argument will have value zero.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	X&amp; <span class="keyword">operator</span>++(); <span class="comment">// prefix ++a</span></span><br><span class="line">	X <span class="keyword">operator</span>++(<span class="type">int</span>); <span class="comment">// postfix a++</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">Y&amp; <span class="keyword">operator</span>++(Y&amp;); <span class="comment">// prefix ++b</span></span><br><span class="line">Y <span class="keyword">operator</span>++(Y&amp;, <span class="type">int</span>); <span class="comment">// postfix b++</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(X a, Y b)</span> </span>&#123;</span><br><span class="line">	++a; <span class="comment">// a.operator++();</span></span><br><span class="line">	a++; <span class="comment">// a.operator++(0);</span></span><br><span class="line">	++b; <span class="comment">// operator++(b);</span></span><br><span class="line">	b++; <span class="comment">// operator++(b, 0);</span></span><br><span class="line">	a.<span class="keyword">operator</span>++(); <span class="comment">// explicit call: like ++a;</span></span><br><span class="line">	a.<span class="keyword">operator</span>++(<span class="number">0</span>); <span class="comment">// explicit call: like a++;</span></span><br><span class="line">	<span class="keyword">operator</span>++(b); <span class="comment">// explicit call: like ++b;</span></span><br><span class="line">	<span class="keyword">operator</span>++(b, <span class="number">0</span>); <span class="comment">// explicit call: like b++;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The prefix and postfix decrement operators – are handled analogously.</p>
<h2 id="Argument-dependent-name-lookup-ADL"><a href="#Argument-dependent-name-lookup-ADL" class="headerlink" title="Argument-dependent name lookup(ADL)"></a>Argument-dependent name lookup(ADL)</h2><p>When the postfix-expression in a function call (5.2.2) is an unqualified-id, other namespaces not considered during the usual unqualified lookup (3.4.1) may be searched, and in those namespaces, namespace-scope<br>friend function or function template declarations (11.3) not otherwise visible may be found. These modifications to the search depend on the types of the arguments (and for template template arguments, the<br>namespace of the template argument).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> N &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">S</span> &#123; &#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(S)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	N::S s;</span><br><span class="line">	<span class="built_in">f</span>(s); <span class="comment">// OK: calls N::f</span></span><br><span class="line">	(f)(s); <span class="comment">// error: N::f not considered; parentheses</span></span><br><span class="line">	<span class="comment">// prevent argument-dependent lookup</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For each argument type T in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of the function arguments (and the namespace of any template template argument).Typedef names and using-declarations used to specify the types do not contribute to this set. The sets of namespaces and classes are determined in the following way:</p>
<ul>
<li>If T is a fundamental type, its associated sets of namespaces and classes are both empty.</li>
<li>If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes. Its associated namespaces are the innermost enclosing namespaces of its associated classes. Furthermore, if T is a class template specialization, its associated namespaces and classes also include: the namespaces and classes associated with the types of the template arguments provided for template type parameters (excluding template template parameters); the namespaces of which any template template arguments are members; and the classes of which any member templates used as template template arguments are members. [ Note: Non-type template arguments do not contribute to the set of associated namespaces. — end note ]</li>
<li>If T is an enumeration type, its associated namespace is the innermost enclosing namespace of its declaration. If it is a class member, its associated class is the member’s class; else it has no associated class.</li>
<li>If T is a pointer to U or an array of U, its associated namespaces and classes are those associated with U.</li>
<li>If T is a function type, its associated namespaces and classes are those associated with the function parameter types and those associated with the return type.</li>
<li>If T is a pointer to a member function of a class X, its associated namespaces and classes are those associated with the function parameter types and return type, together with those associated with X.</li>
</ul>
<p>If an associated namespace is an inline namespace (7.3.1), its enclosing namespace is also included in the set. If an associated namespace directly contains inline namespaces, those inline namespaces are also included in the set. In addition, if the argument is the name or address of a set of overloaded functions and/or function templates, its associated classes and namespaces are the union of those associated with each of the members of the set, i.e., the classes and namespaces associated with its parameter types and return type. Additionally, if the aforementioned set of overloaded functions is named with a template-id, its associated classes and namespaces also include those of its type template-arguments and its template template-arguments.</p>
<p>Let X be the lookup set produced by unqualified lookup (3.4.1) and let Y be the lookup set produced by<br>argument dependent lookup (defined as follows). If X contains:</p>
<ul>
<li>a declaration of a class member, or</li>
<li>a block-scope function declaration that is not a using-declaration, or</li>
<li>a declaration that is neither a function or a function template</li>
</ul>
<p>then Y is empty. Otherwise Y is the set of declarations found in the namespaces associated with the argument types as described below. The set of declarations found by the lookup of the name is the union of X and Y . [ Note: The namespaces and classes associated with the argument types can include namespaces and classes already considered by the ordinary unqualified lookup.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">T</span> &#123; &#125;;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(T, <span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">NS::T parm;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(NS::T, <span class="type">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">f</span>(parm); <span class="comment">// OK: calls NS::f</span></span><br><span class="line">	<span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">g</span><span class="params">(NS::T, <span class="type">float</span>)</span></span>;</span><br><span class="line">	<span class="built_in">g</span>(parm, <span class="number">1</span>); <span class="comment">// OK: calls g(NS::T, float)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When considering an associated namespace, the lookup is the same as the lookup performed when the associated namespace is used as a qualifier (3.4.3.2) except that:</p>
<ul>
<li>Any using-directives in the associated namespace are ignored.</li>
<li>Any namespace-scope friend functions or friend function templates declared in associated classes are visible within their respective namespaces even if they are not visible during an ordinary lookup (11.3).</li>
<li>All names except those of (possibly overloaded) functions and function templates are ignored.</li>
</ul>
<h2 id="sizeof-non-member-class"><a href="#sizeof-non-member-class" class="headerlink" title="sizeof(non-member-class)"></a>sizeof(<em>non-member-class</em>)</h2><p>Complete objects and member subobjects of class type shall have nonzero size.(Base class subobjects are not so constrained.)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sizeof</span>(A);	<span class="comment">// return value is 1.</span></span><br></pre></td></tr></table></figure>
<p>When we use a C++ compiler to compile the above code, <code>sizeof(A)</code> will yield 1.</p>
<h2 id="Derived-class-array-conversion-to-base-class-pointer-and-subsequent-arithmetic-operations"><a href="#Derived-class-array-conversion-to-base-class-pointer-and-subsequent-arithmetic-operations" class="headerlink" title="Derived class array conversion to base class pointer and subsequent arithmetic operations"></a>Derived class array conversion to base class pointer and subsequent arithmetic operations</h2><p>Consider the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="type">int</span> x&#123;<span class="number">12</span>&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="keyword">override</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">callDerviedFunc</span><span class="params">(A* x,<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;++i)&#123;</span><br><span class="line">    <span class="comment">// runtime error(Undefined behavior)</span></span><br><span class="line">    (x+i)-&gt;<span class="built_in">func</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	B a[<span class="number">10</span>];</span><br><span class="line">  <span class="built_in">callDerviedFunc</span>(a, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above code produces undefined behavior (usually a runtime error).<br>Because B is derived from A and adds its own member, so sizeof(B) &gt; sizeof(A), assuming sizeof(A) is 8, sizeof(B) is 16, when converting a pointer of type B to a pointer of type A, the pointer arithmetic is an offset of the pointer type, that is, A type pointer a+1 corresponds to the address pointed to by a offset by 8 bytes, while B type pointer b+1 equals an offset of 16 bytes. Therefore, in callDerviedFunc only the first <code>(x+0)-&gt;func()</code> will succeed, and on the next iteration <code>(x+1)-&gt;func()</code>, since the virtual function pointer cannot be found at the expected location, it will result in undefined behavior.<br>The standard stipulates:</p>
<blockquote>
<p>In particular, a pointer to a base class cannot be used for pointer arithmetic when the array contains objects of a derived class type.——<a target="_blank" rel="noopener" href="http://doc.imzlp.com/viewer.html?file=doc/standard/isocpp2014.pdf#136">ISO/IEC 14882:2014(E)§5.7 P120</a></p>
</blockquote>
<p>When converting a set of derived class pointers to base class pointers, it is advisable to use standard library containers instead of raw arrays, as raw arrays cannot provide type safety like containers.</p>
<h2 id="copy-assignment-operator"><a href="#copy-assignment-operator" class="headerlink" title="copy assignment operator"></a>copy assignment operator</h2><blockquote>
<p>A user-declared copy assignment operator X::operator= is a non-static non-template member function of class X with exactly one parameter of type X, X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;.——<a target="_blank" rel="noopener" href="http://doc.imzlp.com/viewer.html?file=doc/standard/isocpp2014.pdf#292">ISO/IEC 14882:2014(E) §12.8 P276</a></p>
</blockquote>
<p>[ Note: An overloaded assignment operator must be declared to have only one parameter; see 13.5.3. — end note ]<br>[ Note: More than one form of copy assignment operator may be declared for a class. — end note ]<br>[ Note: If a class X only has a copy assignment operator with a parameter of type X&amp;, an expression of type const X cannot be assigned to an object of type X.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">	<span class="built_in">X</span>();</span><br><span class="line">	X&amp; <span class="keyword">operator</span>=(X&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> X cx;</span><br><span class="line">X x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	x = cx; <span class="comment">// error: X::operator=(X&amp;) cannot assign cx into x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Do-not-expect-polymorphic-behavior-when-calling-virtual-functions-from-a-base-class-constructor"><a href="#Do-not-expect-polymorphic-behavior-when-calling-virtual-functions-from-a-base-class-constructor" class="headerlink" title="Do not expect polymorphic behavior when calling virtual functions from a base class constructor"></a>Do not expect polymorphic behavior when calling virtual functions from a base class constructor</h2><p>It is not possible to achieve polymorphic behavior in a base class constructor, as the base class constructor executes before the derived class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">A</span>()&#123;<span class="built_in">func</span>();&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;A::func&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>:<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">B</span>()&#123;<span class="built_in">func</span>();&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="keyword">override</span></span>&#123;cout&lt;&lt;<span class="string">&quot;B::func&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A *obj=<span class="keyword">new</span> B;</span><br><span class="line">	<span class="keyword">delete</span> obj;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">A::func</span><br><span class="line">B::func</span><br></pre></td></tr></table></figure>

<h2 id="lifetimes-of-objects"><a href="#lifetimes-of-objects" class="headerlink" title="lifetimes of objects"></a>lifetimes of objects</h2><p>We can classify objects based on their lifetimes:</p>
<ul>
<li><code>Automatic</code>: Unless the programmer specifies otherwise (§12.1.8, §16.2.12), an object declared in a function is created when its definition is encountered and destroyed when its name goes out of scope. Such objects are sometimes called automatic objects. In a typical implementation, automatic objects are allocated on the stack; each call of the function gets its own <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Call_stack#STACK-FRAME">stack frame</a> to hold its automatic objects.</li>
<li><code>Static</code>: Objects declared in global or namespace scope (§6.3.4) and statics declared in functions (§12.1.8) or classes (§16.2.12) are created and initialized once (only) and ‘‘live’’ until the program terminates (§15.4.3). Such objects are called static objects. A static object has the same address throughout the life of a program execution. Static objects can cause serious problems in a multi-threaded program because they are shared among all threads and typically require locking to avoid data races (§5.3.1, §42.3).</li>
<li><code>Free store</code>: Using the new and delete operators, we can create objects whose lifetimes are controlled directly (§11.2).</li>
<li><code>Temporary objects</code> (e.g., intermediate results in a computation or an object used to hold a value for a reference to const argument): their lifetime is determined by their use. If they are bound to a reference, their lifetime is that of the reference; otherwise, they ‘‘live’’ until the end of the full expression of which they are part. A full expression is an expression that is not part of another expression. Typically, temporary objects are automatic.</li>
<li><code>Thread-local objects</code>; that is, objects declared thread_local (§42.2.8): such objects are created when their thread is and destroyed when their thread is. Static and automatic are traditionally referred to as storage classes.</li>
</ul>
<p>Array elements and nonstatic class members have their lifetimes determined by the object of which they are part.</p>
<h2 id="Giving-temporary-objects-extended-lifetimes-with-const-T-amp"><a href="#Giving-temporary-objects-extended-lifetimes-with-const-T-amp" class="headerlink" title="Giving temporary objects extended lifetimes with const T&amp;"></a>Giving temporary objects extended lifetimes with const T&amp;</h2><p>When we declare a <code>const T&amp;</code> to reference a temporary object, it gives the temporary object an extended lifetime until the lifetime of that reference:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">11</span>,y=<span class="number">12</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span>&amp; z=x+y;</span><br><span class="line">	<span class="comment">// The temporary object created by x+y will be destroyed when leaving the lifetime of z.</span></span><br><span class="line">	<span class="type">int</span> e=<span class="number">13</span>;</span><br><span class="line">&#125;<span class="comment">// destroy x,y,z,e</span></span><br></pre></td></tr></table></figure>
<p>The order of destruction of the <code>const T&amp;</code> follows the usual object destruction order (in reverse).<br>In the code above, the destruction order is e,z,y,x.</p>
<p>The standard defines:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="built_in">S</span>();</span><br><span class="line">	<span class="built_in">S</span>(<span class="type">int</span>);</span><br><span class="line">	<span class="keyword">friend</span> S <span class="keyword">operator</span>+(<span class="type">const</span> S&amp;, <span class="type">const</span> S&amp;);</span><br><span class="line">	~<span class="built_in">S</span>();</span><br><span class="line">&#125;;</span><br><span class="line">S obj1;</span><br><span class="line"><span class="type">const</span> S&amp; cr = <span class="built_in">S</span>(<span class="number">16</span>)+<span class="built_in">S</span>(<span class="number">23</span>);</span><br><span class="line">S obj2;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>the expression S(16) + S(23) creates three temporaries: a first temporary T1 to hold the result of the expression S(16), a second temporary T2 to hold the result of the expression S(23), and a third temporary T3 to hold the result of the addition of these two expressions. The temporary T3 is then bound to the reference cr. It is unspecified whether T1 or T2 is created first. On an implementation where T1 is created before T2, T2 shall be destroyed before T1. The temporaries T1 and T2 are bound to the reference parameters of operator+; these temporaries are destroyed at the end of the full-expression containing the call to operator+. The temporary T3 bound to the reference cr is destroyed at the end of cr’s lifetime, that is, at the end of the program. In addition, the order in which T3 is destroyed takes into account the destruction order of other objects with static storage duration. That is, because obj1 is constructed before T3, and T3 is constructed before obj2, obj2 shall be destroyed before T3, and T3 shall be destroyed before obj1.</p>
</blockquote>
<h2 id="Point-of-declaration"><a href="#Point-of-declaration" class="headerlink" title="Point of declaration"></a>Point of declaration</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> * p = &amp;p;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">bool</span>(p);</span><br><span class="line">&#125;</span><br><span class="line">result is <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its initializer (if any)</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> x = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// Here the second x is initialized with its own (indeterminate) value.</span></span><br><span class="line">&#123; <span class="type">unsigned</span> <span class="type">char</span> x = x; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note: a name from an outer scope remains visible up to the point of declaration of the name that hides it.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// declares a block-scope array of two integers.</span></span><br><span class="line">&#123; <span class="type">int</span> i[i]; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The point of declaration for an enumerator is immediately after its enumerator-definition.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// Here, the enumerator x is initialized with the value of the constant x, namely 12.</span></span><br><span class="line">&#123; <span class="keyword">enum</span> &#123; x = x &#125;; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>After the point of declaration of a class member, the member name can be looked up in the scope of its class. [ Note: this is true even if the class is an incomplete class.]</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">E</span> &#123; z = <span class="number">16</span> &#125;;</span><br><span class="line">	<span class="type">int</span> b[X::z]; <span class="comment">// OK</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="declaration-and-define"><a href="#declaration-and-define" class="headerlink" title="declaration and define"></a>declaration and define</h2><blockquote>
<p>A declaration is a definition unless it declares a function without specifying the function’s body (8.4), it contains the extern specifier (7.1.1) or a linkage-specification 25 (7.5) and neither an initializer nor a function-body, it declares a static data member in a class definition (9.2, 9.4), it is a class name declaration (9.1), it is an opaque-enum-declaration (7.2), it is a template-parameter (14.1), it is a parameter-declaration (8.3.5) in a function declarator that is not the declarator of a function-definition, or it is a typedef declaration (7.1.3), an alias-declaration (7.1.3), a using-declaration (7.3.3), a static_assert-declaration (Clause 7), an attribute- declaration (Clause 7), an empty-declaration (Clause 7), or a using-directive (7.3.4).</p>
</blockquote>
<h2 id="template-default-arguments"><a href="#template-default-arguments" class="headerlink" title="template default arguments"></a>template default arguments</h2><blockquote>
<p>A template-parameter of a template template-parameter is permitted to have a default template-argument. When such default arguments are specified, they apply to the template template-parameter in the scope of the template template-parameter.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">int</span>&gt; <span class="keyword">struct</span> A &#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">A</span>&lt;<span class="type">double</span>&gt; &#123; &#125;; <span class="comment">// specialize for T == double</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">A</span>&lt;&gt; &#123;<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> X=<span class="number">111</span>;&#125;; <span class="comment">// specialize for T == int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A&lt;&gt;::X == A&lt;int&gt;::X</span></span><br><span class="line"><span class="comment">// output: 111</span></span><br><span class="line">cout&lt;&lt;A&lt;&gt;::X&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<h2 id="static-object-initialized-of-C"><a href="#static-object-initialized-of-C" class="headerlink" title="static object initialized of C"></a>static object initialized of C</h2><blockquote>
<p>If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static storage duration is not initialized explicitly, then:</p>
</blockquote>
<ol>
<li>if it has pointer type, it is initialized to a null pointer;</li>
<li>if it has arithmetic type, it is initialized to (positive or unsigned) zero;</li>
<li>if it is an aggregate, every member is initialized (recursively) according to these rules;</li>
<li>if it is a union, the first named member is initialized (recursively) according to these rules.</li>
</ol>
<h2 id="compound-literal-of-C"><a href="#compound-literal-of-C" class="headerlink" title="compound literal of C"></a>compound literal of C</h2><blockquote>
<p>ISO/IEC 9899:1999 (E)<br>A postfix expression that consists of a parenthesized type name followed by a brace-enclosed list of initializers is a compound literal. It provides an unnamed object whose value is given by the initializer list.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p=(<span class="type">int</span>[])&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="noreturn-attribute"><a href="#noreturn-attribute" class="headerlink" title="[[noreturn]] attribute"></a>[[noreturn]] attribute</h2><p><strong>The attribute-token <code>noreturn</code> specifies that a function does not return.</strong> It shall appear at most once in each attribute-list and no attribute-argument-clause shall be present. The attribute may be applied to the declarator-id in a function declaration. The first declaration of a function shall specify the noreturn attribute if any declaration of that function specifies the noreturn attribute. If a function is declared with the noreturn attribute in one translation unit and the same function is declared without the noreturn attribute in another translation unit, the program is ill-formed; no diagnostic required. <strong>If a function f is called where f was previously declared with the noreturn attribute and f eventually returns, the behavior is undefined.</strong> [ Note: The function may terminate by throwing an exception. — end note ] [ Note: Implementations are encouraged to issue a warning if a function marked <code>[[noreturn]]</code> might return. — end note ]</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[ noreturn ]] <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">&quot;error&quot;</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// behavior is undefined if called with an argument &lt;= 0</span></span><br><span class="line">[[ noreturn ]] <span class="function"><span class="type">void</span> <span class="title">q</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">&quot;positive&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="five-ways-of-exiting-a-function"><a href="#five-ways-of-exiting-a-function" class="headerlink" title="five ways of exiting a function"></a>five ways of exiting a function</h2><p>A <code>return</code>-statement is one of five ways of exiting a function:</p>
<ol>
<li>Executing a <code>return</code>-statement.</li>
<li>“Falling off the end” of a function; that is, simply reaching the end of the function body. This is allowed only in functions that are not declared to return a value (i.e., <code>void</code> functions) and in <code>main()</code>, where falling off the end indicates successful completion.</li>
<li>Throwing an exception that isn’t caught locally.</li>
<li>Terminating because an exception was thrown and not caught locally in a <code>noexcept</code> function.</li>
<li>Directly or indirectly invoking a system function that doesn’t return (e.g., <code>exit();</code>).</li>
</ol>
<p>A function that does not return normally (i.e., through a return or “falling off the end”) can be marked <code>[[noreturn]]</code>.</p>
<h2 id="Integer-float-literal-types"><a href="#Integer-float-literal-types" class="headerlink" title="Integer/float literal types"></a>Integer/float literal types</h2><p>Simply put, an integer literal can be <code>int</code>/<code>long int</code>/<code>long long int</code> without a specified suffix;</p>
<table>
<thead>
<tr>
<th align="center">Suffix</th>
<th align="center">Decimal literal</th>
</tr>
</thead>
<tbody><tr>
<td align="center">none</td>
<td align="center">int/long int/long long int</td>
</tr>
<tr>
<td align="center">u or U</td>
<td align="center">unsigned int/unsigned long int/unsigned long long int</td>
</tr>
<tr>
<td align="center">l or L</td>
<td align="center">long int/long long int</td>
</tr>
<tr>
<td align="center">Floating-point literals are <code>double</code>:</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>[C++11] The type of a floating literal is double unless explicitly specified by a suffix. The suffixes f and F specify float, the suffixes l and L specify long double.</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Suffix</th>
<th align="center">Decimal literal</th>
</tr>
</thead>
<tbody><tr>
<td align="center">none</td>
<td align="center">double</td>
</tr>
<tr>
<td align="center">f or F</td>
<td align="center">float</td>
</tr>
<tr>
<td align="center">l or L</td>
<td align="center">long double</td>
</tr>
<tr>
<td align="center">This is consistent with the requirements in C and C++.</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="Differences-in-sizeof-computation-periods-in-C-and-C"><a href="#Differences-in-sizeof-computation-periods-in-C-and-C" class="headerlink" title="Differences in sizeof computation periods in C and C++"></a>Differences in sizeof computation periods in C and C++</h2><p>Generally, the sizeof operator in C behaves at compile time, but due to C having variable length arrays (VLA), it is evaluated at runtime when its operand is a VLA array. </p>
<blockquote>
<p>[C99] If the type of the operand is a variable length array type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an integer constant.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fsize3</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> b[n+<span class="number">3</span>]; <span class="comment">// variable length array</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">sizeof</span> b; <span class="comment">// execution time sizeof</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In C++, <code>sizeof</code> and <code>sizeof...</code> are strictly compile-time behaviors.</p>
<blockquote>
<p>[C++11] The result of sizeof and sizeof… is a constant of type std::size_t.</p>
</blockquote>
<h2 id="Relationship-between-C-and-C-Differences-in-logical-operator-results"><a href="#Relationship-between-C-and-C-Differences-in-logical-operator-results" class="headerlink" title="Relationship between C and C++ / Differences in logical operator results"></a>Relationship between C and C++ / Differences in logical operator results</h2><p>Essentially, the relationship/equality/logical/ternary operator’s first-expression result in C is int (0/1), while in C++ it is of type bool.</p>
<h2 id="Relational-operators"><a href="#Relational-operators" class="headerlink" title="Relational operators"></a>Relational operators</h2><blockquote>
<p>[C++11] The operands shall have arithmetic, enumeration, or pointer type. The operators &lt; (less than), &gt; (greater than), &lt;= (less than or equal to), and &gt;= (greater than or equal to) all yield false or true. The type of the result is <code>bool</code>.<br>[C99] Each of the operators &lt; (less than), &gt; (greater than), &lt;= (less than or equal to), and &gt;= (greater than or equal to) shall yield 1 if the specified relation is true and 0 if it is false. The result has type <code>int</code>.</p>
</blockquote>
<h2 id="Equality-operators"><a href="#Equality-operators" class="headerlink" title="Equality operators"></a>Equality operators</h2><blockquote>
<p>[C++11] The == (equal to) and the != (not equal to) operators group left-to-right. The operands shall have arithmetic, enumeration, pointer, or pointer to member type, or type std::nullptr_t. The operators == and != both yield true or false, i.e., a result of type bool.<br>[C99] The == (equal to) and != (not equal to) operators are analogous to the relational operators except for their lower precedence. Each of the operators yields 1 if the specified relation is true and 0 if it is false. The result has type int.</p>
</blockquote>
<h2 id="Conditional-expressions"><a href="#Conditional-expressions" class="headerlink" title="Conditional expressions"></a>Conditional expressions</h2><blockquote>
<p>[C++11] Conditional expressions group right-to-left. The first expression is contextually converted to bool. It is evaluated and if it is true, the result of the conditional expression is the value of the second expression, otherwise that of the third expression. Only one of the second and third expressions is evaluated.<br>[C99] The first operand is evaluated; there is a sequence point after its evaluation. The second operand is evaluated only if the first compares unequal to 0; the third operand is evaluated only if the first compares equal to 0;</p>
</blockquote>
<h2 id="Logical-operator"><a href="#Logical-operator" class="headerlink" title="Logical operator"></a>Logical operator</h2><blockquote>
<p>[C++11] The ||/&amp;&amp; operator groups left-to-right. The operands are both contextually converted to bool. The result is true if both operands are true and false otherwise.<br>[C99] The ||/&amp;&amp; operator shall yield 1 if both of its operands compare unequal to 0; otherwise, it yields 0. The result has type int.</p>
</blockquote>
<h2 id="Deleting-an-object-not-created-by-new-expressions"><a href="#Deleting-an-object-not-created-by-new-expressions" class="headerlink" title="Deleting an object not created by new expressions"></a>Deleting an object not created by new expressions</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">	~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::destructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">	<span class="comment">// AObj conversion to A*</span></span><br><span class="line">	<span class="keyword">operator</span> A*()&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;A::conversionToA*&quot;</span>&lt;&lt;endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A Aobj;</span><br><span class="line"><span class="comment">// implicitly converted to a pointer to object type.</span></span><br><span class="line"><span class="keyword">delete</span> Aobj;</span><br><span class="line"><span class="comment">// equivalent to</span></span><br><span class="line"><span class="keyword">delete</span> &amp;Aobj;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>If of class type, the operand is contextually implicitly converted (Clause 4) to a pointer to object type.</p>
</blockquote>
<p>Deleting an object not created by new expressions has <strong>undefined</strong> behavior.</p>
<blockquote>
<p>In the first alternative (delete object), the value of the operand of delete may be a null pointer value, a pointer to a non-array object created by a previous new-expression, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). If not, the behavior is undefined.</p>
</blockquote>
<h2 id="C-Library-memory-management-functions-do-not-call-new-delete"><a href="#C-Library-memory-management-functions-do-not-call-new-delete" class="headerlink" title="C Library memory management functions do not call new/delete"></a>C Library memory management functions do not call new/delete</h2><blockquote>
<p>The functions <code>calloc()</code>, <code>malloc()</code>, and <code>realloc()</code> do not attempt to allocate storage by calling <code>::operator new()</code>.<br>The function <code>free()</code> does not attempt to deallocate storage by calling <code>::operator delete()</code>.</p>
</blockquote>
<p>If one must use malloc to allocate memory, placement new can be used:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> z):<span class="built_in">x</span>(z)&#123;cout&lt;&lt;<span class="string">&quot;A::constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">	~<span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::destructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">	<span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A *x=(A*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(A));</span><br><span class="line">	::<span class="keyword">new</span>(x) <span class="built_in">A</span>(<span class="number">11</span>);</span><br><span class="line">	cout&lt;&lt;x-&gt;x&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">free</span>(x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* output</span></span><br><span class="line"><span class="comment">A::constructor</span></span><br><span class="line"><span class="comment">11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-names-are-not-pointers"><a href="#Array-names-are-not-pointers" class="headerlink" title="Array names are not pointers"></a>Array names are not pointers</h2><p>In <a target="_blank" rel="noopener" href="https://imzlp.com/posts/20449/">the logic behind array subscript access</a>, it is mentioned that an array name does not refer to the address of the first element of the array.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">3</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Here x is a 3 × 5 array of integers. When x appears in an expression, it is converted to a pointer to (the first of three) five-membered arrays of integers. In the expression x[i] which is equivalent to *(x+i), x is first converted to a pointer as described; then x+i is converted to the type of x, which involves multiplying i by the length of the object to which the pointer points, namely five integer objects.</p>
</blockquote>
<h2 id="C-and-ISO-C"><a href="#C-and-ISO-C" class="headerlink" title="C++ and ISO C"></a>C++ and ISO C</h2><div class="pdfobject-container" data-target="https://img.imzlp.com/imgs/zlp/blog/posts/19242/C++.and.ISO.C.pdf" data-height="700px"></div>

<h2 id="Compatibility-features-in-the-C-11-standard"><a href="#Compatibility-features-in-the-C-11-standard" class="headerlink" title="Compatibility features in the C++11 standard"></a>Compatibility features in the C++11 standard</h2><div class="pdfobject-container" data-target="https://img.imzlp.com/imgs/zlp/blog/posts/19242/ISOIEC.14882.2014.Annex.D.Compatibility.features.pdf" data-height="700px"></div>

<h2 id="Wild-Pointer-and-Dangling-Pointer"><a href="#Wild-Pointer-and-Dangling-Pointer" class="headerlink" title="Wild Pointer and Dangling Pointer"></a>Wild Pointer and Dangling Pointer</h2><p><strong>Wild Pointer</strong>: refers to a pointer that is uninitialized (no-initializer).  </p>
<blockquote>
<p><em>ISO/IEC 14882:2014(E)</em><br>When storage for an object with automatic or dynamic storage duration is obtained, the object has an indeterminate value, and if no initialization is performed for the object, that object retains an indeterminate value until that value is replaced (5.17).<br>After the declaration of an uninitialized pointer x (as with int* x;), x must always be assumed to have a singular value of a pointer.</p>
</blockquote>
<p>It can be seen that without initialization, the value of the pointer is undefined.</p>
<p><strong>Dangling Pointer</strong>: refers to a pointer that once pointed to a meaningful address, but that address’s memory has been freed (reclaimed by the operating system).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ivalp=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">delete</span> ivalp;</span><br><span class="line"><span class="comment">// After the delete on ivalp, it still points to the original address, and ival becomes a dangling pointer.</span></span><br><span class="line"><span class="comment">// Operations on a dangling pointer yield undefined behavior, as this block of memory has already been reclaimed by the OS (although sometimes operations still yield the original value).</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>ISO/IEC 9899:2011(E)</em><br>If an object is referred to outside of its lifetime, the behavior is undefined. The value of a pointer becomes indeterminate when the object it points to (or just past) reaches the end of its lifetime.</p>
</blockquote>
<h2 id="Trivial-default-constructor"><a href="#Trivial-default-constructor" class="headerlink" title="Trivial default constructor"></a>Trivial default constructor</h2><p>A default constructor is trivial if it is not user-provided and if:</p>
<ol>
<li>its class has no virtual functions (10.3) and no virtual base classes (10.1), and</li>
<li>no non-static data member of its class has a brace-or-equal-initializer, and</li>
<li>all the direct base classes of its class have trivial default constructors, and</li>
<li>for all the non-static data members of its class that are of class type (or array thereof), each such class has a trivial default constructor.</li>
</ol>
<p>Otherwise, the default constructor is non-trivial.</p>
<h2 id="Raw-string-literal"><a href="#Raw-string-literal" class="headerlink" title="Raw string literal"></a>Raw string literal</h2><p>The results of the following two expressions are the same.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">&quot;\\w\\\\w&quot;</span>;</span><br><span class="line">string s1=<span class="string">R&quot;(\w\\w)&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>In a raw string literal, a backslash is simply a backslash, and a double quote is just a double quote. They will not be escaped. Raw string literals are commonly used in regular expressions. Additionally, <code>R&quot;(</code> and <code>)&quot;</code> are not the only delimiters; we can include other delimiters before and after <code>(</code> and <code>)</code>. The rule requires that the sequence of characters following the <code>)</code> must exactly match the sequence preceding the <code>)</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">R&quot;***(&quot;THE STRING IS A TEST&quot;)***&quot;</span>;</span><br><span class="line"><span class="comment">// Equivalent to &quot;THE STRING IS A TEST&quot;</span></span><br></pre></td></tr></table></figure>
<p>Also, in a raw string literal, line breaks are allowed, signifying actual new lines rather than newline characters:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string s=<span class="string">R&quot;(&quot;123</span></span><br><span class="line"><span class="string">	    456</span></span><br><span class="line"><span class="string">	    789&quot;)&quot;</span>;</span><br><span class="line"><span class="comment">// Equivalent to</span></span><br><span class="line">string s1=&#123;<span class="string">&quot;123\n456\n789\n&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>For more content, please refer to “The C++ Programming Language” p5.5/p154.</p>
<h2 id="Placement-syntax"><a href="#Placement-syntax" class="headerlink" title="Placement syntax"></a>Placement syntax</h2><p>If we want to place an object in a different location, we can provide an allocation function with additional parameters.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(<span class="type">int</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>,<span class="type">void</span> *p)</span></span>&#123;<span class="keyword">return</span> p;&#125;</span><br><span class="line"><span class="comment">// A specific address</span></span><br><span class="line"><span class="type">void</span> buf=<span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="number">0xF00F</span>);</span><br><span class="line"><span class="comment">// Construct X at buf, calling operator new(sizeof(X), buf)</span></span><br><span class="line"><span class="type">void</span>* p2=<span class="built_in">new</span>(buf) X;</span><br></pre></td></tr></table></figure>

<p>For more details, refer to:<br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24091979/what-is-this-syntax-new-this-t">what is this syntax - new (this) T(); [duplicate]</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2495485/using-new-this-to-reuse-constructors">Using new (this) to reuse constructors</a></p>
<h2 id="Overriding-functions-do-not-override-their-original-default-parameters"><a href="#Overriding-functions-do-not-override-their-original-default-parameters" class="headerlink" title="Overriding functions do not override their original default parameters"></a>Overriding functions do not override their original default parameters</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(<span class="type">int</span> a = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(<span class="type">int</span> a = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> B;</span><br><span class="line">    b-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">B1</span><br></pre></td></tr></table></figure>
<p>Since the overriding function does not override its default parameters, the default parameter defined in class B for foo remains 1.</p>
<blockquote>
<p>A virtual function call (10.3) uses the default arguments in the declaration of the virtual function determined by the static type of the pointer or reference denoting the object. An overriding function in a derived class does not acquire default arguments from the function it overrides.</p>
</blockquote>
<h2 id="Static-is-thread-safe-initialization"><a href="#Static-is-thread-safe-initialization" class="headerlink" title="Static is thread-safe initialization"></a>Static is thread-safe initialization</h2><p><strong>[ISO/IEC 14882:2014(E) §6.8 P137]</strong>  </p>
<blockquote>
<p>If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.<br>The implementation must not introduce any deadlock around execution of the initializer.</p>
</blockquote>
<p>Static objects are essentially syntactic sugar for thread-safe initialized global variables.</p>
<h2 id="Non-local-static-initialization"><a href="#Non-local-static-initialization" class="headerlink" title="Non-local static initialization"></a>Non-local static initialization</h2><blockquote>
<p>[ISO/IEC 14882:2014 §3.6.2.4] It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of <code>main</code>.</p>
</blockquote>
<p>This means that the dynamic initialization of non-local static storage duration variables is completed before the execution of the first statement in the main function (implementation-defined).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="built_in">A</span>()&#123;cout&lt;&lt;<span class="string">&quot;A::constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">  <span class="built_in">B</span>()&#123;cout&lt;&lt;<span class="string">&quot;B::constructor&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> A a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// result</span></span><br><span class="line">A::constructor</span><br><span class="line">B::constructor</span><br></pre></td></tr></table></figure>

<h2 id="Order-of-evaluation-of-function-parameters"><a href="#Order-of-evaluation-of-function-parameters" class="headerlink" title="Order of evaluation of function parameters"></a>Order of evaluation of function parameters</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">f</span>(i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The C++ standard specifies that the side effects of argument evaluations are sequenced before the function is entered.  </p>
<blockquote>
<p>[ISO/IEC 14882:2014 §5.2.2.8] All side effects of argument evaluations are sequenced before the function is entered.</p>
</blockquote>
<p>Therefore, the output of the above code is 34. This can also be seen from the IR code perspective, observing how the compiler implements this feature:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">main</span>() #<span class="number">4</span> &#123;</span><br><span class="line">  store i32 <span class="number">3</span>, i32* @i, align <span class="number">4</span></span><br><span class="line">  %<span class="number">1</span> = load i32, i32* @i, align <span class="number">4</span></span><br><span class="line">  %<span class="number">2</span> = add nsw i32 %<span class="number">1</span>, <span class="number">1</span></span><br><span class="line">  store i32 %<span class="number">2</span>, i32* @i, align <span class="number">4</span></span><br><span class="line">  call <span class="type">void</span> @_Z1fi(i32 %<span class="number">1</span>)</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It can be seen that when executing f(i++), the compiler first increments i, then passes the value before the increment (%1) as the argument to f. Upon entering function f, since the static object i’s value has already been modified in the main function (%2), it outputs 3 and 4 respectively.</p>
<h2 id="VLA-cannot-have-initializers"><a href="#VLA-cannot-have-initializers" class="headerlink" title="VLA cannot have initializers"></a>VLA cannot have initializers</h2><blockquote>
<p><strong>[ISO/IEC 9899:1999]</strong> The type of the entity to be initialized shall be an array of unknown size or an object type that is not a variable length array type.</p>
</blockquote>
<p>Thus, the following is incorrect:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ivlan;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ivlan);</span><br><span class="line"><span class="type">int</span> ivla[ivlan]=&#123;<span class="number">0</span>&#125;;  <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>The correct approach is to determine the size of the array at runtime and assign values to its members one by one, which can be done using a <code>for loop</code> or <code>memset</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fuck;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;fuck);</span><br><span class="line"><span class="type">int</span> ival[fuck];</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span>*)ival,<span class="number">0</span>,(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)(fuck*<span class="built_in">sizeof</span>(<span class="type">int</span>)));</span><br></pre></td></tr></table></figure>

<h2 id="Template-appearing-on-the-right-side-of-gt-and"><a href="#Template-appearing-on-the-right-side-of-gt-and" class="headerlink" title="Template appearing on the right side of ./-&gt; and ::"></a>Template appearing on the right side of <code>.</code>/<code>-&gt;</code> and <code>::</code></h2><blockquote>
<p>A name prefixed by the keyword template shall be a template-id or the name shall refer to a class template. [ Note: The keyword template may not be applied to non-template members of class templates. - end note ] [ Note: As is the case with the typename prefix, the template prefix is allowed in cases where it is not strictly necessary; that is, when the nested-name-specifier or the expression on the left of the -&gt; or . is not dependent on a template-parameter, or the use does not appear in the scope of a template. - end note ]</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(U)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  A&lt;T&gt; a;</span><br><span class="line">  a.<span class="keyword">template</span> f&lt;&gt;(t); <span class="comment">// OK: calls template</span></span><br><span class="line">  a.<span class="function"><span class="keyword">template</span> <span class="title">f</span><span class="params">(t)</span></span>; <span class="comment">// error: not a template-id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note the distinction from typename; typename appears before the name it qualifies, while template appears immediately before the template name.</p>
<h2 id="What-is-Object-in-C-Standard"><a href="#What-is-Object-in-C-Standard" class="headerlink" title="What is Object in C++ Standard?"></a>What is Object in C++ Standard?</h2><blockquote>
<p><strong>[ISO/IEC 14882:2014]</strong> An <strong>object</strong> is a region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. - end note ] An object is created by a <strong>definition</strong> (3.1), by a <strong>new-expression</strong> (5.3.4) or by the implementation (12.2) when needed. The properties of an object are determined when the object is created.</p>
</blockquote>
<h2 id="Description-of-polymorphism-in-the-C-Standard-C-14"><a href="#Description-of-polymorphism-in-the-C-Standard-C-14" class="headerlink" title="Description of polymorphism in the C++ Standard (C++14)"></a>Description of polymorphism in the C++ Standard (C++14)</h2><p><strong>What is polymorphic?</strong>  </p>
<blockquote>
<p>Some objects are polymorphic (10.3); the implementation generates information associated with each such object that makes it possible to determine that object’s type during program execution.</p>
</blockquote>
<p><strong>What is polymorphic class?</strong>  </p>
<blockquote>
<p>Virtual functions support dynamic binding and object-oriented programming. A class that declares or inherits a virtual function is called a polymorphic class.</p>
</blockquote>
<p><strong>What is polymorphic behavior?</strong>  </p>
<blockquote>
<p>A base class subobject might have a polymorphic behavior (12.7) different from the polymorphic behavior of a most derived object of the same type.</p>
</blockquote>
<p>The standard does not specify how compilers should implement polymorphism, so its implementation relies on the compiler. Most compilers use a <strong>virtual function table</strong> to calculate offsets, and if the code involves direct access to the virtual function table, it may have little portability (across compilers). Therefore, one cannot assume all compilers implement the virtual function table in the same way (e.g., whether to merge virtual function tables in multiple inheritance).</p>
<h2 id="Class-object-size"><a href="#Class-object-size" class="headerlink" title="Class object size"></a>Class object size</h2><p>Complete objects and member subobjects of class type shall have non-zero size.  </p>
<blockquote>
<p>Complete objects and member subobjects of class type shall have nonzero size. (Base class subobjects are not so constrained.)</p>
</blockquote>
<p>Base class subobjects may be of zero size.  </p>
<blockquote>
<p>A base class subobject may be of zero size.</p>
</blockquote>
<p>And the standard description of its sizeof:  </p>
<blockquote>
<p>The size of a most derived class shall be greater than zero (1.8). The result of applying sizeof to a base class subobject is the size of the base class type. When applied to an array, the result is the total number of bytes in the array. This implies that the size of an array of n elements is n times the size of an element.</p>
</blockquote>
<h2 id="References-are-not-pointers"><a href="#References-are-not-pointers" class="headerlink" title="References are not pointers"></a>References are not pointers</h2><p>Earlier in an article, an author analyzed the way references are implemented in the compiler and insisted that references are pointers. This is incorrect.<br>First, look at how <code>g++/clang++</code> implements it:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">1234</span>;</span><br><span class="line"><span class="type">int</span> &amp;y=x;</span><br><span class="line"><span class="type">int</span> *z=&amp;x;</span><br></pre></td></tr></table></figure>
<p>Then view the LLVM-IR code of the above (irrelevant parts omitted):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%6 = alloca i32, align 4</span><br><span class="line">%7 = alloca i32*, align 8</span><br><span class="line">%8 = alloca i32*, align 8</span><br><span class="line"></span><br><span class="line">store i32 1234, i32* %6, align 4</span><br><span class="line">store i32* %6, i32** %7, align 8</span><br><span class="line">store i32* %6, i32** %8, align 8</span><br></pre></td></tr></table></figure>
<p>It can be seen that after compilation, references and pointers appear the same. However, this does not mean that references are pointers.  </p>
<blockquote>
<p><strong>[ISO/IEC 14882:2014]</strong> A reference can be thought of as a name of an object.</p>
</blockquote>
<p>In C++, there are no requirements for how features must be implemented; thus, saying that references are pointers is misleading.</p>
<h2 id="Type-of-this"><a href="#Type-of-this" class="headerlink" title="Type of this"></a>Type of this</h2><blockquote>
<p><strong>[ISO/IEC 14882:2014]</strong> The type of this in a member function of a class X is X*. If the member function is declared const, the type of this is const X*, if the member function is declared volatile, the type of this is volatile X*, and if the member function is declared const volatile, the type of this is const volatile X*.</p>
</blockquote>
<p>I reviewed the C++98/03/11/14 standards and found no differences among them.</p>
<h2 id="Differences-between-typedef-and-using"><a href="#Differences-between-typedef-and-using" class="headerlink" title="Differences between typedef and using"></a>Differences between typedef and using</h2><p>Both <code>typedef</code> and <code>using</code> can define a type alias, but why have two keywords with such similar functionality?<br>For <code>using</code>, it can not only introduce aliasing but also bring a namespace into the <code>name lookup</code> scope. From the perspective of declaring an <code>alias</code>, their most critical distinction is whether or not template aliases can be defined. <code>typedef</code> can achieve what <code>using</code> can, but the reverse is not true. I believe <code>typedef</code> remains mainly for <strong>C compatibility</strong>.<br>Here is the C++ standard’s description regarding the restrictions on <code>typedef</code>:</p>
<blockquote>
<p><strong>[ISO/IEC 14882:2014]</strong> It has the same semantics as if it were introduced by the typedef specifier. In particular, it does not define a new type and it shall not appear in the type-id.</p>
</blockquote>
<p>To use template aliases (template alias), only <code>using</code> can be used.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> VectorA=std::vector&lt;A&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">VectorA&lt;<span class="type">int</span>&gt; x;</span><br><span class="line"><span class="comment">// Equivalent to</span></span><br><span class="line">std::vector&lt;A&lt;<span class="type">int</span>&gt;&gt; x;</span><br></pre></td></tr></table></figure>

<h2 id="dynamic-cast-failure"><a href="#dynamic-cast-failure" class="headerlink" title="dynamic_cast failure"></a>dynamic_cast failure</h2><p>The behavior of pointer and reference conversions using <code>dynamic_cast</code> on failure differs; in pointer conversion, it returns a null pointer, while in reference conversion, it throws a <code>std::bad_cast</code> exception, as detailed in the C++ standard:  </p>
<blockquote>
<p><strong>[ISO/IEC 14882:2014]</strong> The value of a failed cast to pointer type is the null pointer value of the required result type. A failed cast to reference type throws an exception (15.1) of a type that would match a handler (15.3) of type <code>std::bad_cast</code> (18.7.2).</p>
</blockquote>
<h2 id="Implementation-defined-behavior"><a href="#Implementation-defined-behavior" class="headerlink" title="Implementation-defined behavior"></a>Implementation-defined behavior</h2><p><strong>[ISO/IEC 14882:2014]</strong> contains an Index of implementation-defined behavior:  </p>
<div class="pdfobject-container" data-target="https://img.imzlp.com/imgs/zlp/blog/posts/19242/Cpp14-Index-of-implementation-define-bahavior.pdf" data-height="700px"></div>

<h2 id="Name-hiding"><a href="#Name-hiding" class="headerlink" title="Name hiding"></a>Name hiding</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Astruct</span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Astruct=<span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ::Astruct;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The code above presents two issues:</p>
<ol>
<li>In the global scope, when using the identifier <code>Astruct</code>, is the identifier the class Astruct or int object Astruct?</li>
<li>When using the global scope’s <code>::Astruct</code> in the main function, which identifier is being used, the class Astruct or the int object Astruct?</li>
</ol>
<p>Firstly, regarding the first question, using the identifier <code>Astruct</code> in the global scope refers to the class type identifier:  </p>
<blockquote>
<p>A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member, function, or enumerator declared in the same scope. If a class or enumeration name and a variable, data member, function, or enumerator are declared in the same scope (in any order) with the same name, the class or enumeration name is hidden wherever the variable, data member, function, or enumerator name is visible.</p>
</blockquote>
<p>This indicates that within the same scope, class names hide all identifiers with the same name.</p>
<p>As for the second question: using <code>::Astruct</code> in the main function refers to the int object Astruct. If the class name Astruct is to be used, it must be explicitly specified:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ::Astruct Aobj;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A class declaration introduces the class name into the scope where it is declared and hides any class, variable, function, or other declaration of that name in an enclosing scope (3.3). If a class name is declared in a scope where a variable, function, or enumerator of the same name is also declared, then when both declarations are in scope, the class can be referred to only using an elaborated-type-specifier (3.4.4).</p>
</blockquote>
<h2 id="Several-ways-to-implement-abstract-base-classes"><a href="#Several-ways-to-implement-abstract-base-classes" class="headerlink" title="Several ways to implement abstract base classes"></a>Several ways to implement abstract base classes</h2><p>The concept of abstract classes as defined in the C++ standard is:  </p>
<blockquote>
<p>An abstract class can also be used to define an interface for which derived classes provide a variety of implementations.<br>An abstract class is a class that can be used only as a base class of some other class; <strong>no objects of an abstract class can be created except as subobjects of a class derived from it. A class is abstract if it has at least one pure virtual function.</strong> [ Note: Such a function might be inherited: see below. — end note ]<br>A class is abstract if it contains or inherits at least one pure virtual function for which the final overrider is pure virtual.</p>
</blockquote>
<p>Here, there are two concepts:</p>
<ol>
<li>Objects of abstract classes cannot be created, except as subobjects of derived classes.</li>
<li>At least one pure virtual function must be present.</li>
</ol>
<p>Pure virtual functions are not the only way to create abstract classes; any method that ensures <strong>no object can be created</strong> qualifies as an abstract class. This can be achieved by defining the constructor as <code>protected</code> (since the derived class’s constructor will call the base class’s constructor, we should ensure that the derived class has access):  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp;)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Of course, this method is quite blunt. This method can also facilitate the following two operations (in a multi-inheritance hierarchy, it can be defined as private):</p>
<ul>
<li>Allow allocation of objects only on the stack by defining <code>operator new</code> and <code>operator delete</code> member functions as protected.</li>
<li>Allow allocation of objects only on the heap by defining the <code>destructor</code> member function as protected.</li>
</ul>
<p>If there is no compelling reason to define a member function as pure virtual, the destructor can also be defined as pure virtual:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">A</span>()=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">A::~A&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>However, this is not a good idea, as the derived class’s destructor will implicitly call the base class’s destructor. This means that when a destructor is defined as pure virtual, it must provide an implementation; otherwise, a linking error will occur. This contradicts the definition of pure virtual functions:  </p>
<blockquote>
<p>A function declaration cannot provide both a pure-specifier and a definition.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span> &#123; &#125;; <span class="comment">// ill-formed</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In C++, there are many ways to implement behavior, but not all methods are the best; it is important to fit one’s needs.</p>
<h2 id="Pointer-comparison-behavior"><a href="#Pointer-comparison-behavior" class="headerlink" title="Pointer comparison behavior"></a>Pointer comparison behavior</h2><p>Comparing pointers to objects is defined as follows:</p>
<ul>
<li>If two pointers point to different elements of the same array, or to subobjects thereof, the pointer to the element with the higher subscript compares greater.</li>
<li>If one pointer points to an element of an array, or to a subobject thereof, and another pointer points one past the last element of the array, the latter pointer compares greater.</li>
<li>If two pointers point to different non-static data members of the same object, or to subobjects of such members, recursively, the pointer to the later declared member compares greater provided the two members have the same access control (Clause 11) and provided their class is not a union.<h2 id="subobjects-in-C"><a href="#subobjects-in-C" class="headerlink" title="subobjects in C++"></a>subobjects in C++</h2><blockquote>
<p><strong>[ISO/IEC 14882:2014]</strong> Objects can contain other objects, called <strong>subobjects</strong>. A subobject can be a <strong>member subobject</strong> (9.2), a <strong>base class subobject</strong> (Clause 10), or an <strong>array element</strong>.</p>
</blockquote>
</li>
</ul>
<p>From this perspective, if you want to implement <strong>inheritance</strong> of data members in C, you only need to include a <code>struct base</code> member in <code>struct derived</code>. It is quite interesting to try to implement OO features using C; I will analyze this for a while and write an article about it.</p>

    </div>

    
    
        
        
          
            <blockquote class="blockquote-center">
              
                The article is finished. If you have any questions, please comment and communicate.
              
            <br/>
            
                <div class="qr-code" onclick="return false">
                    <script src="/js/qrcode.min.js"></script>
                    <div id="qrcode">
                      
                        <img src="https://imzlp.com/images/wechat-qrcode.webp">
                      
                    <p>Scan the QR code on WeChat and follow me.</p>
                    </div>
                </div>
            
            </blockquote>
          
        

        
          <div class="postCopyright" style="clear:both;">
             <span>Title:</span><a href="/posts/19242/" target="_blank">Some excerpts from the C/C++ standard</a><br/>
             <span>Author:</span><a href="/about" target="_blank" title="查看 LIPENGZHA 的资料">LIPENGZHA</a><br/>
             <span>Publish Date:</span>2016/11/12 01:19<br/>
             
              <span>Update Date:</span>2017/04/05 15:19<br/>
             
             <span>Word Count:</span><span class="page-count">49k Words</span><br/>
             
             <span>Link:</span><a href="/posts/19242/" target="_blank" title="Some excerpts from the C/C++ standard">https://en.imzlp.com/posts/19242/</a>
             <span class="copy-path" data-clipboard-text="Link: https://en.imzlp.com/posts/19242/ Author: LIPENGZHA" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
             <script src="/js/jquery.min.js"></script>
             <script src="/js/clipboard.min.js"></script>
             <script> var clipboard = new Clipboard('.copy-path'); </script>
             <br/>
             
             <span>License:</span><i class="fab fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">CC BY-NC-SA 4.0</a><br/>
             
             <span>Reprinting of the full article is prohibited.</span>
          </div>
        
    

        
  <div class="reward-container">
    <div>Your donation will encourage me to keep creating!</div>
    <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
      Donate
    </button>
    <div id="qr" style="display: none;">
        
        <div style="display: inline-block;">
          <img src="/images/reward/wechatpay.webp" alt="LIPENGZHA WeChat Pay">
          <p>WeChat Pay</p>
        </div>

    </div>
  </div>



      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E6%A0%87%E5%87%86%E8%A7%A3%E8%AF%BB/" rel="tag"># 标准解读</a>
              <a href="/tags/C-%E6%A0%87%E5%87%86/" rel="tag"># C++标准</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/409/" rel="prev" title="TC++PL4E Chinese and English Edition Errata">
      <i class="fa fa-chevron-left"></i> TC++PL4E Chinese and English Edition Errata
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/10205/" rel="next" title="Some interesting questions and analysis of CppQuiz">
      Some interesting questions and analysis of CppQuiz <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-utteranc">utteranc</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane utteranc" id="comment-utteranc">
              
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="hxhb/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#exit-behavior"><span class="nav-number">1.</span> <span class="nav-text">exit() behavior</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#return-statement"><span class="nav-number">2.</span> <span class="nav-text">return statement</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#non-deduced-context"><span class="nav-number">3.</span> <span class="nav-text">non-deduced context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA%E6%97%B6%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">异常抛出时的构造和析构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E6%97%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">对象析构时的执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E6%97%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">6.</span> <span class="nav-text">对象构造时的执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">7.</span> <span class="nav-text">类的内置类型数据成员初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Undefined-Behavior"><span class="nav-number">8.</span> <span class="nav-text">Undefined Behavior</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F"><span class="nav-number">9.</span> <span class="nav-text">求值顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AD%E5%8C%85-closure"><span class="nav-number">10.</span> <span class="nav-text">闭包(closure)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lvalue-and-rvalue"><span class="nav-number">11.</span> <span class="nav-text">Lvalue and rvalue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%B8%8D%E5%85%81%E8%AE%B8int-gt-double%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">12.</span> <span class="nav-text">{}构造不允许int-&gt;double的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#char%E5%B8%A6%E4%B8%8D%E5%B8%A6%E7%AC%A6%E5%8F%B7%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%AE%9A%E4%B9%89"><span class="nav-number">13.</span> <span class="nav-text">char带不带符号由实现定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%8D%E4%BE%8B"><span class="nav-number">14.</span> <span class="nav-text">默认参数的几个反例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">15.</span> <span class="nav-text">对象的几种初始化方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zero-initialize"><span class="nav-number">16.</span> <span class="nav-text">zero-initialize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#default-initialize"><span class="nav-number">17.</span> <span class="nav-text">default-initialize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#value-initialize"><span class="nav-number">18.</span> <span class="nav-text">value-initialize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Initialization-of-non-local-variables"><span class="nav-number">19.</span> <span class="nav-text">Initialization of non-local variables</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Increment-and-decrement-prefix-and-postfix"><span class="nav-number">20.</span> <span class="nav-text">Increment and decrement(prefix and postfix)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Argument-dependent-name-lookup-ADL"><span class="nav-number">21.</span> <span class="nav-text">Argument-dependent name lookup(ADL)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sizeof-non-member-class"><span class="nav-number">22.</span> <span class="nav-text">sizeof(non-member-class)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Derived-class-array-conversion-to-base-class-pointer-and-subsequent-arithmetic-operations"><span class="nav-number">23.</span> <span class="nav-text">Derived class array conversion to base class pointer and subsequent arithmetic operations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#copy-assignment-operator"><span class="nav-number">24.</span> <span class="nav-text">copy assignment operator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Do-not-expect-polymorphic-behavior-when-calling-virtual-functions-from-a-base-class-constructor"><span class="nav-number">25.</span> <span class="nav-text">Do not expect polymorphic behavior when calling virtual functions from a base class constructor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lifetimes-of-objects"><span class="nav-number">26.</span> <span class="nav-text">lifetimes of objects</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Giving-temporary-objects-extended-lifetimes-with-const-T-amp"><span class="nav-number">27.</span> <span class="nav-text">Giving temporary objects extended lifetimes with const T&amp;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Point-of-declaration"><span class="nav-number">28.</span> <span class="nav-text">Point of declaration</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#declaration-and-define"><span class="nav-number">29.</span> <span class="nav-text">declaration and define</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#template-default-arguments"><span class="nav-number">30.</span> <span class="nav-text">template default arguments</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-object-initialized-of-C"><span class="nav-number">31.</span> <span class="nav-text">static object initialized of C</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#compound-literal-of-C"><span class="nav-number">32.</span> <span class="nav-text">compound literal of C</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#noreturn-attribute"><span class="nav-number">33.</span> <span class="nav-text">[[noreturn]] attribute</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#five-ways-of-exiting-a-function"><span class="nav-number">34.</span> <span class="nav-text">five ways of exiting a function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Integer-float-literal-types"><span class="nav-number">35.</span> <span class="nav-text">Integer&#x2F;float literal types</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Differences-in-sizeof-computation-periods-in-C-and-C"><span class="nav-number">36.</span> <span class="nav-text">Differences in sizeof computation periods in C and C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Relationship-between-C-and-C-Differences-in-logical-operator-results"><span class="nav-number">37.</span> <span class="nav-text">Relationship between C and C++ &#x2F; Differences in logical operator results</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Relational-operators"><span class="nav-number">38.</span> <span class="nav-text">Relational operators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Equality-operators"><span class="nav-number">39.</span> <span class="nav-text">Equality operators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Conditional-expressions"><span class="nav-number">40.</span> <span class="nav-text">Conditional expressions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logical-operator"><span class="nav-number">41.</span> <span class="nav-text">Logical operator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deleting-an-object-not-created-by-new-expressions"><span class="nav-number">42.</span> <span class="nav-text">Deleting an object not created by new expressions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-Library-memory-management-functions-do-not-call-new-delete"><span class="nav-number">43.</span> <span class="nav-text">C Library memory management functions do not call new&#x2F;delete</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-names-are-not-pointers"><span class="nav-number">44.</span> <span class="nav-text">Array names are not pointers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-and-ISO-C"><span class="nav-number">45.</span> <span class="nav-text">C++ and ISO C</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compatibility-features-in-the-C-11-standard"><span class="nav-number">46.</span> <span class="nav-text">Compatibility features in the C++11 standard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Wild-Pointer-and-Dangling-Pointer"><span class="nav-number">47.</span> <span class="nav-text">Wild Pointer and Dangling Pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trivial-default-constructor"><span class="nav-number">48.</span> <span class="nav-text">Trivial default constructor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Raw-string-literal"><span class="nav-number">49.</span> <span class="nav-text">Raw string literal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Placement-syntax"><span class="nav-number">50.</span> <span class="nav-text">Placement syntax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Overriding-functions-do-not-override-their-original-default-parameters"><span class="nav-number">51.</span> <span class="nav-text">Overriding functions do not override their original default parameters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Static-is-thread-safe-initialization"><span class="nav-number">52.</span> <span class="nav-text">Static is thread-safe initialization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Non-local-static-initialization"><span class="nav-number">53.</span> <span class="nav-text">Non-local static initialization</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Order-of-evaluation-of-function-parameters"><span class="nav-number">54.</span> <span class="nav-text">Order of evaluation of function parameters</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VLA-cannot-have-initializers"><span class="nav-number">55.</span> <span class="nav-text">VLA cannot have initializers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Template-appearing-on-the-right-side-of-gt-and"><span class="nav-number">56.</span> <span class="nav-text">Template appearing on the right side of .&#x2F;-&gt; and ::</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What-is-Object-in-C-Standard"><span class="nav-number">57.</span> <span class="nav-text">What is Object in C++ Standard?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Description-of-polymorphism-in-the-C-Standard-C-14"><span class="nav-number">58.</span> <span class="nav-text">Description of polymorphism in the C++ Standard (C++14)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class-object-size"><span class="nav-number">59.</span> <span class="nav-text">Class object size</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References-are-not-pointers"><span class="nav-number">60.</span> <span class="nav-text">References are not pointers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Type-of-this"><span class="nav-number">61.</span> <span class="nav-text">Type of this</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Differences-between-typedef-and-using"><span class="nav-number">62.</span> <span class="nav-text">Differences between typedef and using</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic-cast-failure"><span class="nav-number">63.</span> <span class="nav-text">dynamic_cast failure</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation-defined-behavior"><span class="nav-number">64.</span> <span class="nav-text">Implementation-defined behavior</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Name-hiding"><span class="nav-number">65.</span> <span class="nav-text">Name hiding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Several-ways-to-implement-abstract-base-classes"><span class="nav-number">66.</span> <span class="nav-text">Several ways to implement abstract base classes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pointer-comparison-behavior"><span class="nav-number">67.</span> <span class="nav-text">Pointer comparison behavior</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#subobjects-in-C"><span class="nav-number">68.</span> <span class="nav-text">subobjects in C++</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person" oncontextmenu="return false" οndragstart="return false">
    <img class="site-author-image" itemprop="image" alt="LIPENGZHA"
      src="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
  <p class="site-author-name" itemprop="name">LIPENGZHA</p>
  <div class="site-description" itemprop="description">"I think, therefore I am"</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
             
          <span class="site-state-item-count">190</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">95</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">190</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxhb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxhb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/lipengzha" title="Linkedin → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;lipengzha" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/imzlp" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;imzlp" rel="noopener" target="_blank"><i class="fa fa-custom zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat-qrcode-offical.webp" title="微信公众号 → &#x2F;images&#x2F;wechat-qrcode-offical.webp"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imzlp@foxmail.com" title="E-Mail → mailto:imzlp@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://consolehelp.imzlp.com/" title="https:&#x2F;&#x2F;consolehelp.imzlp.com&#x2F;" rel="noopener" target="_blank">UE Console Help</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/opensource/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;opensource&#x2F;" rel="noopener" target="_blank">Open Source Projects</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/posts/11515/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;posts&#x2F;11515&#x2F;" rel="noopener" target="_blank">UE C++ API Dash Documents</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ue5wiki.com/" title="https:&#x2F;&#x2F;ue5wiki.com&#x2F;" rel="noopener" target="_blank">Unreal Engine Wiki</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LIPENGZHA</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.5m</span>
</div>
  <div class="powered-by-other">
    
	    <center>Github Pages | Actions | NeXT | Cloudflare | Hexo Deploy</center>
      
  </div>

<script>
function checkWebp(callback) {
    var img = new Image();
    img.onload = function () { callback((img.width > 0) && (img.height > 0)); };
    img.onerror = function () { callback(false); };
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
}
function showImage(useWebp) {
    var imgs = [].slice.call(document.querySelectorAll('img'));
    imgs.forEach(function (e) {
        if (!useWebp) {
            var src = e.getAttribute('data-src')
            src = src.replace(/\.webp$/, '.png');
            e.setAttribute('data-src', src);
        }
    });
}
checkWebp(showImage);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animejs/3.2.1/anime.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.5.1/jquery.min.js"></script>
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



<script src="/js/code-unfold.js"></script>

  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  
  <script src="//img.imzlp.com/imgs/zlp/picgo/2021/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://en.imzlp.com/posts/19242/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    var requiredFields = 'nick';
    requiredFields = requiredFields.split(',');
    
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oCE6RMVkVoi5MgUhvFsn1EvV-gzGzoHsz',
      appKey     : 'K9SOaNYJ8PV6xaoFggWG5xvv',
      placeholder: "Leave something behind~",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields: requiredFields
    });
  }, window.Valine);
});
</script>

</body>
</html>
