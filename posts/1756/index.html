<!DOCTYPE html>
<html lang="en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-tilt-brush.png">
  <link rel="mask-icon" href="/images/favicon-32x32-tilt-brush.png" color="#222">
  <meta name="google-site-verification" content="ttIkhAIFZQM9Huj8roB0l95ePN2Tv2zv2wRFksi09WA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Pacifico:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"en.imzlp.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"width":280},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"code_unfold":{"enable":true,"CODE_MAX_HEIGHT":600},"path":"search.xml"};
  </script>

  <meta name="description" content="Some examples in C++ that can be confusing or have peculiar usages are recorded.">
<meta property="og:type" content="article">
<meta property="og:title" content="Programming skills and concepts in C&#x2F;C++">
<meta property="og:url" content="https://en.imzlp.com/posts/1756/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="Some examples in C++ that can be confusing or have peculiar usages are recorded.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/1756/wsign_conversion_00.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/1756/wsign_conversion_01.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/1756/struct_circle.webp">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/1756/struct_square.webp">
<meta property="article:published_time" content="2017-03-05T01:21:25.000Z">
<meta property="article:modified_time" content="2017-04-28T07:53:38.000Z">
<meta property="article:author" content="LIPENGZHA">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="编程技巧">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/1756/wsign_conversion_00.webp">

<link rel="canonical" href="https://en.imzlp.com/posts/1756/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Programming skills and concepts in C/C++ | Z's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDCJ41EFP5"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FDCJ41EFP5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Z's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-edit fa-fw"></i>Notes</a>

  </li>


      
        
            
  <li class="menu-item menu-item-essay">

    <a href="/essay/" rel="section"><i class="fas fa-feather-alt fa-fw"></i>Essay</a>

  </li>


      
        
            
  <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-inbox fa-fw"></i>Resources</a>

  </li>


      
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fas fa-link fa-fw"></i>Friends</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me</a>

  </li>


      
        <li class="menu-item menu-item-showcase">

    <a href="/showcase/" rel="section"><i class="fa fa-solid fa-trophy fa-fw"></i>ShowCase</a>

  </li>
        <li class="menu-item menu-item-changelog">

    <a href="/changelog/" rel="section"><i class="fa fa-history fa-fw"></i>Site Log</a>

  </li>
        <li class="menu-item menu-item-opensource">

    <a href="/opensource/" rel="section"><i class="fas fa-code-branch fa-fw"></i>Open Source</a>

  </li>
        <li class="menu-item menu-item-uewiki">

    <a href="https://ue5wiki.com/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>Unreal Wiki</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>



<script type="text/javascript">
  let domain='en.imzlp.com';
  let domain_str = atob(domain);
  let pathname = location.pathname;
  if (domain_str!= location.host.toLowerCase()){
        console.log(`this host is not safe,jump to https://${domain_str}${pathname}`);
        location.href=`https://${domain_str}${pathname}`;
  }
</script>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <div class="l10n-header-widget">
    <script>
      // 获取当前页面的 URL
      const currentUrl = window.location.href;
      // 替换 URL 中的部分内容
      const jumpToL10nLink = currentUrl.replace('en.imzlp.com', 'imzlp.com');
      // 将 jumpToL10nLink 绑定到一个全局变量
      window.jumpToL10nLink = jumpToL10nLink;
    </script>

    <a href="#" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: none;" rel="noopener" target="_blank" onclick="window.open(window.jumpToL10nLink, '_blank'); return false;">
      <i class="fa fa-solid fa-language"></i>
    </a>
  </div>



    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en"
  >
    <link itemprop="mainEntityOfPage" href="https://en.imzlp.com/posts/1756/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
      <meta itemprop="name" content="LIPENGZHA">
      <meta itemprop="description" content=""I think, therefore I am"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Programming skills and concepts in C/C++<a href="https://github.com/imzlp/blog-md/blob/en/_posts/2017-03-05-1756.md" class="post-edit-link" title="Edit this post" style="float: right;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a><a href="https://imzlp.com/posts/1756/" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-solid fa-language"></i></a>
        </h1>

        
          <div class="post-subtitle" style="text-align: center;line-height: 1;">
            <sub text-align="center" style="font-size: 15px;align-content: center;font-style: italic;bottom: 0em;">C/C++中的编程技巧及其概念</sub>
          </div>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-05 01:21 01:21:25:21" itemprop="dateCreated datePublished" datetime="2017-03-05T01:21:25+00:00">2017-03-05 01:21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2017-04-28 07:53 07:53:38:53" itemprop="dateModified" datetime="2017-04-28T07:53:38+00:00">2017-04-28 07:53</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">编程技巧</span></a>
                </span>
            </span>

          
            <span id="/posts/1756/" class="post-meta-item leancloud_visitors" data-flag-title="Programming skills and concepts in C/C++" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>49 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Some examples in C++ that can be confusing or have peculiar usages are recorded.</p>
<span id="more"></span>

<h3 id="Explicitly-Qualified-Number-of-Elements-for-Array-Arguments"><a href="#Explicitly-Qualified-Number-of-Elements-for-Array-Arguments" class="headerlink" title="Explicitly Qualified Number of Elements for Array Arguments"></a>Explicitly Qualified Number of Elements for Array Arguments</h3><p>When an array is passed as a function parameter, it decays to a pointer:</p>
<blockquote>
<p>A declaration of a parameter as “array of type” shall be adjusted to “qualified pointer to type”.</p>
</blockquote>
<p>And as mentioned earlier:</p>
<blockquote>
<p><code>int x[3][5];</code>Here x is a 3 × 5 array of integers. When x appears in an expression, it is converted to a pointer to (the first of three) five-membered arrays of integers.</p>
</blockquote>
<p>This means that when passing an array as a parameter, the bounds will be lost (C/C++ native arrays don’t have boundary checks either…).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">(<span class="type">int</span> x[<span class="number">10</span>])</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">// Equivalent to</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">(<span class="type">int</span> *x)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>The corresponding intermediate code is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">define <span class="type">void</span> @_Z5funcAPi(i32*) #<span class="number">4</span> &#123;</span><br><span class="line">  %<span class="number">2</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line">  store i32* %<span class="number">0</span>, i32** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  ret <span class="type">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">define <span class="type">void</span> @_Z5funcBPi(i32*) #<span class="number">4</span> &#123;</span><br><span class="line">  %<span class="number">2</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line">  store i32* %<span class="number">0</span>, i32** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  ret <span class="type">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If the precise value of the array bounds is very important, and you want the function to only accept arrays containing a specific number of elements, you can use reference parameters:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcC</span><span class="params">(<span class="type">int</span> (&amp;x)[<span class="number">10</span>])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>The intermediate code is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">; Function Attrs: nounwind uwtable</span><br><span class="line">define <span class="type">void</span> @_Z5funcCRA10_i([<span class="number">10</span> x i32]* <span class="built_in">dereferenceable</span>(<span class="number">40</span>)) #<span class="number">4</span> &#123;</span><br><span class="line">  %<span class="number">2</span> = alloca [<span class="number">10</span> x i32]*, align <span class="number">8</span></span><br><span class="line">  store [<span class="number">10</span> x i32]* %<span class="number">0</span>, [<span class="number">10</span> x i32]** %<span class="number">2</span>, align <span class="number">8</span></span><br><span class="line">  ret <span class="type">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we use an array with a number of elements not equal to 10 to pass to <code>funcC</code>, it will result in a compilation error:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// note: candidate function not viable: no known conversion from &#x27;int [11]&#x27; to &#x27;int (&amp;)[10]&#x27; for 1st argument.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcC</span><span class="params">(<span class="type">int</span> (&amp;x)[<span class="number">10</span>])</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> x[<span class="number">11</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">  <span class="comment">// error: no matching function for call to &#x27;funcC&#x27;.</span></span><br><span class="line">  <span class="built_in">funcC</span>(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can also use function template parameters to specify the size of the array parameters the function accepts:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="type">int</span> arrSize&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcA</span><span class="params">(<span class="type">int</span> x[arrSize])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Usage:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[<span class="number">12</span>];</span><br><span class="line"><span class="built_in">funcA</span>&lt;<span class="number">12</span>&gt;(x); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">funcA</span>&lt;<span class="number">13</span>&gt;(x); <span class="comment">//ERROR</span></span><br></pre></td></tr></table></figure>

<h3 id="Enabling-Compiler-Warnings-for-Implicit-Type-Conversions-Changing-Sign"><a href="#Enabling-Compiler-Warnings-for-Implicit-Type-Conversions-Changing-Sign" class="headerlink" title="Enabling Compiler Warnings for Implicit Type Conversions Changing Sign"></a>Enabling Compiler Warnings for Implicit Type Conversions Changing Sign</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">4</span>&lt;(<span class="type">unsigned</span> <span class="type">int</span>)(<span class="type">int</span>)<span class="number">-1</span>)&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The expression in the if statement is true (outputs yes), and no warning will be issued at compile time.</p>
<p> <img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/1756/wsign_conversion_00.webp"></p>
<p>Even though we specified <code>(int)-1</code>, there will be an implicit conversion when comparing <code>unsigned int</code> and <code>int</code>. That is:</p>
<blockquote>
<p>The usual arithmetic conversions are performed on operands of arithmetic or enumeration type.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">4</span>&lt;(<span class="type">unsigned</span>)(<span class="type">int</span>)<span class="number">-1</span>)==<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless -Wsign-conversion is explicitly enabled.</p>
</blockquote>
<p>By enabling <code>-Wsign-conversion</code>, the warning can be seen (it is recommended to enable it).<br>The effect of this option is:</p>
<blockquote>
<p>Warn for implicit conversions that may change the sign of an integer value, like assigning a signed integer expression to an unsigned integer variable. An explicit cast silences the warning. In C, this option is enabled also by -Wconversion.</p>
</blockquote>
<p> <img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/1756/wsign_conversion_01.webp"></p>
<p>For more GCC warning options, you can check here <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html">Warning-Options</a></p>
<h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><p>assert Defined in header <cassert>(c++)/&lt;assert.h&gt;(C)</p>
<blockquote>
<p>If NDEBUG is defined as a macro name at the point in the source code where &lt;assert.h&gt; is included, then assert does nothing.<br>If NDEBUG is not defined, then assert checks if its argument (which must have scalar type) compares equal to zero.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(condition) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> assert(condition) <span class="comment">/*implementation defined*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/error/assert">cppreference - assert</a><br>assert is only effective in debug mode; using it in release mode does nothing.<br>Because in VC++, release will globally define NDEBUG</p>
<p>The following code will compile and input a number &gt;100 in VS with different results in debug and release mode (release will not).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  cin &gt;&gt; i;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">func</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Invalid-References"><a href="#Invalid-References" class="headerlink" title="Invalid References"></a>Invalid References</h3><p>Typically, the references we create are valid, but they can also be rendered invalid due to human factors…</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">ident</span><span class="params">(<span class="type">char</span> *p)</span> </span>&#123; <span class="keyword">return</span> p; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span>&amp; r &#123;*<span class="built_in">ident</span>(<span class="literal">nullptr</span>)&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This leads to undefined behavior.</p>
<blockquote>
<p>In particular, a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the “object” obtained by indirection through a null pointer, which causes undefined behavior.</p>
</blockquote>
<h3 id="References-to-Arrays"><a href="#References-to-Arrays" class="headerlink" title="References to Arrays"></a>References to Arrays</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>(&amp;r)[<span class="number">4</span>])</span></span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="built_in">sizeof</span>(r)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">f</span>(a); <span class="comment">// OK</span></span><br><span class="line">  <span class="type">int</span> b[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="built_in">f</span>(b); <span class="comment">// Error, number of elements is incorrect</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For reference types of array parameters, the number of elements is also part of its type. Typically, references to arrays are only used in templates, where references can be inferred from the array.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T,<span class="type">int</span> N&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T(&amp;r)[N])</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a1[<span class="number">10</span>];</span><br><span class="line"><span class="type">double</span> a2[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(a1);  <span class="comment">// T is int, N is 10</span></span><br><span class="line">  <span class="built_in">f</span>(a2);  <span class="comment">// T is double, N is 100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The consequence is that the more different types of arrays used to call f(), the more corresponding functions are defined.</p>
<h3 id="Ignoring-Top-Level-cv-qualifier-of-Function-Parameters"><a href="#Ignoring-Top-Level-cv-qualifier-of-Function-Parameters" class="headerlink" title="Ignoring Top-Level cv-qualifier of Function Parameters"></a>Ignoring Top-Level cv-qualifier of Function Parameters</h3><p>For compatibility with C, C++ automatically ignores the top-level cv-qualifier of the parameter type.</p>
<p>For example, the following function would report a redefinition error in C++, rather than an overload:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Type is int(int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error: redefinition of &#x27;f&#x27;</span></span><br><span class="line"><span class="comment">// Type is int(int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>In either case, whether allowing or not allowing modification of the actual parameter, it is merely a copy of the actual argument provided by the function caller. Therefore, the calling process will not violate the data safety of the calling context.<br>The signature rule for functions is as follows:</p>
<blockquote>
<p><code>&lt;function&gt;</code> name, parameter type list (8.3.5), and enclosing namespace (if any)</p>
</blockquote>
<p>And the function’s <code>parameter-type-list</code> will remove the <code>top-level cv-qualifier</code>:</p>
<blockquote>
<p>[ISO/IEC 14882:2014 <strong>§8.3.5.5</strong>]After producing the list of parameter types, any top-level cv-qualifiers modifying a parameter type are deleted when forming the function type. The resulting list of transformed parameter types and the presence or absence of the ellipsis or a function parameter pack is the function’s <code>parameter-type-list</code>.</p>
</blockquote>
<h3 id="Be-Careful-with-signed-unsigned-when-using-char-as-an-array-index"><a href="#Be-Careful-with-signed-unsigned-when-using-char-as-an-array-index" class="headerlink" title="Be Careful with signed/unsigned when using char as an array index"></a>Be Careful with signed/unsigned when using char as an array index</h3><p>When the char type is used as an array index, it should first be converted to <code>unsigned char</code> (since <code>char</code> is usually signed (implementation-defined)). It cannot be directly converted to <code>int</code> or <code>unsigned int</code>, or it will lead to array index out of bounds.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> ch=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %u %d&quot;</span>, (<span class="type">int</span>)ch, (<span class="type">unsigned</span>)ch, (<span class="type">unsigned</span> <span class="type">char</span>)ch);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// -1 4294967295 255</span></span><br></pre></td></tr></table></figure>

<h3 id="struct-tag-5-float"><a href="#struct-tag-5-float" class="headerlink" title="struct tag (*[5])(float)"></a>struct tag (*[5])(float)</h3><p>The type designated as ‘struct tag (*[5])(float)’ has type ‘array of pointer to function returning struct tag’. The array has length five and the function has a single parameter of type float. Its type category is array.</p>
<h3 id="new-a-pointer-array"><a href="#new-a-pointer-array" class="headerlink" title="new a pointer array"></a>new a pointer array</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> TEN=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> A=<span class="built_in">new</span> (<span class="built_in">void</span>(*[TEN])(<span class="type">void</span>));</span><br><span class="line"><span class="keyword">delete</span>[] A;</span><br></pre></td></tr></table></figure>

<h3 id="Low-Level-const-and-Top-Level-const"><a href="#Low-Level-const-and-Top-Level-const" class="headerlink" title="Low-Level const and Top-Level const"></a>Low-Level const and Top-Level const</h3><p><strong>Low-Level const</strong>: Indicates that the object pointed to by the pointer is a constant.<br><strong>Top-Level const</strong>: Indicates that the pointer itself is constant. Top-Level const can indicate that any object is constant, which applies to any data type.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> ivalp_1=&amp;ival; <span class="comment">// cannot change ivalp_1&#x27;s value, this is a top-level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci=<span class="number">42</span>;  <span class="comment">// cannot change ci&#x27;s value, this is a top-level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *ivalp_2=&amp;ci;  <span class="comment">// allows changing ivalp_2&#x27;s value, this is a low-level const</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> ivalp_3=ivalp_2; <span class="comment">// right is top-level const, left is low-level const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ref=ci;  <span class="comment">// the const used for declaring references are all low-level const</span></span><br></pre></td></tr></table></figure>

<p>Actually, I have a simple method to distinguish: look at what is modified by const on the right.</p>
<ul>
<li>For <code>int const *x=std::nullput;</code>, const modifies <code>*x</code>, as x is a pointer, we temporarily regard <code>*x</code> as dereference, which represents the object pointed to by x, so it is <code>low-level const</code>.</li>
<li>Conversely, <code>int * const x=std::nullptr;</code>, as const modifies the pointer x, so it is <code>top-level const</code>.</li>
</ul>
<h3 id="Dangers-of-Passing-this-Pointer-in-Constructor"><a href="#Dangers-of-Passing-this-Pointer-in-Constructor" class="headerlink" title="Dangers of Passing this Pointer in Constructor"></a>Dangers of Passing this Pointer in Constructor</h3><p>If we pass the this pointer to other functions within a constructor, we could run into such problems:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">no_opt</span><span class="params">(C*)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	<span class="type">int</span> c;</span><br><span class="line">	<span class="built_in">C</span>() : <span class="built_in">c</span>(<span class="number">0</span>) &#123; <span class="built_in">no_opt</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The code above seems fine, but when we construct a <code>const C</code>, it could lead to the following issue:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> C cobj;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">no_opt</span><span class="params">(C* cptr)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i = cobj.c * <span class="number">100</span>; <span class="comment">// value of cobj.c is unspecified</span></span><br><span class="line">	cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">	cout &lt;&lt; cobj.c * <span class="number">100</span> <span class="comment">// value of cobj.c is unspecified</span></span><br><span class="line">	&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above code will compile successfully and can modify the constant object’s member <code>i</code> in <code>no_opt</code>.<br>Passing the this pointer of a constant object to other functions during construction means we could modify the values of the objects in that constant, which is not standard-compliant.</p>
<blockquote>
<p>During the construction of a const object, if the value of the object or any of its subobjects is accessed through a glvalue that is not obtained, directly or indirectly, from the constructor’s this pointer, the value of the object or subobject thus obtained is unspecified.</p>
</blockquote>
<p>Therefore, it’s best not to write anything that passes the this pointer outside the class in the constructor (it’s better to just initialize data members)…</p>
<h3 id="Get-the-Absolute-Path-of-the-Current-Executing-Program"><a href="#Get-the-Absolute-Path-of-the-Current-Executing-Program" class="headerlink" title="Get the Absolute Path of the Current Executing Program"></a>Get the Absolute Path of the Current Executing Program</h3><p>There are two methods:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;direct.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> buffer[MAXPATH];</span><br><span class="line"><span class="built_in">getcwd</span>(buffer, MAXPATH);</span><br><span class="line">cout&lt;&lt;buffer&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>This method has a drawback: if the executable program is added to the system PATH, it will obtain the path of the directory where it is executed.</p>
<p>Another method is through the Windows API:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string <span class="title">getTheProgramAbsPath</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    TCHAR exeFullPath[MAX_PATH]; <span class="comment">// MAX_PATH is defined in WINDEF.h, equal to 260</span></span><br><span class="line">    <span class="built_in">memset</span>(exeFullPath,<span class="number">0</span>,MAX_PATH);</span><br><span class="line">    <span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>,exeFullPath,MAX_PATH);</span><br><span class="line">    <span class="keyword">return</span> &#123;exeFullPath&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this way, irrespective of whether the program has been added to the system’s PATH or where it is executed, it will get the absolute path where this executable program is stored in the system.</p>
<h3 id="A-Quirky-Usage-of-using"><a href="#A-Quirky-Usage-of-using" class="headerlink" title="A Quirky Usage of using"></a>A Quirky Usage of using</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> foofunc=<span class="built_in">void</span>(<span class="type">int</span>);</span><br><span class="line">foofunc foo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the code above:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foofunc foo;</span><br></pre></td></tr></table></figure>
<p>is declaring a function foo; looking at the symbol information in the target file (omitting unrelated details):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ clang++ -c testusing.cc -o testusing.o -std=c++11</span><br><span class="line">$ llvm-nm testusing.o</span><br><span class="line">-------- U _Z3fooi</span><br><span class="line">-------- U __main</span><br><span class="line">-------- U atexit</span><br><span class="line">00000050 T main</span><br></pre></td></tr></table></figure>
<p>Through the <code>c++filt</code> toolchain in <strong>gcc</strong>, the symbols in the object file can be restored:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ c++filt _Z3fooi</span><br><span class="line">foo(int)</span><br></pre></td></tr></table></figure>
<p>However, it is not defined, and directly linking will produce an undefined error.</p>
<h3 id="Rvalue-References"><a href="#Rvalue-References" class="headerlink" title="Rvalue References"></a>Rvalue References</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;y=x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>The IR code is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Using value <span class="number">123</span> to initialize x</span><br><span class="line">%<span class="number">2</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">store i32 <span class="number">123</span>, i32* %<span class="number">2</span>, align <span class="number">4</span></span><br><span class="line"><span class="meta"># y</span></span><br><span class="line">%<span class="number">3</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line"># Storing the temporary object created by x+<span class="number">1</span></span><br><span class="line">%<span class="number">4</span> = alloca i32, align <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># Calculate x+<span class="number">1</span></span><br><span class="line">%<span class="number">5</span> = load i32, i32* %<span class="number">2</span>, align <span class="number">4</span></span><br><span class="line">%<span class="number">6</span> = add nsw i32 %<span class="number">5</span>, <span class="number">1</span></span><br><span class="line"><span class="meta"># x+1 creates a temporary value that is %4</span></span><br><span class="line">store i32 %<span class="number">6</span>, i32* %<span class="number">4</span>, align <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># Bind the address of the temporary value to %<span class="number">3</span> (y)</span><br><span class="line">store i32* %<span class="number">4</span>, i32** %<span class="number">3</span>, align <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>This realizes a non-copy behavior, which behaves similarly to assigning an object’s address to a pointer.<br>In fact, the purpose of rvalue references is to give temporary objects a longer lifespan—binding a reference to a temporary object without incurring any additional copy operations.<br>The same effect can be achieved with <code>const T&amp;</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">123</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;y=x+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>And the above example will generate identical IR code under LLVM.</p>
<h3 id="An-Array-Name-Example"><a href="#An-Array-Name-Example" class="headerlink" title="An Array Name Example"></a>An Array Name Example</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p=(<span class="type">int</span>*)(&amp;a+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,*(a+<span class="number">1</span>),*(p<span class="number">-1</span>));</span><br><span class="line"><span class="comment">// output: 2,5</span></span><br></pre></td></tr></table></figure>

<h3 id="How-Many-Passing-Methods-Are-There"><a href="#How-Many-Passing-Methods-Are-There" class="headerlink" title="How Many Passing Methods Are There?"></a>How Many Passing Methods Are There?</h3><p>Most people think there are the following three passing methods in C++ functions:</p>
<ul>
<li><strong>Pass by value</strong>: the value of the parameter is a copy of the actual parameter;</li>
<li><strong>Pass by reference</strong>: the parameter is an alias for the actual parameter;</li>
<li><strong>Pass by pointer</strong>: passing a pointer to the object to the parameter;</li>
</ul>
<p>In fact, in C++, there are only two passing methods: <strong>pass by value</strong>, <strong>pass by reference</strong>.<br>Because <strong>passing by pointer</strong> is also a type of <strong>pass by value</strong>, the parameter value is merely a copy of the actual argument; they are just both pointers.<br>In the father of C++’s book: <em>The C++ Programming Language 4th Edition</em>, it states:</p>
<blockquote>
<p>Unless a formal argument (parameter) is a reference, a copy of the actual argument is passed to the function.</p>
</blockquote>
<p><strong>Passing by pointer</strong> is merely a technique that utilizes the properties of <strong>pointers</strong> to avoid the overhead of copying, rather than a <strong>passing method</strong>.</p>
<h3 id="The-Three-Laws-of-Defining-Copy-Assign-and-Destructor-Functions"><a href="#The-Three-Laws-of-Defining-Copy-Assign-and-Destructor-Functions" class="headerlink" title="The Three Laws of Defining Copy/Assign and Destructor Functions"></a>The Three Laws of Defining Copy/Assign and Destructor Functions</h3><blockquote>
<p>If a class requires a user-defined copy constructor, copy assignment operator, or destructor, it typically needs all three.</p>
</blockquote>
<p>The compiler-generated implicit definitions of <code>copy constructor</code> and <code>operator=</code> have a memberwise copy semantic, so if the operations generated by the compiler cannot meet the class’s copying needs (for instance, if class members are handles managing some resources), using the compiler’s implicit definitions will lead to <strong>shallow copies</strong>, causing two objects to enter some shared state.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="built_in">A</span>():<span class="built_in">memory</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">getMemory</span><span class="params">(std::<span class="type">size_t</span> memSize)</span></span>&#123;</span><br><span class="line">    memory=(<span class="type">char</span>*)<span class="built_in">malloc</span>(memSize);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">A</span>()&#123; <span class="built_in">free</span>(memory); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">char</span>* memory;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  A x;</span><br><span class="line">  x.<span class="built_in">getMemory</span>(<span class="number">12</span>);</span><br><span class="line">  A y;</span><br><span class="line">  y=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If the compiler-generated semantics are used, it would make objects x and y internally share a block of memory, so the user needs to define the copy constructor and copy assignment operator. For the same reason, when class members hold some resources, a user-defined destructor is also necessary.</p>
<h3 id="Implementation-of-References"><a href="#Implementation-of-References" class="headerlink" title="Implementation of References"></a>Implementation of References</h3><p>The C++ standard explains references like this:</p>
<blockquote>
<p><strong>[ISO/IEC 14882:2014 §8.3.2]</strong> A reference can be thought of as a name of an object.</p>
</blockquote>
<p>However, the standard doesn’t require how this reference behavior should be implemented (which is often seen in the standard), but most compilers implement it using pointers in practice.<br>Consider the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> &amp;ra=a;</span><br><span class="line"><span class="type">int</span> *pc=&amp;a;</span><br></pre></td></tr></table></figure>
<p>Then compiling it to LLVM-IR to see the actual behavior of the compiler:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">2</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">%<span class="number">3</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line">%<span class="number">4</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line"></span><br><span class="line">store i32 <span class="number">123</span>, i32* %<span class="number">2</span>, align <span class="number">4</span></span><br><span class="line">store i32* %<span class="number">2</span>, i32** %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line">store i32* %<span class="number">2</span>, i32** %<span class="number">4</span>, align <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>It’s evident that pointers and references have the exact same behavior post-compilation.</p>
<h3 id="Appropriately-Using-Compiler-Generated-Operations"><a href="#Appropriately-Using-Compiler-Generated-Operations" class="headerlink" title="Appropriately Using Compiler-Generated Operations"></a>Appropriately Using Compiler-Generated Operations</h3><p>In <a target="_blank" rel="noopener" href="https://imzlp.com/posts/21790">Implicit Declarations and Functions of Special Member Functions</a>, it was mentioned that the compiler implicitly generates and defines the behavior of six kinds of special member functions.<br>Since the generated <code>copy constructor</code> and <code>copy assignment operator</code> both have a <code>memberwise</code> behavior, when the class we write can satisfy shallow copying (value semantics), there’s no need to write relevant operations at the expense, because the compiler-generated ones are just as good as your hand-written versions, and they are less error-prone.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">double</span> b=<span class="number">0.0</span>):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp;)=<span class="keyword">default</span>;</span><br><span class="line">  A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp;)=<span class="keyword">default</span>;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Although when you haven’t explicitly defined a <code>copy constructor</code> and <code>copy assignment operator</code>, the compiler will implicitly define them, it’s still better to manually use <code>=delete</code> to specify.<br>The compiler-generated version is exactly the same as the hand-written:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> a=<span class="number">0</span>,<span class="type">double</span> b=<span class="number">0.0</span>):<span class="built_in">x</span>(a),<span class="built_in">y</span>(b)&#123;&#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp; r)&#123;</span><br><span class="line">    x=r.x;</span><br><span class="line">    y=r.y;</span><br><span class="line">  &#125;</span><br><span class="line">  A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; r)&#123;</span><br><span class="line">    x=r.x;</span><br><span class="line">    y=r.y;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">double</span> y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>It’s obvious that hand-writing is prone to error; this behavior can be safely handed over to the compiler.</p>
<h3 id="Compressing-Capacity-and-Truly-Erasing-Elements-in-STL-Containers"><a href="#Compressing-Capacity-and-Truly-Erasing-Elements-in-STL-Containers" class="headerlink" title="Compressing Capacity and Truly Erasing Elements in STL Containers"></a>Compressing Capacity and Truly Erasing Elements in STL Containers</h3><p>Taken from <em>C++ Programming Standards: 101 Rules/Guidelines and Best Practices</em> Rule 82.</p>
<p><strong>Compressing Container Capacity:</strong> The swap trick</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; x&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(x).<span class="built_in">swap</span>(x); <span class="comment">// Compress to appropriate capacity</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(x); <span class="comment">// Erase all elements</span></span><br></pre></td></tr></table></figure>

<p><strong>Truly Deleting Elements:</strong> <code>std::remove</code> does not perform the delete operation<br>The <code>std::remove</code> algorithm in STL does not truly remove elements from containers. As <code>std::remove</code> belongs to <code>algorithm</code>, it only operates over iterator ranges, not invoking container’s member functions, hence it cannot actually delete elements from containers.<br>Let’s take a look at the implementation in SGISTL (the implementation is a bit old and does not utilize <code>std::move</code>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> _InputIter <span class="title">find</span><span class="params">(_InputIter __first, _InputIter __last, <span class="type">const</span> _Tp&amp; __val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (__first != __last &amp;&amp; !(*__first == __val))</span><br><span class="line">    ++__first;</span><br><span class="line">  <span class="keyword">return</span> __first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_InputIter</span>, <span class="keyword">class</span> <span class="title class_">_OutputIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function">_OutputIter <span class="title">remove_copy</span><span class="params">(_InputIter __first, _InputIter __last, _OutputIter __result, <span class="type">const</span> _Tp&amp; __value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; __first != __last; ++__first)</span><br><span class="line">    <span class="keyword">if</span> (!(*__first == __value)) &#123;</span><br><span class="line">      *__result = *__first;</span><br><span class="line">      ++__result;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> __result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_ForwardIter</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function">_ForwardIter <span class="title">remove</span><span class="params">(_ForwardIter __first, _ForwardIter __last, <span class="type">const</span> _Tp&amp; __value)</span> </span>&#123;</span><br><span class="line">  __first = <span class="built_in">find</span>(__first, __last, __value);</span><br><span class="line">  _ForwardIter __i = __first;</span><br><span class="line">  <span class="keyword">return</span> __first == __last ? __first : <span class="built_in">remove_copy</span>(++__i, __last, __first, __value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can see they are merely moving elements’ positions, not actually deleting the elements; they simply move the elements that should not be deleted to the front of the container, then return the new ending position iterator.<br>Effectively, the deleted portion is moved to the back of the element, so to <strong>truly delete</strong> all matching elements from the container, the <em>erase-remove</em> idiom needs to be used:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.<span class="built_in">erase</span>(std::<span class="built_in">remove</span>(c.<span class="built_in">begin</span>(),c.<span class="built_in">end</span>(),value),c.<span class="built_in">end</span>()); <span class="comment">// Deletes elements at the tail of the container after std::remove</span></span><br></pre></td></tr></table></figure>

<h3 id="Beware-of-Hiding-Overloaded-Functions-in-Base-Classes"><a href="#Beware-of-Hiding-Overloaded-Functions-in-Base-Classes" class="headerlink" title="Beware of Hiding Overloaded Functions in Base Classes"></a>Beware of Hiding Overloaded Functions in Base Classes</h3><p>If there is a virtual function <code>func</code> in the base class but it also overloads several non-virtual functions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A::func()&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A::func(int)&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span>)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A::func(double)&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B::func()&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If we want to use the non-virtual version of the func function inside a B object:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B x;</span><br><span class="line"><span class="comment">// error: too many arguments to function call, expected 0, have 1</span></span><br><span class="line">x.<span class="built_in">func</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<p>This is because when the derived class overrides the base class virtual function, it hides the other overloaded functions, which needs to be explicitly brought into scope in B:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;B::func()&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Bring in the overloaded functions from A::func</span></span><br><span class="line">  <span class="keyword">using</span> A::func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Macro-Alternatives"><a href="#Macro-Alternatives" class="headerlink" title="Macro Alternatives"></a>Macro Alternatives</h3><p>Macros are replaced in the preprocessing stage, at which point C++’s syntax and semantic rules are not yet effective; thus, macros can only perform simple text replacement, making them extremely blunt tools.<br>Macros are almost never required in C++. You can define understandable constants using const and enum. Use inline to avoid the overhead of function calls, templates to specify series of functions and types, and namespaces to avoid name conflicts.<br>Unless used for conditional compilation, there is no legitimate reason to use macros in C++.</p>
<h3 id="Class-Memory-Allocation-Functions"><a href="#Class-Memory-Allocation-Functions" class="headerlink" title="Class Memory Allocation Functions"></a>Class Memory Allocation Functions</h3><p>In C++, memory allocation functions for classes are all static member functions:</p>
<blockquote>
<p>Any allocation function for a class T is a static member (even if not explicitly declared static).</p>
</blockquote>
<p>This means <code>operator new</code>/<code>operator delete</code> and <code>operator new[]</code>/<code>operator delete[]</code> are implicitly declared as static member functions.</p>
<h3 id="Exception-Safety"><a href="#Exception-Safety" class="headerlink" title="Exception Safety"></a>Exception Safety</h3><ol>
<li>Destructors, operator new, operator delete must not throw exceptions.</li>
<li>Swap operations should not throw exceptions.</li>
<li>First do anything that may throw exceptions (but will not change important states of the object), and then end with operations that will not throw exceptions.</li>
<li>When an exception is thrown from a throw expression towards a catch clause, any function executing in the path must manage to clean up any resources they control before removing their activation record from the execution stack.</li>
<li>Do not insert code that might cause an early return, calls to functions that might throw exceptions, or other actions that will prevent the resource release at the end of the function.</li>
</ol>
<h3 id="cv-Versions-of-Pointers-to-Class-Member-Functions"><a href="#cv-Versions-of-Pointers-to-Class-Member-Functions" class="headerlink" title="cv Versions of Pointers to Class Member Functions"></a>cv Versions of Pointers to Class Member Functions</h3><p>If we have a class A with overloaded member functions func that differ only by whether the member function is const, how do we define a pointer to the member function separately?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span><span class="type">const</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;void func()const&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;void func()&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If we just create a pointer to A::func, it points to the non-const version.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(A::*funcP)()=&amp;A::func;</span><br></pre></td></tr></table></figure>
<p>To specify the const version, you must indicate const in the declaration:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(A::*funcConstP)()<span class="type">const</span>=&amp;A::func;</span><br></pre></td></tr></table></figure>
<p>For const A objects, use the const version, and for non-const A objects, use the non-const version; they cannot be mixed.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> A x;</span><br><span class="line">(x.*funcP)(); <span class="comment">// ERROR!</span></span><br><span class="line">(x.*funcConstP)(); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">A y;</span><br><span class="line">(y.*funcConstP)(); <span class="comment">// ERROR!</span></span><br><span class="line">(y.*funcP)(); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h3 id="Compare-Operation-Implementation-in-STL"><a href="#Compare-Operation-Implementation-in-STL" class="headerlink" title="Compare Operation Implementation in STL"></a>Compare Operation Implementation in STL</h3><p>Unlike C language macros, utilizing templates and predicates in C++ allows writing generic compare operations easily.<br>In a macro definition, care must be taken regarding parameter side effects, as macros are merely replacements, such as:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) a&gt;=b?a:b;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MAX</span>(--a,++b);</span><br><span class="line"><span class="comment">// Replaced with</span></span><br><span class="line">--a&gt;=++b?--a:++b;</span><br></pre></td></tr></table></figure>
<p>But this macro’s actual operation does not yield the behavior we expect.<br>Fortunately, in C++, we can avoid such ugly macro definitions using templates and also provide a custom predicate to realize our judgment behavior:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Compare</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b?<span class="literal">false</span>:<span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Compare&gt;</span></span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">max</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b, Compare comp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">comp</span>(a, b)) ? b : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Computational-Constructor"><a href="#Computational-Constructor" class="headerlink" title="Computational Constructor"></a>Computational Constructor</h3><p>In certain cases, creating a constructor can improve the execution efficiency of member functions.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">String</span>&#123;</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* init);</span><br><span class="line">  <span class="type">const</span> String <span class="keyword">operator</span>+(<span class="type">const</span> String&amp; l,<span class="type">const</span> String&amp; r)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(l.s_,r.s_);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* a,<span class="type">const</span> <span class="type">char</span>* b)&#123;</span><br><span class="line">    s_=<span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(a)+<span class="built_in">strlen</span>(b)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcat</span>(<span class="built_in">strcpy</span>(s_,a),b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> *s_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Using-Members-of-Its-Own-Type"><a href="#Using-Members-of-Its-Own-Type" class="headerlink" title="Using Members of Its Own Type"></a>Using Members of Its Own Type</h3><p>How can a member of a class access the current class type?<br>This can be written as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">base</span>&#123;</span><br><span class="line">  <span class="keyword">using</span> selfType=T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">foo</span>:<span class="keyword">public</span> base&lt;foo&lt;T&gt;&gt;&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>Though it has a somewhat forced feel…</p>
<h3 id="Random-Access-in-std-vector"><a href="#Random-Access-in-std-vector" class="headerlink" title="Random Access in std::vector"></a>Random Access in std::vector</h3><p><code>std::vector</code> allows random access because it overloads the <code>[]</code> operator and has <code>at</code> member function, thus typically we would have the following two ways:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp; x)</span></span>&#123;</span><br><span class="line">  x[<span class="number">0</span>];</span><br><span class="line">  x.<span class="built_in">at</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What are the differences between these two random access methods?</p>
<blockquote>
<p>Sequential container’s <code>at(size_type)</code> requires range checks.<br><strong>[ISO/IEC 14882:2014]</strong> The member function at() provides bounds-checked access to container elements. at() throws <code>out_of_range</code> if n &gt;= a.size().<br>However, the standard doesn’t impose any requirements on <code>operator[]</code>.</p>
</blockquote>
<p>Let’s take a look at some STL implementations (<a target="_blank" rel="noopener" href="https://www.sgi.com/tech/stl/download.html">SGISTL</a>) to see how <code>std::vector</code> implements <code>operator[size_type]</code> and <code>at(size_type)</code>:<br>First, the implementation of <code>at(size_type)</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation of at(size_type)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __STL_THROW_RANGE_ERRORS</span></span><br><span class="line"><span class="type">void</span> _M_range_check(size_type __n) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (__n &gt;= <span class="keyword">this</span>-&gt;<span class="built_in">size</span>())</span><br><span class="line">    __stl_throw_range_error(<span class="string">&quot;vector&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">reference <span class="title">at</span><span class="params">(size_type __n)</span></span></span><br><span class="line"><span class="function">  </span>&#123; _M_range_check(__n); <span class="keyword">return</span> (*<span class="keyword">this</span>)[__n]; &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">at</span><span class="params">(size_type __n)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123; _M_range_check(__n); <span class="keyword">return</span> (*<span class="keyword">this</span>)[__n]; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __STL_THROW_RANGE_ERRORS */</span></span></span><br></pre></td></tr></table></figure>
<p>Now look at the implementation of <code>operator[](size_type)</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation of operator[](size_type)</span></span><br><span class="line">reference <span class="keyword">operator</span>[](size_type __n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + __n); &#125;</span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type __n) <span class="type">const</span> &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + __n); &#125;</span><br></pre></td></tr></table></figure>
<p>As you can see, there is no range check in the random access of <code>operator[]</code>.<br>Thus the questions:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x[<span class="number">0</span>];</span><br><span class="line">x.<span class="built_in">at</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>These two differ in that if x is non-empty, the behavior is the same; if x is empty, <code>x.at(0)</code> would throw an <code>std::out_of_range</code> exception (as required by C++ standards), while <code>x[0]</code> would lead to undefined behavior.</p>
<h3 id="Note-the-Difference-Between-typedef-and-define"><a href="#Note-the-Difference-Between-typedef-and-define" class="headerlink" title="Note the Difference Between typedef and #define"></a>Note the Difference Between typedef and #define</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* INTPTR;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR2 int*</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  INTPTR i1,i2;</span><br><span class="line">  INTPTR2 i3,i4;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s directly see the IR code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">6</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line">%<span class="number">7</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line">%<span class="number">8</span> = alloca i32*, align <span class="number">8</span></span><br><span class="line">%<span class="number">9</span> = alloca i32, align <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>Note that %9 is not i32*, it’s an i32 object.<br>Because <code>#define</code> is merely a simple replacement at compile time, it expands during compilation as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR2 int*</span></span><br><span class="line">INTPTR2 i3,i4;</span><br><span class="line"><span class="comment">// Compile-time expansion</span></span><br><span class="line"><span class="type">int</span>* i3,i4;</span><br></pre></td></tr></table></figure>
<p>Thus, only i3 is of type <code>int*</code>, while i4 is of type <code>int</code>.</p>
<h3 id="Why-const-Object-Is-Not-a-Compile-Time-Constant"><a href="#Why-const-Object-Is-Not-a-Compile-Time-Constant" class="headerlink" title="Why const Object Is Not a Compile-Time Constant?"></a>Why const Object Is Not a Compile-Time Constant?</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> y[x]=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>This is permissible; during compiler optimization, x will be replaced directly with 10.<br>The intermediate code is as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">6</span> = alloca i32, align <span class="number">4</span></span><br><span class="line">%<span class="number">7</span> = alloca [<span class="number">10</span> x i32], align <span class="number">16</span></span><br><span class="line">store i32 <span class="number">10</span>, i32* %<span class="number">6</span>, align <span class="number">4</span></span><br><span class="line">%<span class="number">8</span> = bitcast [<span class="number">10</span> x i32]* %<span class="number">7</span> to i8*</span><br><span class="line">call <span class="type">void</span> @llvm.memset.p0i8.<span class="built_in">i64</span>(i8* %<span class="number">8</span>, i8 <span class="number">0</span>, i64 <span class="number">40</span>, i32 <span class="number">16</span>, i1 <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>It can be seen that %7’s allocation does not use %6, hence it does not depend on x, and this object is known at compile-time.<br>However, consider when we write:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> y=x;</span><br><span class="line"><span class="comment">// error: variable-sized object may not be initialized</span></span><br><span class="line"><span class="type">int</span> z[y]=&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>Here it’s because of compiler extensions, so C++ also supports VLA. But we can see that const cannot serve as a compile-time constant.</p>
<h3 id="Class-Query-in-Inheritance-Hierarchies"><a href="#Class-Query-in-Inheritance-Hierarchies" class="headerlink" title="Class Query in Inheritance Hierarchies"></a>Class Query in Inheritance Hierarchies</h3><p>In class inheritance hierarchies, several different derived classes may have the same base class; they might mutually inherit, resulting in several inherited levels. How do we check whether a certain derived class in a hierarchy inherits from a certain class?</p>
<p>We can use <code>dynamic_cast</code> to achieve our requirement. For an overview of C++ type conversions, you can check out my previous article: <a target="_blank" rel="noopener" href="https://imzlp.com/posts/27258/">A Detailed Analysis of Type Conversions in C++</a>. Here’s a description of <code>dynamic_cast</code> in the C++ standard (ISO/IEC 14882:2014):</p>
<blockquote>
<p>The result of the expression <code>dynamic_cast&lt;T&gt;(v)</code> is the result of converting the expression v to type T. T shall be a pointer or reference to a complete class type, or “pointer to cv void.” The dynamic_cast operator shall not cast away constness (5.2.11).</p>
</blockquote>
<p>If C is the class type to which T points or refers, the runtime check logically executes as follows:</p>
<ul>
<li>If, in the most derived object pointed (referred) to by v, v points (refers) to a public base class subobject of a C object, and if only one object of type C is derived from the subobject pointed (referred) to by v, the result points (refers) to that C object.</li>
<li>Otherwise, if v points (refers) to a public base class subobject of the most derived object, and the type of the most derived object has a base class of type C that is unambiguous and public, the result points (refers) to the C subobject of the most derived object.</li>
<li>Otherwise, the runtime check fails.</li>
</ul>
<blockquote>
<p>The value of a failed cast to pointer type is the null pointer value of the required result type. A failed cast to reference type throws an exception (15.1) of a type that would match a handler (15.3) of type <code>std::bad_cast</code> (18.7.2).</p>
</blockquote>
<p>Thus, we can execute <code>dynamic_cast</code> conversion on class pointers in inheritance hierarchies to check the conversion success, hence determining whether a certain class exists in a derived class hierarchy.<br>Here’s a code example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Roll</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">roll</span><span class="params">()</span></span>&#123;cout&lt;&lt;<span class="string">&quot;Roll:roll()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Roll</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span>:<span class="keyword">public</span> Shape,<span class="keyword">public</span> Roll&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Circle::draw&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">roll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Circle::roll()&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Circle</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Square</span>:<span class="keyword">public</span> Shape&#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Square::draw()&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">Square</span>()=<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Shape *a=<span class="keyword">new</span> Square;</span><br><span class="line">  Roll *b=<span class="built_in">dynamic_cast</span>&lt;Roll*&gt;(a);</span><br><span class="line">  <span class="keyword">if</span>(b!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> a;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: no</span></span><br></pre></td></tr></table></figure>
<p>From the code above, you can see the inheritance hierarchy of the <code>Circle</code> class:<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/1756/struct_circle.webp"><br>And the inheritance hierarchy of the <code>Square</code> class:<br><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/1756/struct_square.webp"></p>
<p>The above inheritance hierarchies are quite simple, but if we assume we are unaware of the specific inheritance hierarchies of <code>Circle</code> and <code>Square</code>, how do we determine whether <code>Square</code> contains a certain base class (like <code>Roll</code>)?<br>The solution, as mentioned above, is to utilize <code>dynamic_cast</code>! By converting to the class type that we want to check for in the hierarchy, if the conversion is successful, <code>dynamic_cast</code> returns a pointer converted from the source type to the target type; if it fails, it will return a null pointer (the reason for not using references is that we want to handle the potential threat of exceptions). This conversion is neither an upward nor downward conversion, but rather a lateral conversion. Hence, we need to check the object (pointer) returned by <code>dynamic_cast</code> to ascertain whether the detected type exists in the inheritance hierarchy.</p>
<p>However, I feel that this behavior applies only to very narrow scenarios and is rarely necessary in well-designed classes; if you feel overwhelmed by your class hierarchy, it is surely a poor design.</p>
<h3 id="In-list-initialization-the-initializer-list-constructor-takes-precedence-over-the-ordinary-constructor"><a href="#In-list-initialization-the-initializer-list-constructor-takes-precedence-over-the-ordinary-constructor" class="headerlink" title="In list initialization, the initializer_list constructor takes precedence over the ordinary constructor"></a>In list initialization, the initializer_list constructor takes precedence over the ordinary constructor</h3><p>First, let’s introduce two basic concepts:</p>
<blockquote>
<p><strong>List-initialization</strong> is initialization of an object or reference from a braced-init-list. Such an initializer is called an <strong>initializer list</strong>.<br><strong>initializer-list constructor</strong>: A constructor is an <em>initializer-list constructor</em> if its first parameter is of type <code>std::initializer_list&lt;E&gt;</code> or reference to possibly cv-qualified <code>std::initializer_list&lt;E&gt;</code> for some type E, and either there are no other parameters or else all other parameters have default arguments (8.3.6).</p>
</blockquote>
<p>Note: <strong>Initializer-list constructors</strong> are favored over other constructors in <strong>list-initialization</strong> (13.3.1.7).</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span>,<span class="type">int</span>)&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;A(int,int)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">A</span>(initializer_list&lt;<span class="type">int</span>&gt;)&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;A(initializer_list&lt;int&gt;)&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a&#123;<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">// A(initializer_list&lt;int&gt;)</span></span><br><span class="line">	<span class="function">A <span class="title">b</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>; <span class="comment">// A(int,int)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>[ISO/IEC 14882:2014 13.3.1.7 Initialization by list-initialization]</strong> When objects of non-aggregate class type T are list-initialized (8.5.4), overload resolution selects the constructor in two phases:</p>
</blockquote>
<ul>
<li>Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class T and the<br>argument list consists of the initializer list as a single argument.</li>
<li>If no viable initializer-list constructor is found, overload resolution is performed again, where the<br>candidate functions are all the constructors of the class T and the argument list consists of the elements of the initializer list.</li>
</ul>
<p>If the initializer list has no elements and T has a default constructor, the first phase is omitted. In copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed. [ Note: This differs from other situations (13.3.1.3, 13.3.1.4), where only converting constructors are considered for copy-initialization. This restriction only applies if this initialization is part of the final result of overload resolution. - end note ]</p>
<p>In simpler terms, when the constructor parameters of a class are list-initialized, the overload resolution of the constructor is divided into two steps:</p>
<ol>
<li>First, it tries to match with the constructor whose parameter is an <em>initializer-list</em>. If the <em>initializer-list</em> has no elements and the class has a default constructor, this step is omitted.</li>
<li>If no viable <em>initializer-list</em> constructor is found, overload resolution is performed again, with all constructors of the class as candidates, and the argument list consists of the elements of the <em>initializer-list</em>.</li>
</ol>
<p>Note: In the context of copy list initialization (copy-initializer_list), if an explicit constructor is selected, the program becomes ill-formed.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">A</span>(<span class="type">int</span>,<span class="type">int</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;A(int,int)&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt;)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;explicit A(std::initializer_list&lt;int&gt;)&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> A a=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">// error: chosen constructor is explicit in copy-initialization</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Moreover, explicit constructors will disable the implicit conversion of the <code>initializer list</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">A</span>()</span><br><span class="line"> &#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;A()&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt;)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">  cout&lt;&lt;<span class="string">&quot;explicit A(std::initializer_list&lt;int&gt;)&quot;</span>&lt;&lt;endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">f</span>(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;); <span class="comment">// ERROR due to explicit (no implicit type conversion allowed)</span></span><br><span class="line"> <span class="built_in">f</span>(A&#123;<span class="number">1</span>,<span class="number">2</span>&#125;); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
        
        
          
            <blockquote class="blockquote-center">
              
                The article is finished. If you have any questions, please comment and communicate.
              
            <br/>
            
                <div class="qr-code" onclick="return false">
                    <script src="/js/qrcode.min.js"></script>
                    <div id="qrcode">
                      
                        <img src="https://imzlp.com/images/wechat-qrcode.webp">
                      
                    <p>Scan the QR code on WeChat and follow me.</p>
                    </div>
                </div>
            
            </blockquote>
          
        

        
          <div class="postCopyright" style="clear:both;">
             <span>Title:</span><a href="/posts/1756/" target="_blank">Programming skills and concepts in C/C++</a><br/>
             <span>Author:</span><a href="/about" target="_blank" title="查看 LIPENGZHA 的资料">LIPENGZHA</a><br/>
             <span>Publish Date:</span>2017/03/05 01:21<br/>
             
              <span>Update Date:</span>2017/04/28 07:53<br/>
             
             <span>Word Count:</span><span class="page-count">19k Words</span><br/>
             
             <span>Link:</span><a href="/posts/1756/" target="_blank" title="Programming skills and concepts in C/C++">https://en.imzlp.com/posts/1756/</a>
             <span class="copy-path" data-clipboard-text="Link: https://en.imzlp.com/posts/1756/ Author: LIPENGZHA" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
             <script src="/js/jquery.min.js"></script>
             <script src="/js/clipboard.min.js"></script>
             <script> var clipboard = new Clipboard('.copy-path'); </script>
             <br/>
             
             <span>License:</span><i class="fab fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">CC BY-NC-SA 4.0</a><br/>
             
             <span>Reprinting of the full article is prohibited.</span>
          </div>
        
    

        
  <div class="reward-container">
    <div>Your donation will encourage me to keep creating!</div>
    <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
      Donate
    </button>
    <div id="qr" style="display: none;">
        
        <div style="display: inline-block;">
          <img src="/images/reward/wechatpay.webp" alt="LIPENGZHA WeChat Pay">
          <p>WeChat Pay</p>
        </div>

    </div>
  </div>



      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/" rel="tag"># 编程技巧</a>
              <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"># C语言</a>
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/2658/" rel="prev" title="A brief discussion on fork/vfork">
      <i class="fa fa-chevron-left"></i> A brief discussion on fork/vfork
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/15272/" rel="next" title="Main-function prototype verification and program termination behavior">
      Main-function prototype verification and program termination behavior <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-utteranc">utteranc</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane utteranc" id="comment-utteranc">
              
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="hxhb/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Explicitly-Qualified-Number-of-Elements-for-Array-Arguments"><span class="nav-number">1.</span> <span class="nav-text">Explicitly Qualified Number of Elements for Array Arguments</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Enabling-Compiler-Warnings-for-Implicit-Type-Conversions-Changing-Sign"><span class="nav-number">2.</span> <span class="nav-text">Enabling Compiler Warnings for Implicit Type Conversions Changing Sign</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Assert"><span class="nav-number">3.</span> <span class="nav-text">Assert</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Invalid-References"><span class="nav-number">4.</span> <span class="nav-text">Invalid References</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#References-to-Arrays"><span class="nav-number">5.</span> <span class="nav-text">References to Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ignoring-Top-Level-cv-qualifier-of-Function-Parameters"><span class="nav-number">6.</span> <span class="nav-text">Ignoring Top-Level cv-qualifier of Function Parameters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Be-Careful-with-signed-unsigned-when-using-char-as-an-array-index"><span class="nav-number">7.</span> <span class="nav-text">Be Careful with signed&#x2F;unsigned when using char as an array index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-tag-5-float"><span class="nav-number">8.</span> <span class="nav-text">struct tag (*[5])(float)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-a-pointer-array"><span class="nav-number">9.</span> <span class="nav-text">new a pointer array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Low-Level-const-and-Top-Level-const"><span class="nav-number">10.</span> <span class="nav-text">Low-Level const and Top-Level const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dangers-of-Passing-this-Pointer-in-Constructor"><span class="nav-number">11.</span> <span class="nav-text">Dangers of Passing this Pointer in Constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Get-the-Absolute-Path-of-the-Current-Executing-Program"><span class="nav-number">12.</span> <span class="nav-text">Get the Absolute Path of the Current Executing Program</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Quirky-Usage-of-using"><span class="nav-number">13.</span> <span class="nav-text">A Quirky Usage of using</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rvalue-References"><span class="nav-number">14.</span> <span class="nav-text">Rvalue References</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#An-Array-Name-Example"><span class="nav-number">15.</span> <span class="nav-text">An Array Name Example</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#How-Many-Passing-Methods-Are-There"><span class="nav-number">16.</span> <span class="nav-text">How Many Passing Methods Are There?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Three-Laws-of-Defining-Copy-Assign-and-Destructor-Functions"><span class="nav-number">17.</span> <span class="nav-text">The Three Laws of Defining Copy&#x2F;Assign and Destructor Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Implementation-of-References"><span class="nav-number">18.</span> <span class="nav-text">Implementation of References</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Appropriately-Using-Compiler-Generated-Operations"><span class="nav-number">19.</span> <span class="nav-text">Appropriately Using Compiler-Generated Operations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compressing-Capacity-and-Truly-Erasing-Elements-in-STL-Containers"><span class="nav-number">20.</span> <span class="nav-text">Compressing Capacity and Truly Erasing Elements in STL Containers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Beware-of-Hiding-Overloaded-Functions-in-Base-Classes"><span class="nav-number">21.</span> <span class="nav-text">Beware of Hiding Overloaded Functions in Base Classes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Macro-Alternatives"><span class="nav-number">22.</span> <span class="nav-text">Macro Alternatives</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-Memory-Allocation-Functions"><span class="nav-number">23.</span> <span class="nav-text">Class Memory Allocation Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception-Safety"><span class="nav-number">24.</span> <span class="nav-text">Exception Safety</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cv-Versions-of-Pointers-to-Class-Member-Functions"><span class="nav-number">25.</span> <span class="nav-text">cv Versions of Pointers to Class Member Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compare-Operation-Implementation-in-STL"><span class="nav-number">26.</span> <span class="nav-text">Compare Operation Implementation in STL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Computational-Constructor"><span class="nav-number">27.</span> <span class="nav-text">Computational Constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Members-of-Its-Own-Type"><span class="nav-number">28.</span> <span class="nav-text">Using Members of Its Own Type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Random-Access-in-std-vector"><span class="nav-number">29.</span> <span class="nav-text">Random Access in std::vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Note-the-Difference-Between-typedef-and-define"><span class="nav-number">30.</span> <span class="nav-text">Note the Difference Between typedef and #define</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Why-const-Object-Is-Not-a-Compile-Time-Constant"><span class="nav-number">31.</span> <span class="nav-text">Why const Object Is Not a Compile-Time Constant?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-Query-in-Inheritance-Hierarchies"><span class="nav-number">32.</span> <span class="nav-text">Class Query in Inheritance Hierarchies</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#In-list-initialization-the-initializer-list-constructor-takes-precedence-over-the-ordinary-constructor"><span class="nav-number">33.</span> <span class="nav-text">In list initialization, the initializer_list constructor takes precedence over the ordinary constructor</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person" oncontextmenu="return false" οndragstart="return false">
    <img class="site-author-image" itemprop="image" alt="LIPENGZHA"
      src="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
  <p class="site-author-name" itemprop="name">LIPENGZHA</p>
  <div class="site-description" itemprop="description">"I think, therefore I am"</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
             
          <span class="site-state-item-count">190</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">95</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">190</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxhb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxhb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/lipengzha" title="Linkedin → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;lipengzha" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/imzlp" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;imzlp" rel="noopener" target="_blank"><i class="fa fa-custom zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat-qrcode-offical.webp" title="微信公众号 → &#x2F;images&#x2F;wechat-qrcode-offical.webp"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imzlp@foxmail.com" title="E-Mail → mailto:imzlp@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://consolehelp.imzlp.com/" title="https:&#x2F;&#x2F;consolehelp.imzlp.com&#x2F;" rel="noopener" target="_blank">UE Console Help</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/opensource/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;opensource&#x2F;" rel="noopener" target="_blank">Open Source Projects</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/posts/11515/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;posts&#x2F;11515&#x2F;" rel="noopener" target="_blank">UE C++ API Dash Documents</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ue5wiki.com/" title="https:&#x2F;&#x2F;ue5wiki.com&#x2F;" rel="noopener" target="_blank">Unreal Engine Wiki</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LIPENGZHA</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.5m</span>
</div>
  <div class="powered-by-other">
    
	    <center>Github Pages | Actions | NeXT | Cloudflare | Hexo Deploy</center>
      
  </div>

<script>
function checkWebp(callback) {
    var img = new Image();
    img.onload = function () { callback((img.width > 0) && (img.height > 0)); };
    img.onerror = function () { callback(false); };
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
}
function showImage(useWebp) {
    var imgs = [].slice.call(document.querySelectorAll('img'));
    imgs.forEach(function (e) {
        if (!useWebp) {
            var src = e.getAttribute('data-src')
            src = src.replace(/\.webp$/, '.png');
            e.setAttribute('data-src', src);
        }
    });
}
checkWebp(showImage);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animejs/3.2.1/anime.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.5.1/jquery.min.js"></script>
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



<script src="/js/code-unfold.js"></script>

  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  
  <script src="//img.imzlp.com/imgs/zlp/picgo/2021/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://en.imzlp.com/posts/1756/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    var requiredFields = 'nick';
    requiredFields = requiredFields.split(',');
    
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oCE6RMVkVoi5MgUhvFsn1EvV-gzGzoHsz',
      appKey     : 'K9SOaNYJ8PV6xaoFggWG5xvv',
      placeholder: "Leave something behind~",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields: requiredFields
    });
  }, window.Valine);
});
</script>

</body>
</html>
