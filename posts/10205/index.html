<!DOCTYPE html>
<html lang="en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-tilt-brush.png">
  <link rel="mask-icon" href="/images/favicon-32x32-tilt-brush.png" color="#222">
  <meta name="google-site-verification" content="ttIkhAIFZQM9Huj8roB0l95ePN2Tv2zv2wRFksi09WA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Pacifico:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"en.imzlp.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"width":280},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"code_unfold":{"enable":true,"CODE_MAX_HEIGHT":600},"path":"search.xml"};
  </script>

  <meta name="description" content="CppQuiz is a simple online quiz that you can use to test your knowledge of the C++ programming language.It’s quite interesting; I wrote down a few questions I encountered today. I’ll add more here whe">
<meta property="og:type" content="article">
<meta property="og:title" content="Some interesting questions and analysis of CppQuiz">
<meta property="og:url" content="https://en.imzlp.com/posts/10205/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="CppQuiz is a simple online quiz that you can use to test your knowledge of the C++ programming language.It’s quite interesting; I wrote down a few questions I encountered today. I’ll add more here whe">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2016-10-24T06:15:05.000Z">
<meta property="article:modified_time" content="2016-10-24T06:15:05.000Z">
<meta property="article:author" content="LIPENGZHA">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="C++标准">
<meta property="article:tag" content="CppQuiz">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://en.imzlp.com/posts/10205/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Some interesting questions and analysis of CppQuiz | Z's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDCJ41EFP5"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FDCJ41EFP5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Z's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-edit fa-fw"></i>Notes</a>

  </li>


      
        
            
  <li class="menu-item menu-item-essay">

    <a href="/essay/" rel="section"><i class="fas fa-feather-alt fa-fw"></i>Essay</a>

  </li>


      
        
            
  <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-inbox fa-fw"></i>Resources</a>

  </li>


      
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fas fa-link fa-fw"></i>Friends</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me</a>

  </li>


      
        <li class="menu-item menu-item-showcase">

    <a href="/showcase/" rel="section"><i class="fa fa-solid fa-trophy fa-fw"></i>ShowCase</a>

  </li>
        <li class="menu-item menu-item-changelog">

    <a href="/changelog/" rel="section"><i class="fa fa-history fa-fw"></i>Site Log</a>

  </li>
        <li class="menu-item menu-item-opensource">

    <a href="/opensource/" rel="section"><i class="fas fa-code-branch fa-fw"></i>Open Source</a>

  </li>
        <li class="menu-item menu-item-uewiki">

    <a href="https://ue5wiki.com/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>Unreal Wiki</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>



<script type="text/javascript">
  let domain='en.imzlp.com';
  let domain_str = atob(domain);
  let pathname = location.pathname;
  if (domain_str!= location.host.toLowerCase()){
        console.log(`this host is not safe,jump to https://${domain_str}${pathname}`);
        location.href=`https://${domain_str}${pathname}`;
  }
</script>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <div class="l10n-header-widget">
    <script>
      // 获取当前页面的 URL
      const currentUrl = window.location.href;
      // 替换 URL 中的部分内容
      const jumpToL10nLink = currentUrl.replace('en.imzlp.com', 'imzlp.com');
      // 将 jumpToL10nLink 绑定到一个全局变量
      window.jumpToL10nLink = jumpToL10nLink;
    </script>

    <a href="#" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: none;" rel="noopener" target="_blank" onclick="window.open(window.jumpToL10nLink, '_blank'); return false;">
      <i class="fa fa-solid fa-language"></i>
    </a>
  </div>



    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en"
  >
    <link itemprop="mainEntityOfPage" href="https://en.imzlp.com/posts/10205/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
      <meta itemprop="name" content="LIPENGZHA">
      <meta itemprop="description" content=""I think, therefore I am"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Some interesting questions and analysis of CppQuiz<a href="https://github.com/imzlp/blog-md/blob/en/_posts/2016-10-24-10205.md" class="post-edit-link" title="Edit this post" style="float: right;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a><a href="https://imzlp.com/posts/10205/" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-solid fa-language"></i></a>
        </h1>

        
          <div class="post-subtitle" style="text-align: center;line-height: 1;">
            <sub text-align="center" style="font-size: 15px;align-content: center;font-style: italic;bottom: 0em;">CppQuiz一些有趣的题和分析</sub>
          </div>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-24 06:15 06:15:05:15" itemprop="dateCreated datePublished" datetime="2016-10-24T06:15:05+00:00">2016-10-24 06:15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">代码分析</span></a>
                </span>
            </span>

          
            <span id="/posts/10205/" class="post-meta-item leancloud_visitors" data-flag-title="Some interesting questions and analysis of CppQuiz" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>51 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a target="_blank" rel="noopener" href="http://cppquiz.org/">CppQuiz</a> is a simple online quiz that you can use to test your knowledge of the C++ programming language.<br>It’s quite interesting; I wrote down a few questions I encountered today. I’ll add more here whenever I have time. In fact, many questions in CppQuiz can be explained by “Deep Exploration of C++ Object Model”… If you find yourself struggling with many questions, I recommend buying a copy of “Deep Exploration of C++ Object Model” and reading it thoroughly!<br>In addition, I will try to find relevant descriptions in the C++ standard (ISO/IEC 14882:2014) while answering questions.</p>
<span id="more"></span>
<p><strong>According to the C++11 standard, what is the output of this program?</strong></p>
<h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T &amp;i)</span> </span>&#123; std::cout &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> </span>&#123; std::cout &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> j=<span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">f</span>(i); <span class="comment">// match to void f(int&amp;)</span></span><br><span class="line">  <span class="built_in">f</span>(j); <span class="comment">// match to void f(const int&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer</strong>: 12</p>
<h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> std::string &amp;)</span> </span>&#123; std::cout &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *)</span> </span>&#123; std::cout &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *bar = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line">  <span class="built_in">f</span>(bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:22<br>Because a literal is not a <code>std::string</code> object, but is a <code>const char[]</code>. If you want <code>const char[]</code> to match <code>std::string</code>, you have to implement a user-defined conversion, which is not the optimal choice.</p>
<blockquote>
<p>Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type “array of n const char”, where n is the size of the string as defined below, and has static storage duration.</p>
</blockquote>
<h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">unsigned</span>)</span> </span>&#123; std::cout &lt;&lt; <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">-2.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**Answer: **compilation error</p>
<p>Calling <code>f</code> is ambiguous because <code>-2.5</code> is a <code>signed double</code>:</p>
<blockquote>
<p>The type of a floating literal is double unless explicitly specified by a suffix. The suffixes f and F specify float; the suffixes l and L specify long double.</p>
</blockquote>
<p>Converting <code>double</code> to internal needs to follow <strong>Integer conversion rank</strong>, see <strong>[ISO/IEC 14882:2014 4.13]</strong>.<br>It specifies that the conversion rank of signed integer types is equal to that of unsigned integer types:</p>
<blockquote>
<p>The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type.</p>
</blockquote>
<p>In this question’s case, the matching degree of the two <code>f</code> functions is equal (it can convert to either, with no preference), which causes the ambiguity.</p>
<h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>() : <span class="built_in">a</span>(), <span class="built_in">b</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  B b;</span><br><span class="line">  A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">C</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:BA</p>
<p>Because when constructing <code>C</code>, the initialization order of members <code>a</code> and <code>b</code> does not follow the order in the constructor, but rather the order in which data members are defined in the class.</p>
<h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    std::cout &lt;&lt; i;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    std::cout &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**Answer: **012012</p>
<h3 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;X&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="function">X <span class="title">x</span><span class="params">()</span></span>; &#125;</span><br></pre></td></tr></table></figure>

<p>Result: does not output anything.<br>Because <code>X x();</code> is a function prototype, not an instantiation of an object.<br>Changing it to <code>X x&#123;&#125;;</code> will output <code>X</code>.</p>
<h3 id="Q11"><a href="#Q11" class="headerlink" title="Q11"></a>Q11</h3><p>According to the C++11 standard, what is the output of this program?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Result: 0<br>Because objects in the static storage area without specified initialization will be zero-initialized (zero-initialized).</p>
<blockquote>
<p>[ISO/IEC 14882:2014 §8.5/10]Every object of static storage duration is zero-initialized at program startup before any other initialization takes place.</p>
</blockquote>
<h3 id="Q13"><a href="#Q13" class="headerlink" title="Q13"></a>Q13</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;a&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;b&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;c&quot;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">C</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  C c;</span><br><span class="line">  B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer:</strong> acbBCA</p>
<p>First, because static objects are initialized before the first statement of the <code>main</code> function (implementation-defined):</p>
<blockquote>
<p>It is implementation-defined whether the dynamic initialization of a non-local variable with static storage duration is done before the first statement of main.</p>
</blockquote>
<p>In most compilers (I haven’t encountered one that isn’t), the global object <code>a</code> is constructed first, then <code>c</code> and <code>b</code> are constructed in the order they are defined, resulting in <code>acb</code> output.<br>When the program terminates, objects are destroyed in the reverse order of their construction, so the output is <code>BCA</code>.</p>
<h3 id="Q15"><a href="#Q15" class="headerlink" title="Q15"></a>Q15</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (x++ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;A&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;b&#x27;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;B&#x27;</span>; &#125;</span><br><span class="line">  A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="type">static</span> B b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">catch</span> (std::exception &amp;) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer</strong>: acabBA</p>
<ol>
<li>First, calling <code>foo()</code>, creates a <code>static B</code> object within <code>foo</code>. Without an initializer, B’s default constructor will be called.</li>
<li>According to <a target="_blank" rel="noopener" href="https://imzlp.com/posts/19242/#%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0%E6%97%B6%E7%9A%84%E6%89%A7%EF%BF%BD%EF%BF%BD%E9%A1%BA%E5%BA%8F">the order of object construction execution</a>, initialize base classes (if any) and data members. Since class B has no base class and a single data member <code>A</code>, the member <code>a</code> is initialized first. Being without an initializer, A’s default constructor will also be called.</li>
<li>In A’s default constructor, it outputs <code>a</code> and checks <code>x++ == 0</code>, which is true and hence throws an exception. When an exception is thrown in a constructor, all fully constructed sub-objects (excluding union type variant members) will have their destructors called. Since there are no data members in A, the constructor ends here, and no destructors are called.</li>
<li>In the <code>catch</code> block, the exception is caught and outputs <code>c</code>.</li>
<li>The <code>foo()</code> is executed again, causing B’s and A’s constructors to be called in sequence (outputting <code>a</code>). Since <code>x++</code> was executed before, <code>x++==0</code> is false this time; no exception is thrown, so A constructs successfully.</li>
<li>Execution continues with B’s constructor, outputting <code>b</code>.</li>
<li>When the program ends, destruction of B (and its members) follows the inverse order of construction.</li>
<li>Thus, B’s destructor is called and outputs <code>B</code>.</li>
<li>Lastly, A’s member destructor outputs <code>A</code>.</li>
</ol>
<h3 id="Q17"><a href="#Q17" class="headerlink" title="Q17"></a>Q17</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;a&#x27;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;A&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;b&#x27;</span>; &#125;</span><br><span class="line">  ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&#x27;B&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; B b; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer</strong>: abBA<br>This question primarily tests the order of construction under inheritance.<br>Construction:</p>
<blockquote>
<p>Where “left-to-right” is the order of appearance of the base classes in the derived class base-specifier-list.</p>
</blockquote>
<p>And destruction:</p>
<blockquote>
<p>After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class X calls the destructors for X’s direct non-variant non-static data members, the destructors for X’s direct base classes, and, if X is the type of the most derived class (12.6.2), its destructor calls the destructors for X’s virtual base classes. All destructors are called as if they were referenced with a qualified name, that is, ignoring any possible virtual overriding destructors in more derived classes. Bases and members are destroyed in the reverse order of the completion of their constructor (see 12.6.2). A return statement (6.6.3) in a destructor might not directly return to the caller; before transferring control to the caller, the destructors for the members and bases are called. Destructors for elements of an array are called in reverse order of their construction (see 12.6).</p>
</blockquote>
<h3 id="Q25"><a href="#Q25" class="headerlink" title="Q25"></a>Q25</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">  std::cout &lt;&lt; ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**Answer: **The program is undefined.</p>
<blockquote>
<p>If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined. [Note: most existing implementations of C++ ignore integer overflows. Treatment of division by zero, forming a remainder using a zero divisor, and all floating point exceptions vary among machines and are usually adjustable by a library function. — end note]</p>
</blockquote>
<h3 id="Q26"><a href="#Q26" class="headerlink" title="Q26"></a>Q26</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">  std::cout &lt;&lt; i / --j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer</strong>:The behavior is undefined.</p>
<h3 id="Q27"><a href="#Q27" class="headerlink" title="Q27"></a>Q27</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::ostream &amp;<span class="title">put</span><span class="params">(std::ostream &amp;o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o &lt;&lt; <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::ostream &amp;<span class="title">put</span><span class="params">(std::ostream &amp;o)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o &lt;&lt; <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;o, <span class="type">const</span> A &amp;a) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="built_in">put</span>(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  std::cout &lt;&lt; b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer:</strong> B<br>Because polymorphism can be achieved using a pointer or reference to a base class, hence in <code>operator&lt;&lt;</code>, calling <code>put</code> on <code>A&amp;</code> will invoke <code>B</code>‘s <code>put</code>.</p>
<blockquote>
<p>The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move of its bases and members.</p>
</blockquote>
<p>As to why <code>D d2(d1);</code> outputs <code>ABDd</code>, it is because when you explicitly define the copy constructor for the derived class, you need to manually call the copy constructor of its base class.<br>If you comment out the copy constructor in <code>D</code>, it will output <code>abc</code>.</p>
<h3 id="Q28"><a href="#Q28" class="headerlink" title="Q28"></a>Q28</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A &amp;a) &#123; std::cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line">    x.<span class="built_in">f</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Answer:</strong> AABCBC</p>
<p>Because in <code>for(auto x : a)</code>, the range for loop here makes a copy, transferring the elements from <code>a</code> to <code>x</code> one by one, thus calling the copy constructor. If you don’t want to use copies, you can pass by reference in the range for:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x : a) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Q29"><a href="#Q29" class="headerlink" title="Q29"></a>Q29</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>; &#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;3&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**Answer: **121<br>All the utilized concepts are written in <a target="_blank" rel="noopener" href="https://imzlp.com/posts/16550/">the order of object construction and destruction</a> and <a target="_blank" rel="noopener" href="https://imzlp.com/posts/1756/#%E4%B8%8D%E8%A6%81%E5%9C%A8%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E6%9C%9F%E5%BE%85%E5%A4%9A%E6%80%81%E8%A1%8C%E4%B8%BA">Don’t expect polymorphic behavior when calling virtual functions in base class constructors</a>.<br>One important point is that calling a virtual function in a base class constructor will not invoke the overridden version in the derived class (because the base class constructor completes before the derived class). However, when calling the <code>foo</code> method because the class construction is completed, during the execution of <code>b.foo()</code>, the derived class version can be found.</p>
<h3 id="Q32"><a href="#Q32" class="headerlink" title="Q32"></a>Q32</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">  <span class="built_in">X</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;a&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">X</span>(<span class="type">const</span> X &amp;x) &#123; std::cout &lt;&lt; <span class="string">&quot;b&quot;</span>; &#125;</span><br><span class="line">  <span class="type">const</span> X &amp;<span class="keyword">operator</span>=(<span class="type">const</span> X &amp;x) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;c&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  X x;</span><br><span class="line">  <span class="function">X <span class="title">y</span><span class="params">(x)</span></span>;</span><br><span class="line">  X z = y;</span><br><span class="line">  z = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:abbc</p>
<p>The only important note is that <code>X z = y;</code> calls the copy constructor, not <code>operator=()</code>. The distinction between <strong>copy initialization</strong> and <strong>assignment operation</strong> is crucial.</p>
<blockquote>
<p>The first line in main(), <code>X x;</code>, is straightforward; it calls the default constructor.<br>The next two lines are the heart of the question: The difference between <code>X y(x)</code> and <code>X z = y</code> is not just that the first calls the copy constructor and the second calls the copy assignment operator. The distinction lies in direct initialization (§8.5.15 in the standard) versus copy initialization (§8.5.14).<br>§8.5.16 states: “If the initialization is direct-initialization, or if it is copy-initialization where the (…) source type is the same class as (…) the class of the destination, constructors are considered.” So both our cases utilize the copy constructor.<br>Only when reaching <code>z = x;</code> do we see an actual assignment using the assignment operator.<br>See <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/1051379/is-there-a-difference-in-c-between-copy-initialization-and-direct-initialization/1051468#1051468">http://stackoverflow.com/#1051468</a> for a more detailed discussion of direct versus copy initialization.</p>
</blockquote>
<h3 id="Q35"><a href="#Q35" class="headerlink" title="Q35"></a>Q35</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">  std::cout &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; v2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer</strong>:12</p>
<p><code>v1</code> is initialized with one element set to 2, referring to the vector constructor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Effects: Constructs a vector with n copies of value, using the specified allocator.</span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="type">const</span> T&amp; value, <span class="type">const</span> Allocator&amp; = <span class="built_in">Allocator</span>());</span><br></pre></td></tr></table></figure>

<p><code>v2</code> uses an initializer list to construct the vector object, resulting in a count equal to the number of elements in the initializer list.</p>
<h3 id="Q49"><a href="#Q49" class="headerlink" title="Q49"></a>Q49</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">C</span>(<span class="type">int</span> i) : <span class="built_in">i</span>(i) &#123; std::cout &lt;&lt; i; &#125;</span><br><span class="line">  ~<span class="built_in">C</span>() &#123; std::cout &lt;&lt; i + <span class="number">5</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> C &amp;c = <span class="built_in">C</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">C</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**Answer: **1276</p>
<p>This is because a const reference extends the lifetime of a temporary object within the scope of that reference, so <code>C(1)</code> will not call a destructor immediately after the expression, but rather when it leaves the current block. </p>
<h3 id="Q52"><a href="#Q52" class="headerlink" title="Q52"></a>Q52</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> B <span class="title">A::createB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">B <span class="title">createB</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">B</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  B b = a.<span class="built_in">createB</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**Answer: ** compilation error</p>
<p>Even though there’s a forward declaration of <code>A</code> before <code>B</code> is defined, the friend function <code>A::createB()</code> cannot be determined whether it exists in <code>A</code> at this time, thus leading to a compilation error.</p>
<p>One way to solve it is to look at the code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">  <span class="function">B <span class="title">createB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> B <span class="title">A::createB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">B <span class="title">A::createB</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">B</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  B b = a.<span class="built_in">createB</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Delay the definition of mutually dependent functions until after all class definitions.</p>
<h3 id="Q112"><a href="#Q112" class="headerlink" title="Q112"></a>Q112</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;1&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">const</span> A&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;2&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">A</span>(A&amp;&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;3&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;4&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">const</span> B&amp; b) : <span class="built_in">a</span>(b.a) &#123; std::cout &lt;&lt; <span class="string">&quot;5&quot;</span>; &#125;</span><br><span class="line">  <span class="built_in">B</span>(B&amp;&amp; b) : <span class="built_in">a</span>(b.a) &#123; std::cout &lt;&lt; <span class="string">&quot;6&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b1;</span><br><span class="line">  B b2 = std::<span class="built_in">move</span>(b1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:1426</p>
<p>The construction order for <code>B b1;</code> is: </p>
<ol>
<li>Calls <code>A</code> constructor to construct member object <code>a</code>; </li>
<li>Calls <code>B</code>‘s default constructor.</li>
</ol>
<p>When a class has a default constructor and one or more member class objects, the class expands its existing default constructor so the necessary member class object constructor is called before the user code in the class’s default constructor.</p>
<p>Thus, the above code for <code>B</code>‘s default constructor expands to:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">b</span>() &#123;</span><br><span class="line">  <span class="comment">// Pseudo code, calls A&#x27;s constructor to initialize object a</span></span><br><span class="line">  a.A::<span class="built_in">A</span>();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If multiple member objects require construction, C++ requires calling each member class object’s default constructor in the order of <strong>member objects’ declaration</strong> in the class.</p>
<p>More content can be found in “Deep Exploration of C++ Object Model” P43.</p>
<blockquote>
<p>First, <code>b1</code> is default initialized. All members are initialized before the body of the constructor, so <code>b1.a</code> is default initialized first, resulting in output <code>14</code>.<br>§12.6.2¶8 in the standard: “In a non-delegating constructor, if a given non-static data member or base class is not designated by a mem-initializer-id (…) then if the entity is a non-static data member that has a brace-or-equal-initializer, the entity is initialized as specified in §8.5 (…) otherwise, the entity is default-initialized.”<br>Then, <code>b2</code> is initialized with the move constructor (since <code>std::move(b1)</code> converts the reference to <code>b1</code> to an xvalue, allowing it to be moved from). In <code>B</code>‘s move constructor, <code>a</code> is initialized in the initializer list. Even though <code>a</code> is an rvalue reference (and bound to an rvalue), <code>a</code> itself is an lvalue, and cannot be moved from. <code>b2.a</code> is then copy initialized, printing <code>2</code>, and finally the body of <code>B</code>‘s move constructor prints <code>6</code>. (If the concept of rvalue references being lvalues is confusing, read <a target="_blank" rel="noopener" href="http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">The Article</a>. Search for “In widget”.)</p>
</blockquote>
<h3 id="Q116"><a href="#Q116" class="headerlink" title="Q116"></a>Q116</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">(<span class="type">int</span> &amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">y</span><span class="params">(<span class="type">int</span> &amp;&amp;)</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(T &amp;&amp;x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">y</span>(x); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(T &amp;&amp;x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">y</span>(std::<span class="built_in">move</span>(x)); &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">int</span> <span class="title">h</span><span class="params">(T &amp;&amp;x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">y</span>(std::forward&lt;T&gt;(x)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">f</span>(i) &lt;&lt; <span class="built_in">f</span>(<span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">g</span>(i) &lt;&lt; <span class="built_in">g</span>(<span class="number">20</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">h</span>(i) &lt;&lt; <span class="built_in">h</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The T&amp;&amp; in the templated functions do not necessarily denote an rvalue reference; it depends on the type that is used to instantiate the template. If instantiated with an lvalue, it collapses to an lvalue reference; if instantiated with an rvalue, it collapses to an rvalue reference. See note [1].<br>Scott Meyers has written a very good article about this, where he introduces the concept of “universal references” (note that this is not C++ standard wording) <a target="_blank" rel="noopener" href="http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers</a>.<br>In this example, all three functions are called once with an lvalue and once with an rvalue. In all cases, calling with an lvalue (<code>i</code>) collapses <code>T&amp;&amp; x</code> to <code>T&amp; x</code> (an lvalue reference), and calling with an rvalue (<code>20</code>) collapses <code>T&amp;&amp; x</code> to <code>T&amp;&amp; x</code> (an rvalue reference). Inside the functions, <code>x</code> itself is always an lvalue, regardless of whether its type is an rvalue reference or an lvalue reference.</p>
<ul>
<li>In the first example, <code>y(int&amp;)</code> is called for both cases. Output: <code>11</code>.</li>
<li>In the second example, <code>move(x)</code> obtains an rvalue reference, and <code>y(int&amp;&amp;)</code> is called for both cases. Output: <code>22</code>.</li>
<li>In the third example, <code>forward&lt;T&gt;(x)</code> obtains an lvalue reference when <code>x</code> is an lvalue reference and an rvalue reference when <code>x</code> is an rvalue reference, resulting in first a call to <code>y(int&amp;)</code> and then a call to <code>y(int&amp;&amp;)</code>. Output: <code>12</code>.</li>
</ul>
<p>Note [1]: §8.3.2¶6 in the standard: “If a (…) type template-parameter (§14.3.1) (…) denotes a type TR that is a reference to a type T, an attempt to create the type ‘lvalue reference to cv TR’ creates the type ‘lvalue reference to T’, while an attempt to create the type ‘rvalue reference to cv TR’ creates the type TR.” The example at the end of that paragraph is worth a look.<br>Note from the contributor: This illustrates Scott Meyers’s advice to use <code>std::forward</code> for universal references and <code>std::move</code> for rvalue references.</p>
<h3 id="Q119"><a href="#Q119" class="headerlink" title="Q119"></a>Q119</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">void</span> * p = &amp;p;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">bool</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**Answer: **1<br>Because assigning an object to itself at declaration is permissible (although it will have an indeterminate value).</p>
<blockquote>
<p>The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its initializer (if any), except as noted below.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> x = <span class="number">12</span>;</span><br><span class="line">&#123; <span class="type">unsigned</span> <span class="type">char</span> x = x; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Here the second <code>x</code> is initialized with its own (indeterminate) value.</p>
</blockquote>
<p>In this question, <code>p</code> is assigned a pointer pointing to <code>p</code>, and it can be assured that it is not <code>NULL</code>. Thus, converting it to <code>bool</code> results in <code>true</code>.</p>
<blockquote>
<p>[ISO/IEC 14882:2014 §4.12]A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true.</p>
</blockquote>
<p>We can take a look at the intermediate code to analyze how the compiler implements it:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">main</span>() #<span class="number">4</span> &#123;</span><br><span class="line">  %<span class="number">1</span> = alloca i8*, align <span class="number">8</span></span><br><span class="line">  %<span class="number">2</span> = bitcast i8** %<span class="number">1</span> to i8*</span><br><span class="line">  store i8* %<span class="number">2</span>, i8** %<span class="number">1</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">3</span> = load i8*, i8** %<span class="number">1</span>, align <span class="number">8</span></span><br><span class="line">  %<span class="number">4</span> = icmp ne i8* %<span class="number">3</span>, null</span><br><span class="line">  %<span class="number">5</span> = call <span class="built_in">dereferenceable</span>(<span class="number">272</span>) %<span class="string">&quot;class.std::basic_ostream&quot;</span>* @_ZNSolsEb(%<span class="string">&quot;class.std::basic_ostream&quot;</span>* @_ZSt4cout, i1 zeroext %<span class="number">4</span>)</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As seen:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">4</span> = icmp ne i8* %<span class="number">3</span>, null</span><br></pre></td></tr></table></figure>
<p>This line checks whether <code>%3</code> is not equal to <code>null</code>; hence a <code>ne</code> (not equal) comparison is performed, confirming that <code>%3</code>, which has an actual address, is not <code>null</code>. Therefore, the resulting boolean value is <code>true</code>.</p>
<h3 id="Q120"><a href="#Q120" class="headerlink" title="Q120"></a>Q120</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  x = a, b;</span><br><span class="line">  std::cout &lt;&lt; x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output: <code>10</code><br>Because the comma operator has the lowest precedence, resulting in the assignment operation being executed first, followed by the comma operator.<br>C++ operator precedence can be viewed in this article: <a target="_blank" rel="noopener" href="https://imzlp.com/posts/14660/">C++ keywords and operator precedence quick reference</a></p>
<h3 id="Q124"><a href="#Q124" class="headerlink" title="Q124"></a>Q124</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = A&gt; <span class="keyword">struct</span> X;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">X</span>&lt;A&gt; &#123;</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">X</span>&lt;B&gt; &#123;</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = B&gt; <span class="keyword">class</span> C&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">g</span>() &#123;</span><br><span class="line">   C&lt;&gt;::<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">g</span>&lt;X&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:2</p>
<p>Note: <code>C&lt;&gt;::f()</code> calls the version with the default template argument, which corresponds to <code>C&lt;X&lt;B&gt;&gt;::f()</code>, hence the output is <code>2</code>.</p>
<blockquote>
<p>A template-parameter of a template template-parameter is permitted to have a default template-argument. When such default arguments are specified, they apply to the template template-parameter in the scope of the template template-parameter.</p>
</blockquote>
<h3 id="Q125"><a href="#Q125" class="headerlink" title="Q125"></a>Q125</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T)</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  cout &lt;&lt; ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1.0</span>);</span><br><span class="line">  <span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**Answer: **112</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// Specialized f(int)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1.1</span>); <span class="comment">// Specialized f(double)</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1</span>); <span class="comment">// Uses the previously specialized f(int)</span></span><br></pre></td></tr></table></figure>
<p>This results in two versions of <code>f</code>, each having their own static object <code>i</code>, hence the output will be <code>112</code>.</p>
<h3 id="Q130"><a href="#Q130" class="headerlink" title="Q130"></a>Q130</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adl</span><span class="params">(T)</span></span>&#123;cout &lt;&lt; <span class="string">&quot;T&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_adl</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">adl</span>(<span class="built_in">S</span>());</span><br><span class="line">  <span class="built_in">adl</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adl</span><span class="params">(S)</span></span>&#123;cout &lt;&lt; <span class="string">&quot;S&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">call_adl</span>(<span class="built_in">S</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:TS<br>This happens because the first call of <code>adl(S())</code> in <code>call_adl</code> is a <code>Non-dependent name</code>, following ordinary name lookup rules. At this point, the only version of <code>adl</code> present is <code>adl(T)</code>, and <code>adl(S)</code> has not been defined yet, thus it won’t be included in the candidate set.<br>However, for the second call <code>adl(t)</code> which depends on the template parameter, the name resolution is postponed until instantiation at <code>call_adl(S())</code>, at which point <code>adl(S)</code> is already declared and defined, thus it gets matched.</p>
<blockquote>
<p>When looking for the declaration of a name used in a template definition, the usual lookup rules (3.4.1, 3.4.2) are applied for non-dependent names. The lookup of names dependent on the template parameters is postponed until the actual template argument is known (14.6.2).</p>
</blockquote>
<h3 id="Q131"><a href="#Q131" class="headerlink" title="Q131"></a>Q131</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;std::cout &lt;&lt; <span class="string">&quot;i&quot;</span>;&#125;;</span><br><span class="line">  <span class="built_in">C</span>(<span class="type">double</span>) &#123;std::cout &lt;&lt; <span class="string">&quot;d&quot;</span>;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">C <span class="title">c1</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">  C c2 = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer</strong>:id</p>
<p>An explicit constructor is only called in direct initialization.</p>
<blockquote>
<p>An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or value-initialization (8.5).</p>
</blockquote>
<p>Conversion constructor:</p>
<blockquote>
<p>A constructor declared without the function-specifier explicit specifies a conversion from the types of its parameters to the type of its class. Such a constructor is called a converting constructor.</p>
</blockquote>
<p><code>C c1(7)</code> is direct initialization, while <code>C c2=7;</code> is copy initialization. They should generally be equivalent, but in the above code, the difference exists.</p>
<blockquote>
<p>As well as in new expressions (5.3.4), static_cast expressions (5.2.9), functional notation type conversions (5.2.3), and base and member initializers (12.6.2) is called direct-initialization.</p>
</blockquote>
<p>While copy initialization:</p>
<blockquote>
<p>As well as in argument passing, function return, throwing an exception (15.1), handling an exception(15.3), and aggregate member initialization (8.5.1) is called copy-initialization. [Note: Copy-initialization may invoke a move (12.8). — end note]</p>
</blockquote>
<p>Explicit constructors are only called in direct initialization, hence in <code>C c2=7;</code>, the constructor <code>C(int)</code> won’t be a candidate, allowing only the match to <code>C(double)</code>.</p>
<h3 id="Q133"><a href="#Q133" class="headerlink" title="Q133"></a>Q133</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;) &#123; cout &lt;&lt; <span class="string">&quot;a&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">virtual</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B &amp;) &#123; cout&lt;&lt; <span class="string">&quot;b&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">virtual</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123; cout&lt;&lt; <span class="string">&quot;C&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">const</span> C &amp;) &#123; cout &lt;&lt; <span class="string">&quot;c&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>:B,C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123; cout&lt;&lt; <span class="string">&quot;D&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> D &amp;) &#123; cout &lt;&lt; <span class="string">&quot;d&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d1;</span><br><span class="line">    <span class="function">D <span class="title">d2</span><span class="params">(d1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**Answer: **ABCDABCd</p>
<p>This also utilizes <a target="_blank" rel="noopener" href="https://imzlp.com/posts/16550/">the order of object construction and destruction</a>. The only potential confusion in this code is how many times <code>A</code> is constructed. Because <code>B</code> and <code>C</code> use virtual inheritance, it only gets constructed once. Since <code>B</code> appears first in <code>D</code>, the construction proceeds in left-to-right order with a depth-first strategy: first calling <code>A</code>‘s constructor, followed by <code>B</code>, then <code>C</code>, and finally executing <code>D</code>‘s constructor.</p>
<h3 id="Q135"><a href="#Q135" class="headerlink" title="Q135"></a>Q135</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  map&lt;<span class="type">bool</span>,<span class="type">int</span>&gt; mb = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">  cout &lt;&lt; mb.<span class="built_in">size</span>();</span><br><span class="line">  map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mi = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">  cout &lt;&lt; mi.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:13</p>
<p>First, you need to understand that a map can only store unique keys. Additionally, the values 1/3/5 are all converted to the bool type, which results in true… At this point, <code>mb[true]</code> is 2.</p>
<blockquote>
<p><code>std::map</code> stores values based on a unique key. The keys for <code>mb</code> are boolean, and <code>1</code>, <code>3</code>, and <code>5</code> all evaluate to the same key, <code>true</code>.<br><em>§23.4.4.1¶1</em> in the standard:<br>“A map is an associative container that supports unique keys (contains at most one of each key value).”<br>The type of <code>mb</code> is <code>map</code>. The key is bool, so the integers <code>1</code>, <code>3</code>, and <code>5</code> used for initialization are first converted to bool, and they all evaluate to true.<br><em>§4.12¶1</em> in the standard:<br>“A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type bool. A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true.”### Q140</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">get_size_1</span><span class="params">(<span class="type">int</span>* arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">get_size_2</span><span class="params">(<span class="type">int</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">get_size_3</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> array[<span class="number">10</span>];</span><br><span class="line">  cout &lt;&lt; (<span class="built_in">sizeof</span>(array) == <span class="built_in">get_size_1</span>(array));</span><br><span class="line">  cout &lt;&lt; (<span class="built_in">sizeof</span>(array) == <span class="built_in">get_size_2</span>(array));</span><br><span class="line">  cout &lt;&lt; (<span class="built_in">sizeof</span>(array) == <span class="built_in">get_size_3</span>(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:001<br>Because get_size_1 and get_size_2 only receive an int pointer, the size obtained from sizeof is just the size of an int*. In contrast, get_size_3 receives a ten-element int array, so the sizeof operation yields the size of the ten-element int array.</p>
<h3 id="Q144"><a href="#Q144" class="headerlink" title="Q144"></a>Q144</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> N[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( std::numeric_limits&lt;<span class="type">long</span> <span class="type">int</span>&gt;::digits==<span class="number">63</span> <span class="keyword">and</span></span><br><span class="line">    std::numeric_limits&lt;<span class="type">int</span>&gt;::digits==<span class="number">31</span> <span class="keyword">and</span></span><br><span class="line">    std::numeric_limits&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;::digits==<span class="number">32</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">int</span> i = <span class="number">-0xffffffff</span>; i ; --i)</span><br><span class="line">    &#123;</span><br><span class="line">      N[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    N[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; N[<span class="number">0</span>] &lt;&lt;N [<span class="number">1</span>] &lt;&lt; N[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:010</p>
<p>The result of <code>std::numeric_limits&lt;T&gt;::digits</code> indicates the data bit size of T (<code>sizeof(T)*CHAR_BIT</code>, excluding the sign bit).</p>
<p>Moreover, the C++ standard only specifies the <code>minimum range</code> that built-in data types can represent, as shown in the following table:</p>
<table>
<thead>
<tr>
<th align="center">Type</th>
<th align="center">Meaning</th>
<th align="center">Minimum Size</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">Boolean type</td>
<td align="center">Undefined</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
<td align="center">8 bits</td>
</tr>
<tr>
<td align="center">wchar_t</td>
<td align="center">Wide character</td>
<td align="center">16 bits</td>
</tr>
<tr>
<td align="center">char16_t</td>
<td align="center">Unicode character</td>
<td align="center">16 bits</td>
</tr>
<tr>
<td align="center">char32_t</td>
<td align="center">Unicode character</td>
<td align="center">32 bits</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short type</td>
<td align="center">16 bits</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
<td align="center">16 bits</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long type</td>
<td align="center">32 bits</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">Long type</td>
<td align="center">64 bits</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Single precision float</td>
<td align="center">6 significant digits</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double precision float</td>
<td align="center">10 significant digits</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">Extended precision float</td>
<td align="center">10 significant digits</td>
</tr>
</tbody></table>
<p>No need to elaborate on the else part; the main point is to focus on the if condition.</p>
<p>The key concept is that <strong>the negative of an unsigned number is obtained by subtracting its value from $2^n$</strong>, i.e.:</p>
<p><code>-0xffffffff</code> = $2^n - \sum_{x=0}^{31}2^i$ = 1</p>
<blockquote>
<p>As the <code>else</code> part of the branch is obvious, we concentrate on the <code>if</code> part and make the assumptions present in the condition.<br><em>§2.14.2</em> in the standard: “The type of an integer literal is the first of the corresponding list in Table 6.” [Table 6: int, unsigned int, long int, unsigned long int … for hexadecimal literals – end Table] in which its value can be represented.”<br>Since the literal <code>0xffffffff</code> needs 32 digits, it can be represented as an <code>unsigned int</code>, but not as a signed <code>int</code>, and is of type <code>unsigned int</code>. But what happens with the negative of an unsigned integer?<br><em>§5.3.1</em> in the standard: “The negative of an unsigned quantity is computed by subtracting its value from 2^n, where n is the number of bits in the promoted operand.” Here <code>n</code> is <code>32</code>, and we get:<br><code>2^32 - 0xffffffff = 4294967296 - 4294967295 = 1</code><br>So <code>i</code> is initialized to <code>1</code>, and <code>N[1]</code> is the only element accessed in the loop. (The second time around the loop, <code>i</code> is <code>0</code>, which evaluates to false, and the loop terminates.)</p>
</blockquote>
<h3 id="Q147"><a href="#Q147" class="headerlink" title="Q147"></a>Q147</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> x=<span class="number">0</span>; <span class="comment">//What is wrong here??/</span></span><br><span class="line">  x=<span class="number">1</span>;</span><br><span class="line">  std::cout&lt;&lt;x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer</strong>:0</p>
<p>Because ??/ is a Trigraph sequence that represents <code>\</code>. The effect of \ is to change the next physical line into a logical line.</p>
<blockquote>
<p>Each instance of a backslash character (<code>\</code>) immediately followed by a newline character is deleted, splicing physical source lines to form logical source lines.</p>
</blockquote>
<p>So, the above code is actually equivalent to:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">0</span>; <span class="comment">//What is wrong here\</span></span><br><span class="line"><span class="comment">x=1;</span></span><br><span class="line"><span class="comment">// Equivalent to</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x=<span class="number">0</span>; <span class="comment">//What is wrong herex=1;</span></span><br></pre></td></tr></table></figure>

<h3 id="Q151"><a href="#Q151" class="headerlink" title="Q151"></a>Q151</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::is_signed&lt;<span class="type">char</span>&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The C++ standard specifies that whether char is unsigned or signed is implementation-defined behavior.<br>. It is implementation-defined whether a char object can hold negative values.</p>
</blockquote>
<h3 id="Q153"><a href="#Q153" class="headerlink" title="Q153"></a>Q153</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>A narrow string literal has type “array of n const char”, where n is the size of the string as defined below, and has static storage duration.</p>
</blockquote>
<p>In C++11, converting const char* to char* is illegal.</p>
<blockquote>
<p>ISO C++11 does not allow conversion from string literal to ‘char *’.</p>
</blockquote>
<p>The solution is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* str=<span class="string">&quot;x&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Q158"><a href="#Q158" class="headerlink" title="Q158"></a>Q158</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout&lt;&lt;<span class="string">&quot;a&quot;</span>; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;) &#123; std::cout&lt;&lt;<span class="string">&quot;b&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;Foo&gt; <span class="title">bar</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>:aaaaa</p>
<p><code>vector&lt;Foo&gt; bar(5)</code> where <code>bar(5)</code> does not pass 5 to the Foo constructor; it specifies the number of elements in the vector container.</p>
<p>When creating an <code>ordered container</code>, you can <code>explicitly specify the container size</code> and an (optional) element initializer.<br>The <code>container size</code> can be a <code>constant</code> or <code>non-constant expression</code>, and the element initializer must be a value that can initialize the object of its element type.</p>
<p>If you want to provide an initialization when <strong>specifying the container size</strong>, you can use:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;Foo&gt; <span class="title">initTenFooObj</span><span class="params">(<span class="number">10</span>,Foo())</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Since C++11 (<em>§23.3.6.2¶3</em> in the standard), <code>std::vector</code> has a one-parameter constructor<br><code>explicit vector( size_type n )</code><br>which constructs a vector with <code>n</code> value-initialized elements. Each value-initialization calls the default <code>Foo</code> constructor, resulting in the output <code>aaaaa</code>.<br>The “trick” is that before C++11, <code>std::vector</code> had a two-parameter constructor (+ allocator), which constructed the container with <code>n</code> copies of the second parameter, which is defaulted to <code>T()</code>. So this code before C++11 would output <code>abbbbb</code>, because the call would be equivalent to <code>std::vector bar(5,T())</code>.</p>
</blockquote>
<h3 id="Q157"><a href="#Q157" class="headerlink" title="Q157"></a>Q157</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt; (&amp;<span class="built_in">typeid</span>(A) == &amp;<span class="built_in">typeid</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Answer</strong>: This question The program is unspecified / implementation-defined.</p>
<blockquote>
<p>The result of a <code>typeid</code> expression is an lvalue of static type <code>const std::type_info</code> (18.7.1) and dynamic type <code>const std::type_info</code> or const name where name is an implementation-defined class publicly derived from <code>std::type_info</code> which preserves the behavior described in 18.7.1</p>
</blockquote>
<p>And the unary operator <code>&amp;</code> is:</p>
<blockquote>
<p>The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a qualified-id.</p>
</blockquote>
<p>Two <code>typeid</code> operations produce two pointers, and comparing the two pointers compares the values they store:</p>
<blockquote>
<p>Comparing pointers is defined as follows: Two pointers compare equal if they are both null, both point to the same function, or both represent the same address (3.9.2), otherwise they compare unequal.</p>
</blockquote>
<p>There is no guarantee that the same <code>std::type_info</code> instance will be referenced by all evaluation references of typeid expressions of the same type.<br>So, this is implementation-defined.</p>
<h3 id="Q159"><a href="#Q159" class="headerlink" title="Q159"></a>Q159</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">f</span>(i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>: 34</p>
<p>The C++ standard states that the side effects of argument evaluations are sequenced before the function is entered.</p>
<blockquote>
<p>[ISO/IEC 14882:2014 §5.2.3.8] All side effects of argument evaluations are sequenced before the function is entered.</p>
</blockquote>
<p>We can also look at the implementation of this feature from the viewpoint of IR code as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define i32 @main() #4 &#123;</span><br><span class="line">  store i32 3, i32* @i, align 4</span><br><span class="line">  %1 = load i32, i32* @i, align 4</span><br><span class="line">  %2 = add nsw i32 %1, 1</span><br><span class="line">  store i32 %2, i32* @i, align 4</span><br><span class="line">  call void @_Z1fi(i32 %1)</span><br><span class="line">  ret i32 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can see that when we call f(i++), the compiler first increments i and then passes the pre-increment value to f. But when entering function f, since the static object i has already been modified in the main function, the values output in function f are 3 and 4.</p>
<h3 id="Q160"><a href="#Q160" class="headerlink" title="Q160"></a>Q160</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(<span class="type">int</span> a = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A&quot;</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span> <span class="params">(<span class="type">int</span> a = <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B&quot;</span> &lt;&lt; a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> B;</span><br><span class="line">    b-&gt;<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Answer</strong>: B1</p>
<p>Because overriding the function does not replace the default arguments, the default argument still remains 1 in class B.</p>
<blockquote>
<p>A virtual function call (10.3) uses the default arguments in the declaration of the virtual function determined by the static type of the pointer or reference denoting the object. An overriding function in a derived class does not acquire default arguments from the function it overrides.</p>
</blockquote>

    </div>

    
    
        
        
          
            <blockquote class="blockquote-center">
              
                The article is finished. If you have any questions, please comment and communicate.
              
            <br/>
            
                <div class="qr-code" onclick="return false">
                    <script src="/js/qrcode.min.js"></script>
                    <div id="qrcode">
                      
                        <img src="https://imzlp.com/images/wechat-qrcode.webp">
                      
                    <p>Scan the QR code on WeChat and follow me.</p>
                    </div>
                </div>
            
            </blockquote>
          
        

        
          <div class="postCopyright" style="clear:both;">
             <span>Title:</span><a href="/posts/10205/" target="_blank">Some interesting questions and analysis of CppQuiz</a><br/>
             <span>Author:</span><a href="/about" target="_blank" title="查看 LIPENGZHA 的资料">LIPENGZHA</a><br/>
             <span>Publish Date:</span>2016/10/24 06:15<br/>
             
             <span>Word Count:</span><span class="page-count">21k Words</span><br/>
             
             <span>Link:</span><a href="/posts/10205/" target="_blank" title="Some interesting questions and analysis of CppQuiz">https://en.imzlp.com/posts/10205/</a>
             <span class="copy-path" data-clipboard-text="Link: https://en.imzlp.com/posts/10205/ Author: LIPENGZHA" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
             <script src="/js/jquery.min.js"></script>
             <script src="/js/clipboard.min.js"></script>
             <script> var clipboard = new Clipboard('.copy-path'); </script>
             <br/>
             
             <span>License:</span><i class="fab fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">CC BY-NC-SA 4.0</a><br/>
             
             <span>Reprinting of the full article is prohibited.</span>
          </div>
        
    

        
  <div class="reward-container">
    <div>Your donation will encourage me to keep creating!</div>
    <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
      Donate
    </button>
    <div id="qr" style="display: none;">
        
        <div style="display: inline-block;">
          <img src="/images/reward/wechatpay.webp" alt="LIPENGZHA WeChat Pay">
          <p>WeChat Pay</p>
        </div>

    </div>
  </div>



      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/C-%E6%A0%87%E5%87%86/" rel="tag"># C++标准</a>
              <a href="/tags/CppQuiz/" rel="tag"># CppQuiz</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/19242/" rel="prev" title="Some excerpts from the C/C++ standard">
      <i class="fa fa-chevron-left"></i> Some excerpts from the C/C++ standard
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/42318/" rel="next" title="Automatically deploy Github/Coding Pages blog using Travis CI">
      Automatically deploy Github/Coding Pages blog using Travis CI <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-utteranc">utteranc</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane utteranc" id="comment-utteranc">
              
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="hxhb/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1"><span class="nav-number">1.</span> <span class="nav-text">Q1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q2"><span class="nav-number">2.</span> <span class="nav-text">Q2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q3"><span class="nav-number">3.</span> <span class="nav-text">Q3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q5"><span class="nav-number">4.</span> <span class="nav-text">Q5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q6"><span class="nav-number">5.</span> <span class="nav-text">Q6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q9"><span class="nav-number">6.</span> <span class="nav-text">Q9</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q11"><span class="nav-number">7.</span> <span class="nav-text">Q11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q13"><span class="nav-number">8.</span> <span class="nav-text">Q13</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q15"><span class="nav-number">9.</span> <span class="nav-text">Q15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q17"><span class="nav-number">10.</span> <span class="nav-text">Q17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q25"><span class="nav-number">11.</span> <span class="nav-text">Q25</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q26"><span class="nav-number">12.</span> <span class="nav-text">Q26</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q27"><span class="nav-number">13.</span> <span class="nav-text">Q27</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q28"><span class="nav-number">14.</span> <span class="nav-text">Q28</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q29"><span class="nav-number">15.</span> <span class="nav-text">Q29</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q32"><span class="nav-number">16.</span> <span class="nav-text">Q32</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q35"><span class="nav-number">17.</span> <span class="nav-text">Q35</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q49"><span class="nav-number">18.</span> <span class="nav-text">Q49</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q52"><span class="nav-number">19.</span> <span class="nav-text">Q52</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q112"><span class="nav-number">20.</span> <span class="nav-text">Q112</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q116"><span class="nav-number">21.</span> <span class="nav-text">Q116</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q119"><span class="nav-number">22.</span> <span class="nav-text">Q119</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q120"><span class="nav-number">23.</span> <span class="nav-text">Q120</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q124"><span class="nav-number">24.</span> <span class="nav-text">Q124</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q125"><span class="nav-number">25.</span> <span class="nav-text">Q125</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q130"><span class="nav-number">26.</span> <span class="nav-text">Q130</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q131"><span class="nav-number">27.</span> <span class="nav-text">Q131</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q133"><span class="nav-number">28.</span> <span class="nav-text">Q133</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q135"><span class="nav-number">29.</span> <span class="nav-text">Q135</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q144"><span class="nav-number">30.</span> <span class="nav-text">Q144</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q147"><span class="nav-number">31.</span> <span class="nav-text">Q147</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q151"><span class="nav-number">32.</span> <span class="nav-text">Q151</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q153"><span class="nav-number">33.</span> <span class="nav-text">Q153</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q158"><span class="nav-number">34.</span> <span class="nav-text">Q158</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q157"><span class="nav-number">35.</span> <span class="nav-text">Q157</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q159"><span class="nav-number">36.</span> <span class="nav-text">Q159</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Q160"><span class="nav-number">37.</span> <span class="nav-text">Q160</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person" oncontextmenu="return false" οndragstart="return false">
    <img class="site-author-image" itemprop="image" alt="LIPENGZHA"
      src="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
  <p class="site-author-name" itemprop="name">LIPENGZHA</p>
  <div class="site-description" itemprop="description">"I think, therefore I am"</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
             
          <span class="site-state-item-count">190</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">95</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">190</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxhb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxhb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/lipengzha" title="Linkedin → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;lipengzha" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/imzlp" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;imzlp" rel="noopener" target="_blank"><i class="fa fa-custom zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat-qrcode-offical.webp" title="微信公众号 → &#x2F;images&#x2F;wechat-qrcode-offical.webp"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imzlp@foxmail.com" title="E-Mail → mailto:imzlp@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://consolehelp.imzlp.com/" title="https:&#x2F;&#x2F;consolehelp.imzlp.com&#x2F;" rel="noopener" target="_blank">UE Console Help</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/opensource/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;opensource&#x2F;" rel="noopener" target="_blank">Open Source Projects</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/posts/11515/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;posts&#x2F;11515&#x2F;" rel="noopener" target="_blank">UE C++ API Dash Documents</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ue5wiki.com/" title="https:&#x2F;&#x2F;ue5wiki.com&#x2F;" rel="noopener" target="_blank">Unreal Engine Wiki</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LIPENGZHA</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.5m</span>
</div>
  <div class="powered-by-other">
    
	    <center>Github Pages | Actions | NeXT | Cloudflare | Hexo Deploy</center>
      
  </div>

<script>
function checkWebp(callback) {
    var img = new Image();
    img.onload = function () { callback((img.width > 0) && (img.height > 0)); };
    img.onerror = function () { callback(false); };
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
}
function showImage(useWebp) {
    var imgs = [].slice.call(document.querySelectorAll('img'));
    imgs.forEach(function (e) {
        if (!useWebp) {
            var src = e.getAttribute('data-src')
            src = src.replace(/\.webp$/, '.png');
            e.setAttribute('data-src', src);
        }
    });
}
checkWebp(showImage);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animejs/3.2.1/anime.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.5.1/jquery.min.js"></script>
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



<script src="/js/code-unfold.js"></script>

  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  
  <script src="//img.imzlp.com/imgs/zlp/picgo/2021/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://en.imzlp.com/posts/10205/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    var requiredFields = 'nick';
    requiredFields = requiredFields.split(',');
    
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oCE6RMVkVoi5MgUhvFsn1EvV-gzGzoHsz',
      appKey     : 'K9SOaNYJ8PV6xaoFggWG5xvv',
      placeholder: "Leave something behind~",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields: requiredFields
    });
  }, window.Valine);
});
</script>

</body>
</html>
