<!DOCTYPE html>
<html lang="en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-tilt-brush.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-tilt-brush.png">
  <link rel="mask-icon" href="/images/favicon-32x32-tilt-brush.png" color="#222">
  <meta name="google-site-verification" content="ttIkhAIFZQM9Huj8roB0l95ePN2Tv2zv2wRFksi09WA">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Pacifico:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/5.15.2/css/all.min.css">
  <link rel="stylesheet" href="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"en.imzlp.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"width":280},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"manual"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"code_unfold":{"enable":true,"CODE_MAX_HEIGHT":600},"path":"search.xml"};
  </script>

  <meta name="description" content="“Pointers to members” is a feature in C++ that is not commonly used. However, the use of the term “pointer” is somewhat inaccurate here, as they do not contain an address, and their behavior is not li">
<meta property="og:type" content="article">
<meta property="og:title" content="Pointers to class members in C++ are not pointers">
<meta property="og:url" content="https://en.imzlp.com/posts/27615/index.html">
<meta property="og:site_name" content="Z&#39;s Blog">
<meta property="og:description" content="“Pointers to members” is a feature in C++ that is not commonly used. However, the use of the term “pointer” is somewhat inaccurate here, as they do not contain an address, and their behavior is not li">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27615/pointer-to-member-diff-non-init-have-init.webp">
<meta property="article:published_time" content="2017-04-29T21:28:17.000Z">
<meta property="article:modified_time" content="2019-04-22T00:38:56.000Z">
<meta property="article:author" content="LIPENGZHA">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="技术笔记">
<meta property="article:tag" content="编程笔记">
<meta property="article:tag" content="C++标准">
<meta property="article:tag" content="中间代码">
<meta property="article:tag" content="LLVM-IR">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.imzlp.com/imgs/zlp/blog/posts/27615/pointer-to-member-diff-non-init-have-init.webp">

<link rel="canonical" href="https://en.imzlp.com/posts/27615/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Pointers to class members in C++ are not pointers | Z's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDCJ41EFP5"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-FDCJ41EFP5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.7.0/style.min.css" /><!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Z's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Z's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        
            
  <li class="menu-item menu-item-notes">

    <a href="/notes/" rel="section"><i class="fa fa-edit fa-fw"></i>Notes</a>

  </li>


      
        
            
  <li class="menu-item menu-item-essay">

    <a href="/essay/" rel="section"><i class="fas fa-feather-alt fa-fw"></i>Essay</a>

  </li>


      
        
            
  <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-inbox fa-fw"></i>Resources</a>

  </li>


      
        <li class="menu-item menu-item-friends">

    <a href="/friends/" rel="section"><i class="fas fa-link fa-fw"></i>Friends</a>

  </li>
        
            
  <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About Me</a>

  </li>


      
        <li class="menu-item menu-item-showcase">

    <a href="/showcase/" rel="section"><i class="fa fa-solid fa-trophy fa-fw"></i>ShowCase</a>

  </li>
        <li class="menu-item menu-item-changelog">

    <a href="/changelog/" rel="section"><i class="fa fa-history fa-fw"></i>Site Log</a>

  </li>
        <li class="menu-item menu-item-opensource">

    <a href="/opensource/" rel="section"><i class="fas fa-code-branch fa-fw"></i>Open Source</a>

  </li>
        <li class="menu-item menu-item-uewiki">

    <a href="https://ue5wiki.com/" rel="noopener" target="_blank"><i class="fab fa-wikipedia-w fa-fw"></i>Unreal Wiki</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>



<script type="text/javascript">
  let domain='en.imzlp.com';
  let domain_str = atob(domain);
  let pathname = location.pathname;
  if (domain_str!= location.host.toLowerCase()){
        console.log(`this host is not safe,jump to https://${domain_str}${pathname}`);
        location.href=`https://${domain_str}${pathname}`;
  }
</script>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <div class="l10n-header-widget">
    <script>
      // 获取当前页面的 URL
      const currentUrl = window.location.href;
      // 替换 URL 中的部分内容
      const jumpToL10nLink = currentUrl.replace('en.imzlp.com', 'imzlp.com');
      // 将 jumpToL10nLink 绑定到一个全局变量
      window.jumpToL10nLink = jumpToL10nLink;
    </script>

    <a href="#" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: none;" rel="noopener" target="_blank" onclick="window.open(window.jumpToL10nLink, '_blank'); return false;">
      <i class="fa fa-solid fa-language"></i>
    </a>
  </div>



    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en"
  >
    <link itemprop="mainEntityOfPage" href="https://en.imzlp.com/posts/27615/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
      <meta itemprop="name" content="LIPENGZHA">
      <meta itemprop="description" content=""I think, therefore I am"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Z's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Pointers to class members in C++ are not pointers<a href="https://github.com/imzlp/blog-md/blob/en/_posts/2017-04-29-27615.md" class="post-edit-link" title="Edit this post" style="float: right;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-pen-nib"></i></a><a href="https://imzlp.com/posts/27615/" class="post-l10n-link" title="切换至中文版本" style="float: left;border-bottom: 0px;" rel="noopener" target="_blank"><i class="fa fa-solid fa-language"></i></a>
        </h1>

        
          <div class="post-subtitle" style="text-align: center;line-height: 1;">
            <sub text-align="center" style="font-size: 15px;align-content: center;font-style: italic;bottom: 0em;">C++中指向类成员的指针并非指针</sub>
          </div>
        

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-04-29 21:28 21:28:17:28" itemprop="dateCreated datePublished" datetime="2017-04-29T21:28:17+00:00">2017-04-29 21:28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-04-22 00:38 00:38:56:38" itemprop="dateModified" datetime="2019-04-22T00:38:56+00:00">2019-04-22 00:38</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">技术笔记</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          
            <span id="/posts/27615/" class="post-meta-item leancloud_visitors" data-flag-title="Pointers to class members in C++ are not pointers" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>9.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>23 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>“Pointers to members” is a feature in C++ that is not commonly used. However, the use of the term “pointer” is somewhat inaccurate here, as they do not contain an address, and their behavior is not like pointers. This article will analyze how “pointers to class members” are implemented in clang through LLVM-IR, alongside some definitions from the C++14 standard and related LLVM-IR syntax.</p>
<span id="more"></span>
<p>Firstly, the C++ standard does not specify how “pointers to class members” should be implemented, as it relies on the implementation by the compiler. However, the standard indicates that “pointers to members” are distinctly different from ordinary pointers.</p>
<blockquote>
<p>The type “pointer to member” is distinct from the type “pointer”, that is, a pointer to member is declared only by the pointer to member declarator syntax, and never by the pointer declarator syntax. There is no “reference-to-member” type in C++.</p>
</blockquote>
<p>For ordinary pointers, they contain an address and can be dereferenced to access the pointed-to object indirectly.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> *xp=&amp;x;</span><br><span class="line">*xp=<span class="number">456</span>;</span><br></pre></td></tr></table></figure>
<p>However, a pointer to a member does not point to the memory address of a specific object. It points to a specific member of a class rather than to the member of a specified object. Let’s analyze what “pointers to members” actually are through the implementation of the Clang compiler. Assume we have the following class type:</p>
<h2 id="Pointers-to-Class-Data-Members"><a href="#Pointers-to-Class-Data-Members" class="headerlink" title="Pointers to Class Data Members"></a>Pointers to Class Data Members</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x=<span class="number">0</span>,<span class="type">double</span> y=<span class="number">0.0</span>,<span class="type">char</span> z=<span class="string">&#x27;\0&#x27;</span>):a&#123;x&#125;,b&#123;y&#125;,c&#123;z&#125;&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;void A::func()&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="type">double</span> b;</span><br><span class="line">	<span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Then we create a “pointer to class member” with the following code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// non-initializer</span></span><br><span class="line"><span class="type">int</span> A::*ap;</span><br><span class="line"><span class="type">double</span> A::*bp;</span><br><span class="line"><span class="type">char</span> A::*cp;</span><br></pre></td></tr></table></figure>
<p>The above is the uninitialized version. Let’s provide an initialized version, and later we’ll compare the LLVM-IR to see what “pointers to class data members” have been initialized to.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initializer</span></span><br><span class="line"><span class="type">int</span> A::*ap=&amp;A::a;</span><br><span class="line"><span class="type">double</span> A::*bp=&amp;A::b;</span><br><span class="line"><span class="type">char</span> A::*cp=&amp;A::c;</span><br></pre></td></tr></table></figure>
<p>By comparing with diff, we can observe the difference in the LLVM-IR code for both:</p>
<p><img data-src="https://img.imzlp.com/imgs/zlp/blog/posts/27615/pointer-to-member-diff-non-init-have-init.webp"></p>
<p>It can be seen that those with initialization do not store some kind of address in the “pointer to class data members,” but are actually an integer type. The implementation in Clang reflects that they are equal to the offset values of the data members within the class. For detailed content on class internal offset values, please refer to my other article: <a target="_blank" rel="noopener" href="https://imzlp.com/posts/61962/">Memory Alignment Issues with Structure Members</a>.</p>
<p>This means that the implementation of “pointers to class members” retrieves the offset value of that class member within the class, which also confirms the reason why “pointers to class members” cannot be accessed independently (they depend on a specific object)—they are simply offset values, requiring a specific object to access the sub-object at that offset.</p>
<p>Let’s try to access a specific object through a class object and a “pointer to data member”:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A x&#123;<span class="number">123</span>&#125;;</span><br><span class="line"><span class="type">int</span> A::*ap=&amp;A::a;</span><br><span class="line">x.*ap=<span class="number">888</span>;</span><br></pre></td></tr></table></figure>
<p>We can still check its LLVM-IR code:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Create class object x and call A&#x27;s constructor</span><br><span class="line">%2 = alloca %struct.A, align 8</span><br><span class="line">call void @_ZN1AC2Eidc(%struct.A* %2, i32 123, double 0.000000e+00, i8 0)</span><br><span class="line"># Initialize &quot;pointer to class data member&quot; ap (retrieve its offset value)</span><br><span class="line">%3 = alloca i64, align 8</span><br><span class="line">store i64 0, i64* %3, align 8</span><br><span class="line"></span><br><span class="line">%4 = load i64, i64* %3, align 8</span><br><span class="line">%5 = bitcast %struct.A* %2 to i8*</span><br><span class="line"># Access the sub-object (data member) through the specific object&#x27;s pointer and offset</span><br><span class="line">%6 = getelementptr inbounds i8, i8* %5, i64 %4</span><br><span class="line">%7 = bitcast i8* %6 to i32*</span><br><span class="line">store i32 888, i32* %7, align 4</span><br></pre></td></tr></table></figure>
<p>You can view the LLVM-IR syntax in the <a target="_blank" rel="noopener" href="http://llvm.org/docs/LangRef.html">LLVM Language Reference Manual</a>. </p>
<p>A relatively complex part here is the syntax of <code>getelementptr inbounds</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Syntax</span><br><span class="line">&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</span><br><span class="line">&lt;result&gt; = getelementptr inbounds &lt;ty&gt;, &lt;ty&gt;* &lt;ptrval&gt;&#123;, [inrange] &lt;ty&gt; &lt;idx&gt;&#125;*</span><br><span class="line">&lt;result&gt; = getelementptr &lt;ty&gt;, &lt;ptr vector&gt; &lt;ptrval&gt;, [inrange] &lt;vector index type&gt; &lt;idx&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The <code>getelementptr</code> instruction is used to get the address of a subelement of an aggregate data structure. It performs address calculation only and does not access memory. The instruction can also be used to calculate a vector of such addresses.</p>
</blockquote>
<ul>
<li>The first argument is always a type used as the basis for the calculations.</li>
<li>The second argument is always a pointer or a vector of pointers, and is the base address to start from.</li>
<li>The remaining arguments are indices that indicate which of the elements of the aggregate object are indexed.</li>
</ul>
<blockquote>
<p>The interpretation of each index is dependent on the type being indexed into. The first index always indexes the pointer value given as the first argument, the second index indexes a value of the type pointed to (not necessarily the value directly pointed to, since the first index can be non-zero), etc. The first type indexed into must be a pointer value, subsequent types can be arrays, vectors, and structs. Note that subsequent types being indexed into can never be pointers, since that would require loading the pointer before continuing calculation.</p>
</blockquote>
<p>There won’t be more elaboration on LLVM-IR; let’s return to analyzing “pointers to data members.”</p>
<p>When we assign an initial value to a “pointer to class data members,” we are effectively obtaining the offset of that data member within the class. Unless the <code>&amp;</code> operator is applied to a static data member within a class, it does not yield an actual address, but rather an offset.</p>
<p>This should also be why the C++ standard stipulates that “pointers to class members” cannot point to static members:</p>
<blockquote>
<p><strong>[ISO/IEC 14882:2014]</strong> A pointer to member shall not point to a static member of a class (9.4), a member with reference type, or “cv void.”</p>
</blockquote>
<p>Previously, it was briefly mentioned that “pointers to members” cannot be accessed independently—they require a specific class A object. This is because “pointers to members” are merely the offset of that member within the class; to access the sub-object (data member) at that offset, we need the address of an object of class (A).</p>
<p>When we use <code>.*</code> or <code>-&gt;*</code> to access an offset through a class object or pointer, what gets executed is the <code>getelementptr inbounds</code> part of the LLVM-IR code provided above.</p>
<h2 id="Pointers-to-Class-Member-Functions"><a href="#Pointers-to-Class-Member-Functions" class="headerlink" title="Pointers to Class Member Functions"></a>Pointers to Class Member Functions</h2><p>The previous section covered “pointers to class data members” and their implementation in clang. Now, “pointers to class member functions” differ slightly from “pointers to class data members.” </p>
<p>An implementation of a pointer to a member function must store certain information, such as whether the function it’s pointing to is a virtual function or a non-virtual function, and how to find the appropriate virtual table pointer. Therefore, the implementation of pointers to class member functions often consists of a small structure to store this critical information.</p>
<blockquote>
<p>Note: There is no pointer to a virtual function. A virtual function is a property of the function itself, not an attribute of the pointer to a class member function.</p>
</blockquote>
<p>Following the same logic as the previous section, we first create a “pointer to a class member function.” Unlike ordinary function pointers, initializing a “pointer to a member function” must use the address operator on a member function within the class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (A::*funcp)();</span><br></pre></td></tr></table></figure>
<p>Its LLVM-IR code would be:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>It can be seen that, in clang, a <strong>pointer to class member functions</strong> is different from a <strong>pointer to class data members</strong>. “Pointers to class member functions” have a structure containing two <code>i64</code> objects. Let’s attempt an initialization operation:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (A::*funcp)()=&amp;A::func;</span><br></pre></td></tr></table></figure>
<p>We can check its LLVM-IR code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">3</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br><span class="line">store &#123; i64, i64 &#125; &#123; i64 <span class="built_in">ptrtoint</span> (<span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)* @_ZN1A4funcEv to i64), i64 <span class="number">0</span> &#125;, &#123; i64, i64 &#125;* %<span class="number">3</span>, align <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>It can be seen that here the function address of A::func (which takes a pointer to class A and does not return) is converted to i64, and is stored in the member pointer structure. The second parameter is an offset modifier for the this pointer, as the position of data members is not absolute but relative to the base class in class inheritance scenarios. This offset can be represented using the <code>ptrdiff_t</code> type, as seen in the following example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;A::func&quot;</span>&lt;&lt;<span class="string">&quot;, this ptr address is &quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> pad16[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;B::Bar&quot;</span>&lt;&lt;<span class="string">&quot;, this ptr address is &quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> pad8[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> A,<span class="keyword">public</span> B&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	C cobj;</span><br><span class="line">	<span class="built_in">void</span>(C::*Afunc)()=&amp;C::func;</span><br><span class="line">	<span class="built_in">void</span>(C::*Bbar)()=&amp;C::bar;</span><br><span class="line"></span><br><span class="line">	(cobj.*Afunc)();</span><br><span class="line">	(cobj.*Bbar)();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line">A::func, <span class="keyword">this</span> ptr address is <span class="number">0x61fe30</span></span><br><span class="line">B::Bar, <span class="keyword">this</span> ptr address is <span class="number">0x61fe40</span></span><br></pre></td></tr></table></figure>

<p>As can be observed, the difference between the two this addresses is the size of the memory layout of the A class object. Now let’s look at the IR code for the member function pointer assignment:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">define i32 @<span class="built_in">main</span>() #<span class="number">4</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  %<span class="number">2</span> = alloca %<span class="keyword">class</span>.C, align <span class="number">1</span></span><br><span class="line">  %<span class="number">3</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br><span class="line">  %<span class="number">4</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br><span class="line">  store &#123; i64, i64 &#125; &#123; i64 <span class="built_in">ptrtoint</span> (<span class="built_in">void</span> (%<span class="keyword">class</span>.A*)* @_ZN1A4funcEv to i64), i64 <span class="number">0</span> &#125;, &#123; i64, i64 &#125;* %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line">  store &#123; i64, i64 &#125; &#123; i64 <span class="built_in">ptrtoint</span> (<span class="built_in">void</span> (%<span class="keyword">class</span>.B*)* @_ZN1B3barEv to i64), i64 <span class="number">16</span> &#125;, &#123; i64, i64 &#125;* %<span class="number">4</span>, align <span class="number">8</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above code allocates two structures for member functions—two int64. The first member is used to store the member function pointer, while the second is used to store the offset of the this pointer. </p>
<p>Understanding this pattern allows us to directly extract the real function pointer address of the member function pointer (by retrieving the first element of its structure):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> ival)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::cout&lt;&lt;<span class="string">&quot;HelloWorld,&quot;</span>&lt;&lt;<span class="string">&quot;ival = &quot;</span>&lt;&lt;ival&lt;&lt;std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="built_in">void</span>(A::*Afunc)(<span class="type">int</span>);</span><br><span class="line">		<span class="built_in">void</span>(*realAfunc[<span class="number">2</span>])(A*,<span class="type">int</span>);</span><br><span class="line">	&#125;AfuncAddr;</span><br><span class="line">	AfuncAddr.Afunc=&amp;A::func;</span><br><span class="line"></span><br><span class="line">	AfuncAddr.realAfunc[<span class="number">0</span>](<span class="literal">NULL</span>,<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line">HelloWorld, ival = <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>However, using this method is <strong>undefined behavior</strong> because the this pointer passed is <code>NULL</code>, and if the member function depends on this operation (like polymorphism or accessing member variables), it will crash.</p>
<p>In summary, when using member function pointers, we need to call them with an object of class A (since <code>.*</code> and <code>-&gt;*</code> have lower precedence than <code>()</code>, parentheses are required for <code>x.*funcp</code>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">x</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (A::*funcp)()=&amp;A::func;</span><br><span class="line">(x.*funcp)();</span><br></pre></td></tr></table></figure>
<p>Its LLVM-IR code would be:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">2</span> = alloca %<span class="keyword">struct</span>.A, align <span class="number">8</span></span><br><span class="line">call <span class="type">void</span> @_ZN1AC2Eidc(%<span class="keyword">struct</span>.A* %<span class="number">2</span>, i3 <span class="number">123</span>, <span class="type">double</span> <span class="number">0.000000e+00</span>, i8 <span class="number">0</span>)</span><br><span class="line">%<span class="number">3</span> = alloca &#123; i64, i64 &#125;, align <span class="number">8</span></span><br><span class="line"># Store the member function address into allocated <span class="built_in">space</span> (%<span class="number">3</span>)</span><br><span class="line">store &#123; i64, i64 &#125; &#123; i64 <span class="built_in">ptrtoint</span> (<span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)* @_ZN1A4funcEv to i64), i64 <span class="number">0</span> &#125;, &#123; i64, i64 &#125;* %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line"></span><br><span class="line">%<span class="number">4</span> = load &#123; i64, i64 &#125;, &#123; i64, i64 &#125;* %<span class="number">3</span>, align <span class="number">8</span></span><br><span class="line"># Retrieve the second i64 data from the structure <span class="keyword">and</span> place into %<span class="number">5</span></span><br><span class="line">%<span class="number">5</span> = extractvalue &#123; i64, i64 &#125; %<span class="number">4</span>, <span class="number">1</span></span><br><span class="line">%<span class="number">6</span> = bitcast %<span class="keyword">struct</span>.A* %<span class="number">2</span> to i8*</span><br><span class="line"># Access the sub-object at the offset of <span class="keyword">this</span> object</span><br><span class="line">%<span class="number">7</span> = getelementptr inbounds i8, i8* %<span class="number">6</span>, i64 %<span class="number">5</span></span><br><span class="line">%<span class="number">8</span> = bitcast i8* %<span class="number">7</span> to %<span class="keyword">struct</span>.A*</span><br><span class="line"># Retrieve the first i64 data from the structure <span class="keyword">and</span> place into %<span class="number">9</span></span><br><span class="line">%<span class="number">9</span> = extractvalue &#123; i64, i64 &#125; %<span class="number">4</span>, <span class="number">0</span></span><br><span class="line"># Perform bitwise AND operation on %<span class="number">9</span> with <span class="number">1</span></span><br><span class="line">%<span class="number">10</span> = <span class="keyword">and</span> i64 %<span class="number">9</span>, <span class="number">1</span></span><br><span class="line"># Check <span class="keyword">if</span> %<span class="number">10</span> is <span class="keyword">not</span> equal to <span class="number">0</span> (ne <span class="keyword">for</span> <span class="keyword">not</span> equal)</span><br><span class="line">%<span class="number">11</span> = icmp ne i64 %<span class="number">10</span>, <span class="number">0</span></span><br><span class="line"># Based on the above check result, execute different branches</span><br><span class="line">br i1 %<span class="number">11</span>, label %<span class="number">12</span>, label %<span class="number">19</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">12</span>:                                     ; preds = %<span class="number">0</span></span><br><span class="line">%<span class="number">13</span> = bitcast %<span class="keyword">struct</span>.A* %<span class="number">8</span> to i8**</span><br><span class="line">%<span class="number">14</span> = load i8*, i8** %<span class="number">13</span>, align <span class="number">8</span></span><br><span class="line">%<span class="number">15</span> = sub i64 %<span class="number">9</span>, <span class="number">1</span></span><br><span class="line">%<span class="number">16</span> = getelementptr i8, i8* %<span class="number">14</span>, i64 %<span class="number">15</span></span><br><span class="line">%<span class="number">17</span> = bitcast i8* %<span class="number">16</span> to <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)**</span><br><span class="line">%<span class="number">18</span> = load <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)*, <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)** %<span class="number">17</span>, align <span class="number">8</span></span><br><span class="line">br label %<span class="number">21</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">19</span>:                                     ; preds = %<span class="number">0</span></span><br><span class="line">%<span class="number">20</span> = inttoptr i64 %<span class="number">9</span> to <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)*</span><br><span class="line">br label %<span class="number">21</span></span><br><span class="line"></span><br><span class="line">; &lt;label&gt;:<span class="number">21</span>:                                     ; preds = %<span class="number">19</span>, %<span class="number">12</span></span><br><span class="line">%<span class="number">22</span> = phi <span class="built_in">void</span> (%<span class="keyword">struct</span>.A*)* [ %<span class="number">18</span>, %<span class="number">12</span> ], [ %<span class="number">20</span>, %<span class="number">19</span> ]</span><br><span class="line"></span><br><span class="line"># Call member function via <span class="keyword">class</span> <span class="built_in">pointer</span> (similarly to <span class="keyword">class</span> internal member functions having <span class="keyword">this</span> pointer)</span><br><span class="line"># The reason member function pointers need to be called with an object <span class="keyword">or</span> pointer is that it is required here to supplement the <span class="keyword">this</span> pointer needed <span class="keyword">for</span> the standalone member function pointer</span><br><span class="line">call <span class="type">void</span> %<span class="number">22</span>(%<span class="keyword">struct</span>.A* %<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>Moreover, pointers to member functions exhibit a form of covariance: there exists a conversion from a pointer to a base class member function to a pointer to a derived class member function, whereas the reverse is not permissible.</p>
<p>For example, we have the following class:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">base</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;base::func()&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>:<span class="keyword">public</span> base&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;A::func&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>It is possible to convert from pointers to base class member functions to pointers to derived class member functions (exhibiting polymorphism):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (A::*AfuncP)()=&amp;base::func;</span><br><span class="line">A aobj;</span><br><span class="line">(aobj.*AfuncP)(); <span class="comment">// output:A::func()</span></span><br></pre></td></tr></table></figure>
<p>However, the reverse results in a compilation error:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error: cannot initialize a variable of type &#x27;void (base::*)()&#x27; with an rvalue of type &#x27;void (A::*)()&#x27;:different classes (&#x27;base&#x27; vs &#x27;A&#x27;)</span></span><br><span class="line"><span class="built_in">void</span> (base::*baseFuncp)()=&amp;A::func;</span><br></pre></td></tr></table></figure>

<h3 id="Combining-with-STL"><a href="#Combining-with-STL" class="headerlink" title="Combining with STL"></a>Combining with STL</h3><p>Pointers to member functions can be implemented through the standard library’s <code>mem_fun</code> adapter to make them behave like function objects (functors), allowing them to be applied in related algorithms (use <code>std::mem_fun</code> when containers hold pointers and <code>std::mem_fun_ref</code> when they hold references). </p>
<p>For instance, performing the member function operation on all objects stored in a container:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;C::func&quot;</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;C&gt; x;</span><br><span class="line">	x.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line">	std::for_each(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(),std::<span class="built_in">mem_fun_ref</span>(&amp;C::func));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">C::func</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Let’s look at a simple implementation of <code>std::mem_fun</code> (SGISTL, a bit outdated):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">mem_fun_ref_t</span> : <span class="keyword">public</span> unary_function&lt;_Tp,_Ret&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">mem_fun_ref_t</span><span class="params">(_Ret (_Tp::*__pf)())</span> : _M_f(__pf) &#123;</span>&#125;</span><br><span class="line">  <span class="function">_Ret <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp&amp; __r)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (__r.*_M_f)(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  _Ret (_Tp::*_M_f)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Ret</span>, <span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">mem_fun_ref_t</span>&lt;_Ret,_Tp&gt; <span class="title">mem_fun_ref</span><span class="params">(_Ret (_Tp::*__f)())</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">mem_fun_ref_t</span>&lt;_Ret,_Tp&gt;(__f); &#125;</span><br></pre></td></tr></table></figure>
<p>It can be observed that the SGISTL implementation creates a function object that wraps the member function, which receives a passed instance of the member function’s class as an argument (pointer or reference, here only the implementation of <code>std::mem_fun_ref</code> is shown, while <code>std::mem_fun</code> is similar).</p>
<p>In light of the SGISTL implementation limitations—it can only call non-parameterized member functions (this can depend on different STL implementations). What if we want to call parameterized member functions? We can use <code>std::bind</code>! Unlike C++11’s <code>std::bind1st</code> and <code>std::bind2nd</code>, which were clumsy, C++11’s <code>std::bind</code> is a real gem as it does not restrict the number of parameters!</p>
<p>Let’s slightly modify the class C to take a parameter:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">	<span class="built_in">C</span>(<span class="type">const</span> <span class="type">int</span>&amp; x):ival&#123;x&#125;&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; iArg)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;ival+=iArg;</span><br><span class="line">		std::cout&lt;&lt;<span class="keyword">this</span>-&gt;ival&lt;&lt;std::endl;</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> ival;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If we then use <code>std::mem_fun</code> for adaptation, an error message <strong>no matching function</strong> will appear. We can use <code>std::bind</code> instead:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;C&gt; c&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">std::for_each(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(),std::<span class="built_in">bind</span>(&amp;C::func,_1,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>
<p>Since member function pointers need to be accessed through class pointers or class objects, the first argument must be passed to the member function pointer bound in bind.</p>
<h3 id="Conversion-from-Member-Function-Pointer-to-Ordinary-Function-Pointer"><a href="#Conversion-from-Member-Function-Pointer-to-Ordinary-Function-Pointer" class="headerlink" title="Conversion from Member Function Pointer to Ordinary Function Pointer"></a>Conversion from Member Function Pointer to Ordinary Function Pointer</h3><p>From the above discussion, we learn that member function pointers form a structure with the first element storing the member function pointer and the second storing the offset of the this pointer. Together, they constitute the member function pointer, and indeed you might have realized: class member functions are functions with this pointers:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Thus, the function pointer of the member function func is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span>(*)(A*,<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*);</span><br></pre></td></tr></table></figure>
<p>Therefore, if we want to convert a member function pointer to a function pointer format, we simply need to retrieve the first element of the member function pointer structure:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*)</span></span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;A::func\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gfunc</span><span class="params">(<span class="type">void</span>(*pfunc)(A*,<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A obj;</span><br><span class="line">	<span class="comment">// (obj.*pfunc)();</span></span><br><span class="line">	<span class="built_in">pfunc</span>(&amp;obj,<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span>&#123;</span><br><span class="line">	<span class="built_in">void</span>(A::*func)(<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*);</span><br><span class="line">	<span class="built_in">void</span>(*pure_func)(A*,<span class="type">int</span>,<span class="type">double</span>,<span class="type">void</span>*);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	U unionObj;</span><br><span class="line">	unionObj.func=&amp;A::func;</span><br><span class="line">	<span class="built_in">gfunc</span>(unionObj.pure_func);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This allows us to assign from a member function pointer to an ordinary function pointer. Direct conversion is not permitted (as observed by compilers); using a union can bypass the compiler restrictions, making this approach more versatile.</p>
<h2 id="Update-Log"><a href="#Update-Log" class="headerlink" title="Update Log"></a>Update Log</h2><p><strong>2017.05.11</strong></p>
<ul>
<li>Added content on the use of standard library with pointers to member functions.</li>
</ul>
<p><strong>2018.09.25</strong></p>
<ul>
<li>Supplemented content on the struct initialization of member function pointers.</li>
</ul>
<p><strong>2018.11.06</strong></p>
<ul>
<li>Added content on converting from member function pointers to ordinary function pointers.</li>
</ul>
<p><strong>2019.04.22</strong></p>
<ul>
<li>Enhanced information on extracting raw function pointers from the member function pointer structure.</li>
</ul>

    </div>

    
    
        
        
          
            <blockquote class="blockquote-center">
              
                The article is finished. If you have any questions, please comment and communicate.
              
            <br/>
            
                <div class="qr-code" onclick="return false">
                    <script src="/js/qrcode.min.js"></script>
                    <div id="qrcode">
                      
                        <img src="https://imzlp.com/images/wechat-qrcode.webp">
                      
                    <p>Scan the QR code on WeChat and follow me.</p>
                    </div>
                </div>
            
            </blockquote>
          
        

        
          <div class="postCopyright" style="clear:both;">
             <span>Title:</span><a href="/posts/27615/" target="_blank">Pointers to class members in C++ are not pointers</a><br/>
             <span>Author:</span><a href="/about" target="_blank" title="查看 LIPENGZHA 的资料">LIPENGZHA</a><br/>
             <span>Publish Date:</span>2017/04/29 21:28<br/>
             
              <span>Update Date:</span>2019/04/22 00:38<br/>
             
             <span>Word Count:</span><span class="page-count">9.3k Words</span><br/>
             
             <span>Link:</span><a href="/posts/27615/" target="_blank" title="Pointers to class members in C++ are not pointers">https://en.imzlp.com/posts/27615/</a>
             <span class="copy-path" data-clipboard-text="Link: https://en.imzlp.com/posts/27615/ Author: LIPENGZHA" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
             <script src="/js/jquery.min.js"></script>
             <script src="/js/clipboard.min.js"></script>
             <script> var clipboard = new Clipboard('.copy-path'); </script>
             <br/>
             
             <span>License:</span><i class="fab fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" title="Attribution-NonCommercial-ShareAlike 4.0 International">CC BY-NC-SA 4.0</a><br/>
             
             <span>Reprinting of the full article is prohibited.</span>
          </div>
        
    

        
  <div class="reward-container">
    <div>Your donation will encourage me to keep creating!</div>
    <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
      Donate
    </button>
    <div id="qr" style="display: none;">
        
        <div style="display: inline-block;">
          <img src="/images/reward/wechatpay.webp" alt="LIPENGZHA WeChat Pay">
          <p>WeChat Pay</p>
        </div>

    </div>
  </div>



      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/" rel="tag"># 技术笔记</a>
              <a href="/tags/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag"># 编程笔记</a>
              <a href="/tags/C-%E6%A0%87%E5%87%86/" rel="tag"># C++标准</a>
              <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81/" rel="tag"># 中间代码</a>
              <a href="/tags/LLVM-IR/" rel="tag"># LLVM-IR</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/10380/" rel="prev" title="Specialization and overloading of C++ function templates">
      <i class="fa fa-chevron-left"></i> Specialization and overloading of C++ function templates
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/5392/" rel="next" title="Why is extern "C" needed?">
      Why is extern "C" needed? <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
      <div class="tabs tabs-comment">
        <ul class="nav-tabs">
            <li class="tab"><a href="#comment-utteranc">utteranc</a></li>
            <li class="tab"><a href="#comment-valine">valine</a></li>
        </ul>
        <div class="tab-content">
            <div class="tab-pane utteranc" id="comment-utteranc">
              
  
  <div class="comments">
  <script src="https://utteranc.es/client.js" repo="hxhb/blog-comments" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script>
  </div>
  
  
            </div>
            <div class="tab-pane valine" id="comment-valine">
              <div class="comments" id="valine-comments"></div>
            </div>
        </div>
      </div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Pointers-to-Class-Data-Members"><span class="nav-number">1.</span> <span class="nav-text">Pointers to Class Data Members</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pointers-to-Class-Member-Functions"><span class="nav-number">2.</span> <span class="nav-text">Pointers to Class Member Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Combining-with-STL"><span class="nav-number">2.1.</span> <span class="nav-text">Combining with STL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conversion-from-Member-Function-Pointer-to-Ordinary-Function-Pointer"><span class="nav-number">2.2.</span> <span class="nav-text">Conversion from Member Function Pointer to Ordinary Function Pointer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Update-Log"><span class="nav-number">3.</span> <span class="nav-text">Update Log</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person" oncontextmenu="return false" οndragstart="return false">
    <img class="site-author-image" itemprop="image" alt="LIPENGZHA"
      src="https://img.imzlp.com/imgs/zlp/picgo/2023/202304152112902.webp">
  <p class="site-author-name" itemprop="name">LIPENGZHA</p>
  <div class="site-description" itemprop="description">"I think, therefore I am"</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
             
          <span class="site-state-item-count">190</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">95</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">190</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxhb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hxhb" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://linkedin.com/in/lipengzha" title="Linkedin → https:&#x2F;&#x2F;linkedin.com&#x2F;in&#x2F;lipengzha" rel="noopener" target="_blank"><i class="fab fa-linkedin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/imzlp" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;imzlp" rel="noopener" target="_blank"><i class="fa fa-custom zhihu fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/images/wechat-qrcode-offical.webp" title="微信公众号 → &#x2F;images&#x2F;wechat-qrcode-offical.webp"><i class="fab fa-weixin fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:imzlp@foxmail.com" title="E-Mail → mailto:imzlp@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://consolehelp.imzlp.com/" title="https:&#x2F;&#x2F;consolehelp.imzlp.com&#x2F;" rel="noopener" target="_blank">UE Console Help</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/opensource/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;opensource&#x2F;" rel="noopener" target="_blank">Open Source Projects</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://imzlp.com/posts/11515/" title="https:&#x2F;&#x2F;imzlp.com&#x2F;posts&#x2F;11515&#x2F;" rel="noopener" target="_blank">UE C++ API Dash Documents</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://ue5wiki.com/" title="https:&#x2F;&#x2F;ue5wiki.com&#x2F;" rel="noopener" target="_blank">Unreal Engine Wiki</a>
        </li>
    </ul>
  </div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LIPENGZHA</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">1.5m</span>
</div>
  <div class="powered-by-other">
    
	    <center>Github Pages | Actions | NeXT | Cloudflare | Hexo Deploy</center>
      
  </div>

<script>
function checkWebp(callback) {
    var img = new Image();
    img.onload = function () { callback((img.width > 0) && (img.height > 0)); };
    img.onerror = function () { callback(false); };
    img.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
}
function showImage(useWebp) {
    var imgs = [].slice.call(document.querySelectorAll('img'));
    imgs.forEach(function (e) {
        if (!useWebp) {
            var src = e.getAttribute('data-src')
            src = src.replace(/\.webp$/, '.png');
            e.setAttribute('data-src', src);
        }
    });
}
checkWebp(showImage);
</script>

        








      </div>
    </footer>
  </div>

  
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/animejs/3.2.1/anime.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/jquery/3.5.1/jquery.min.js"></script>
  <script src="//lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="//lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/pangu/4.0.7/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>



<script src="/js/code-unfold.js"></script>

  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>


<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  
  <script src="//img.imzlp.com/imgs/zlp/picgo/2021/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://en.imzlp.com/posts/27615/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/valine/1.4.14/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    var requiredFields = 'nick';
    requiredFields = requiredFields.split(',');
    
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'oCE6RMVkVoi5MgUhvFsn1EvV-gzGzoHsz',
      appKey     : 'K9SOaNYJ8PV6xaoFggWG5xvv',
      placeholder: "Leave something behind~",
      avatar     : 'robohash',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'en' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields: requiredFields
    });
  }, window.Valine);
});
</script>

</body>
</html>
